; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\motor.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\motor.d --feedback=.\Objects\Project.fed --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\Start -I.\User -I.\Library -I.\System -I.\System\delay -I.\System\sys -I.\System\usart -I.\Hardware\Encoder -I.\Hardware\Motor -I.\Hardware\MPU6050 -I.\Hardware\MPU6050\eMPL -I.\Hardware\OLED -I.\Hardware\PWM -I.\Public\Bit-Band -I.\Public\SystemClock -I.\Public\SysTick-Timer -I.\Hardware\Control -IC:\Users\GCP\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__UVISION_VERSION=535 -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\motor.crf Hardware\Motor\Motor.c]
                          THUMB

                          AREA ||i.Limit||, CODE, READONLY, ALIGN=2

                  Limit PROC
;;;24     
;;;25     void Limit(int *motoA,int *motoB)			//限幅
000000  6802              LDR      r2,[r0,#0]
;;;26     {
;;;27     	if(*motoA>PWM_MAX)*motoA=PWM_MAX;
000002  f5b25fe1          CMP      r2,#0x1c20
000006  dd02              BLE      |L1.14|
000008  f44f52e1          MOV      r2,#0x1c20
00000c  6002              STR      r2,[r0,#0]
                  |L1.14|
;;;28     	if(*motoA<PWM_MIN)*motoA=PWM_MIN;
00000e  6802              LDR      r2,[r0,#0]
000010  f5125fe1          CMN      r2,#0x1c20
000014  da01              BGE      |L1.26|
000016  4a08              LDR      r2,|L1.56|
000018  6002              STR      r2,[r0,#0]
                  |L1.26|
;;;29     	
;;;30     	if(*motoB>PWM_MAX)*motoB=PWM_MAX;
00001a  680a              LDR      r2,[r1,#0]
00001c  f5b25fe1          CMP      r2,#0x1c20
000020  dd02              BLE      |L1.40|
000022  f44f52e1          MOV      r2,#0x1c20
000026  600a              STR      r2,[r1,#0]
                  |L1.40|
;;;31     	if(*motoB<PWM_MIN)*motoB=PWM_MIN;
000028  680a              LDR      r2,[r1,#0]
00002a  f5125fe1          CMN      r2,#0x1c20
00002e  da01              BGE      |L1.52|
000030  4a01              LDR      r2,|L1.56|
000032  600a              STR      r2,[r1,#0]
                  |L1.52|
;;;32     }
000034  4770              BX       lr
;;;33     
                          ENDP

000036  0000              DCW      0x0000
                  |L1.56|
                          DCD      0xffffe3e0

                          AREA ||i.Load||, CODE, READONLY, ALIGN=2

                  Load PROC
;;;33     
;;;34     void Load(int moto1, int moto2)				//控制正反转
000000  b570              PUSH     {r4-r6,lr}
;;;35     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;36     	//1.研究正负号，对应正反转
;;;37     	if(moto1>0)	
000006  2c00              CMP      r4,#0
000008  dd07              BLE      |L2.26|
;;;38         	Ain1=1,Ain2=0;//正转
00000a  2001              MOVS     r0,#1
00000c  4919              LDR      r1,|L2.116|
00000e  6008              STR      r0,[r1,#0]
000010  2000              MOVS     r0,#0
000012  4919              LDR      r1,|L2.120|
000014  f8c101bc          STR      r0,[r1,#0x1bc]
000018  e006              B        |L2.40|
                  |L2.26|
;;;39     	else 				
;;;40         	Ain1=0,Ain2=1;//反转
00001a  2000              MOVS     r0,#0
00001c  4915              LDR      r1,|L2.116|
00001e  6008              STR      r0,[r1,#0]
000020  2001              MOVS     r0,#1
000022  4915              LDR      r1,|L2.120|
000024  f8c101bc          STR      r0,[r1,#0x1bc]
                  |L2.40|
;;;41     	//2.研究PWM值
;;;42     	TIM_SetCompare1(TIM1,abs(moto1));
000028  1e26              SUBS     r6,r4,#0
00002a  db01              BLT      |L2.48|
00002c  4630              MOV      r0,r6
00002e  e000              B        |L2.50|
                  |L2.48|
000030  4270              RSBS     r0,r6,#0
                  |L2.50|
000032  b281              UXTH     r1,r0
000034  4811              LDR      r0,|L2.124|
000036  f7fffffe          BL       TIM_SetCompare1
;;;43     	
;;;44       	//1.研究正负号，对应正反转
;;;45     	if(moto2>0)
00003a  2d00              CMP      r5,#0
00003c  dd08              BLE      |L2.80|
;;;46         	Bin1=1,Bin2=0;
00003e  2001              MOVS     r0,#1
000040  490c              LDR      r1,|L2.116|
000042  1f09              SUBS     r1,r1,#4
000044  6008              STR      r0,[r1,#0]
000046  2000              MOVS     r0,#0
000048  490b              LDR      r1,|L2.120|
00004a  f8c101b0          STR      r0,[r1,#0x1b0]
00004e  e007              B        |L2.96|
                  |L2.80|
;;;47     	else 				
;;;48         	Bin1=0,Bin2=1;	
000050  2000              MOVS     r0,#0
000052  4908              LDR      r1,|L2.116|
000054  1f09              SUBS     r1,r1,#4
000056  6008              STR      r0,[r1,#0]
000058  2001              MOVS     r0,#1
00005a  4907              LDR      r1,|L2.120|
00005c  f8c101b0          STR      r0,[r1,#0x1b0]
                  |L2.96|
;;;49       	//2.研究PWM值
;;;50     	TIM_SetCompare4(TIM1,abs(moto2));
000060  1e2e              SUBS     r6,r5,#0
000062  db01              BLT      |L2.104|
000064  4630              MOV      r0,r6
000066  e000              B        |L2.106|
                  |L2.104|
000068  4270              RSBS     r0,r6,#0
                  |L2.106|
00006a  b281              UXTH     r1,r0
00006c  4803              LDR      r0,|L2.124|
00006e  f7fffffe          BL       TIM_SetCompare4
;;;51     }
000072  bd70              POP      {r4-r6,pc}
;;;52     
                          ENDP

                  |L2.116|
                          DCD      0x422181b8
                  |L2.120|
                          DCD      0x42218000
                  |L2.124|
                          DCD      0x40012c00

                          AREA ||i.Motor_Init||, CODE, READONLY, ALIGN=2

                  Motor_Init PROC
;;;3      
;;;4      void Motor_Init(void)
000000  b508              PUSH     {r3,lr}
;;;5      {
;;;6      	GPIO_InitTypeDef GPIO_InitStructure;
;;;7      	
;;;8      	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
000002  2101              MOVS     r1,#1
000004  2008              MOVS     r0,#8
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;9      	
;;;10     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
00000a  2010              MOVS     r0,#0x10
00000c  f88d0003          STRB     r0,[sp,#3]
;;;11     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
000010  f44f4070          MOV      r0,#0xf000
000014  f8ad0000          STRH     r0,[sp,#0]
;;;12     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000018  2003              MOVS     r0,#3
00001a  f88d0002          STRB     r0,[sp,#2]
;;;13     	
;;;14     	GPIO_Init(GPIOB, &GPIO_InitStructure);
00001e  4669              MOV      r1,sp
000020  4801              LDR      r0,|L3.40|
000022  f7fffffe          BL       GPIO_Init
;;;15     	
;;;16     }
000026  bd08              POP      {r3,pc}
;;;17     
                          ENDP

                  |L3.40|
                          DCD      0x40010c00

                          AREA ||i.abs||, CODE, READONLY, ALIGN=1

                  abs PROC
;;;17     
;;;18     int abs(int p)								//绝对值函数
000000  4601              MOV      r1,r0
;;;19     {
;;;20     	int q;
;;;21     	q=p>0?p:(-p);
000002  2900              CMP      r1,#0
000004  dd01              BLE      |L4.10|
000006  460a              MOV      r2,r1
000008  e000              B        |L4.12|
                  |L4.10|
00000a  424a              RSBS     r2,r1,#0
                  |L4.12|
00000c  4610              MOV      r0,r2
;;;22     	return q;
;;;23     }
00000e  4770              BX       lr
;;;24     
                          ENDP

