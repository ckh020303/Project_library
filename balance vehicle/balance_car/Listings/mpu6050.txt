; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\mpu6050.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\mpu6050.d --feedback=.\Objects\Project.fed --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\Start -I.\User -I.\Library -I.\System -I.\System\delay -I.\System\sys -I.\System\usart -I.\Hardware\Encoder -I.\Hardware\Motor -I.\Hardware\MPU6050 -I.\Hardware\MPU6050\eMPL -I.\Hardware\OLED -I.\Hardware\PWM -I.\Public\Bit-Band -I.\Public\SystemClock -I.\Public\SysTick-Timer -I.\Hardware\Control -IC:\Users\GCP\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__UVISION_VERSION=535 -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\mpu6050.crf Hardware\MPU6050\mpu6050.c]
                          THUMB

                          AREA ||i.MPU_Get_Accelerometer||, CODE, READONLY, ALIGN=1

                  MPU_Get_Accelerometer PROC
;;;110    //    其他,错误代码
;;;111    u8 MPU_Get_Accelerometer(short *ax,short *ay,short *az)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;112    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;113        u8 buf[6],res;  
;;;114    	res=MPU_Read_Len(MPU_ADDR,MPU_ACCEL_XOUTH_REG,6,buf);
00000a  466b              MOV      r3,sp
00000c  2206              MOVS     r2,#6
00000e  213b              MOVS     r1,#0x3b
000010  2068              MOVS     r0,#0x68
000012  f7fffffe          BL       MPU_Read_Len
000016  4607              MOV      r7,r0
;;;115    	if(res==0)
000018  b9bf              CBNZ     r7,|L1.74|
;;;116    	{
;;;117    		*ax=((u16)buf[0]<<8)|buf[1];  
00001a  f89d0001          LDRB     r0,[sp,#1]
00001e  f89d1000          LDRB     r1,[sp,#0]
000022  ea402001          ORR      r0,r0,r1,LSL #8
000026  b200              SXTH     r0,r0
000028  8020              STRH     r0,[r4,#0]
;;;118    		*ay=((u16)buf[2]<<8)|buf[3];  
00002a  f89d0003          LDRB     r0,[sp,#3]
00002e  f89d1002          LDRB     r1,[sp,#2]
000032  ea402001          ORR      r0,r0,r1,LSL #8
000036  b200              SXTH     r0,r0
000038  8028              STRH     r0,[r5,#0]
;;;119    		*az=((u16)buf[4]<<8)|buf[5];
00003a  f89d0005          LDRB     r0,[sp,#5]
00003e  f89d1004          LDRB     r1,[sp,#4]
000042  ea402001          ORR      r0,r0,r1,LSL #8
000046  b200              SXTH     r0,r0
000048  8030              STRH     r0,[r6,#0]
                  |L1.74|
;;;120    	} 	
;;;121        return res;;
00004a  4638              MOV      r0,r7
;;;122    }
00004c  e8bd81fc          POP      {r2-r8,pc}
;;;123    //IIC连续写
                          ENDP


                          AREA ||i.MPU_Get_Gyroscope||, CODE, READONLY, ALIGN=1

                  MPU_Get_Gyroscope PROC
;;;94     //    其他,错误代码
;;;95     u8 MPU_Get_Gyroscope(short *gx,short *gy,short *gz)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;96     {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;97         u8 buf[6],res;  
;;;98     	res=MPU_Read_Len(MPU_ADDR,MPU_GYRO_XOUTH_REG,6,buf);
00000a  466b              MOV      r3,sp
00000c  2206              MOVS     r2,#6
00000e  2143              MOVS     r1,#0x43
000010  2068              MOVS     r0,#0x68
000012  f7fffffe          BL       MPU_Read_Len
000016  4607              MOV      r7,r0
;;;99     	if(res==0)
000018  b9bf              CBNZ     r7,|L2.74|
;;;100    	{
;;;101    		*gx=((u16)buf[0]<<8)|buf[1];  
00001a  f89d0001          LDRB     r0,[sp,#1]
00001e  f89d1000          LDRB     r1,[sp,#0]
000022  ea402001          ORR      r0,r0,r1,LSL #8
000026  b200              SXTH     r0,r0
000028  8020              STRH     r0,[r4,#0]
;;;102    		*gy=((u16)buf[2]<<8)|buf[3];  
00002a  f89d0003          LDRB     r0,[sp,#3]
00002e  f89d1002          LDRB     r1,[sp,#2]
000032  ea402001          ORR      r0,r0,r1,LSL #8
000036  b200              SXTH     r0,r0
000038  8028              STRH     r0,[r5,#0]
;;;103    		*gz=((u16)buf[4]<<8)|buf[5];
00003a  f89d0005          LDRB     r0,[sp,#5]
00003e  f89d1004          LDRB     r1,[sp,#4]
000042  ea402001          ORR      r0,r0,r1,LSL #8
000046  b200              SXTH     r0,r0
000048  8030              STRH     r0,[r6,#0]
                  |L2.74|
;;;104    	} 	
;;;105        return res;;
00004a  4638              MOV      r0,r7
;;;106    }
00004c  e8bd81fc          POP      {r2-r8,pc}
;;;107    //得到加速度值(原始值)
                          ENDP


                          AREA ||i.MPU_Get_Temperature||, CODE, READONLY, ALIGN=2

                  MPU_Get_Temperature PROC
;;;80     //返回值:温度值(扩大了100倍)
;;;81     short MPU_Get_Temperature(void)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;82     {
;;;83         u8 buf[2]; 
;;;84         short raw;
;;;85     	float temp;
;;;86     	MPU_Read_Len(MPU_ADDR,MPU_TEMP_OUTH_REG,2,buf); 
000004  466b              MOV      r3,sp
000006  2202              MOVS     r2,#2
000008  2141              MOVS     r1,#0x41
00000a  2068              MOVS     r0,#0x68
00000c  f7fffffe          BL       MPU_Read_Len
;;;87         raw=((u16)buf[0]<<8)|buf[1];  
000010  f89d0001          LDRB     r0,[sp,#1]
000014  f89d1000          LDRB     r1,[sp,#0]
000018  ea402001          ORR      r0,r0,r1,LSL #8
00001c  fa0ffa80          SXTH     r10,r0
;;;88         temp=36.53+((double)raw)/340;  
000020  4650              MOV      r0,r10
000022  f7fffffe          BL       __aeabi_i2d
000026  4680              MOV      r8,r0
000028  2200              MOVS     r2,#0
00002a  4b0b              LDR      r3,|L3.88|
00002c  f7fffffe          BL       __aeabi_ddiv
000030  4606              MOV      r6,r0
000032  4a0a              LDR      r2,|L3.92|
000034  4b0a              LDR      r3,|L3.96|
000036  f7fffffe          BL       __aeabi_dadd
00003a  4604              MOV      r4,r0
00003c  f7fffffe          BL       __aeabi_d2f
000040  4683              MOV      r11,r0
;;;89         return temp*100;;
000042  4908              LDR      r1,|L3.100|
000044  4658              MOV      r0,r11
000046  f7fffffe          BL       __aeabi_fmul
00004a  4604              MOV      r4,r0
00004c  f7fffffe          BL       __aeabi_f2iz
000050  b200              SXTH     r0,r0
;;;90     }
000052  e8bd8ff8          POP      {r3-r11,pc}
;;;91     //得到陀螺仪值(原始值)
                          ENDP

000056  0000              DCW      0x0000
                  |L3.88|
                          DCD      0x40754000
                  |L3.92|
                          DCD      0x0a3d70a4
                  |L3.96|
                          DCD      0x404243d7
                  |L3.100|
                          DCD      0x42c80000

                          AREA ||i.MPU_Init||, CODE, READONLY, ALIGN=1

                  MPU_Init PROC
;;;10     //其他,错误代码
;;;11     u8 MPU_Init(void)
000000  b510              PUSH     {r4,lr}
;;;12     { 
;;;13     	u8 res; 
;;;14     	MPU_IIC_Init();//初始化IIC总线
000002  f7fffffe          BL       MPU_IIC_Init
;;;15     	MPU_Write_Byte(MPU_PWR_MGMT1_REG,0X80);	//复位MPU6050
000006  2180              MOVS     r1,#0x80
000008  206b              MOVS     r0,#0x6b
00000a  f7fffffe          BL       MPU_Write_Byte
;;;16         delay_ms(100);
00000e  2064              MOVS     r0,#0x64
000010  f7fffffe          BL       delay_ms
;;;17     	MPU_Write_Byte(MPU_PWR_MGMT1_REG,0X00);	//唤醒MPU6050 
000014  2100              MOVS     r1,#0
000016  206b              MOVS     r0,#0x6b
000018  f7fffffe          BL       MPU_Write_Byte
;;;18     	MPU_Set_Gyro_Fsr(3);					//陀螺仪传感器,±2000dps
00001c  2003              MOVS     r0,#3
00001e  f7fffffe          BL       MPU_Set_Gyro_Fsr
;;;19     	MPU_Set_Accel_Fsr(0);					//加速度传感器,±2g
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       MPU_Set_Accel_Fsr
;;;20     	MPU_Set_Rate(200);						//设置采样率50Hz
000028  20c8              MOVS     r0,#0xc8
00002a  f7fffffe          BL       MPU_Set_Rate
;;;21     	MPU_Write_Byte(MPU_INT_EN_REG,0X00);	//关闭所有中断
00002e  2100              MOVS     r1,#0
000030  2038              MOVS     r0,#0x38
000032  f7fffffe          BL       MPU_Write_Byte
;;;22     	MPU_Write_Byte(MPU_USER_CTRL_REG,0X00);	//I2C主模式关闭
000036  2100              MOVS     r1,#0
000038  206a              MOVS     r0,#0x6a
00003a  f7fffffe          BL       MPU_Write_Byte
;;;23     	MPU_Write_Byte(MPU_FIFO_EN_REG,0X00);	//关闭FIFO
00003e  2100              MOVS     r1,#0
000040  2023              MOVS     r0,#0x23
000042  f7fffffe          BL       MPU_Write_Byte
;;;24     	MPU_Write_Byte(MPU_INTBP_CFG_REG,0X80);	//INT引脚低电平有效
000046  2180              MOVS     r1,#0x80
000048  2037              MOVS     r0,#0x37
00004a  f7fffffe          BL       MPU_Write_Byte
;;;25     	res=MPU_Read_Byte(MPU_DEVICE_ID_REG); 
00004e  2075              MOVS     r0,#0x75
000050  f7fffffe          BL       MPU_Read_Byte
000054  4604              MOV      r4,r0
;;;26     	if(res==MPU_ADDR)//器件ID正确
000056  2c68              CMP      r4,#0x68
000058  d10b              BNE      |L4.114|
;;;27     	{
;;;28     		MPU_Write_Byte(MPU_PWR_MGMT1_REG,0X01);	//设置CLKSEL,PLL X轴为参考
00005a  2101              MOVS     r1,#1
00005c  206b              MOVS     r0,#0x6b
00005e  f7fffffe          BL       MPU_Write_Byte
;;;29     		MPU_Write_Byte(MPU_PWR_MGMT2_REG,0X00);	//加速度与陀螺仪都工作
000062  2100              MOVS     r1,#0
000064  206c              MOVS     r0,#0x6c
000066  f7fffffe          BL       MPU_Write_Byte
;;;30     		MPU_Set_Rate(200);						//设置采样率为50Hz
00006a  20c8              MOVS     r0,#0xc8
00006c  f7fffffe          BL       MPU_Set_Rate
000070  e001              B        |L4.118|
                  |L4.114|
;;;31      	}else return 1;
000072  2001              MOVS     r0,#1
                  |L4.116|
;;;32     	return 0;
;;;33     }
000074  bd10              POP      {r4,pc}
                  |L4.118|
000076  2000              MOVS     r0,#0                 ;32
000078  e7fc              B        |L4.116|
;;;34     //设置MPU6050陀螺仪传感器满量程范围
                          ENDP


                          AREA ||i.MPU_Read_Byte||, CODE, READONLY, ALIGN=1

                  MPU_Read_Byte PROC
;;;212    //返回值:读到的数据
;;;213    u8 MPU_Read_Byte(u8 reg)
000000  b570              PUSH     {r4-r6,lr}
;;;214    {
000002  4604              MOV      r4,r0
;;;215    	u8 res;
;;;216        MPU_IIC_Start(); 
000004  f7fffffe          BL       MPU_IIC_Start
;;;217    	MPU_IIC_Send_Byte((MPU_ADDR<<1)|0);//发送器件地址+写命令	
000008  20d0              MOVS     r0,#0xd0
00000a  f7fffffe          BL       MPU_IIC_Send_Byte
;;;218    	MPU_IIC_Wait_Ack();		//等待应答 
00000e  f7fffffe          BL       MPU_IIC_Wait_Ack
;;;219        MPU_IIC_Send_Byte(reg);	//写寄存器地址
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       MPU_IIC_Send_Byte
;;;220        MPU_IIC_Wait_Ack();		//等待应答
000018  f7fffffe          BL       MPU_IIC_Wait_Ack
;;;221        MPU_IIC_Start();
00001c  f7fffffe          BL       MPU_IIC_Start
;;;222    	MPU_IIC_Send_Byte((MPU_ADDR<<1)|1);//发送器件地址+读命令	
000020  20d1              MOVS     r0,#0xd1
000022  f7fffffe          BL       MPU_IIC_Send_Byte
;;;223        MPU_IIC_Wait_Ack();		//等待应答 
000026  f7fffffe          BL       MPU_IIC_Wait_Ack
;;;224    	res=MPU_IIC_Read_Byte(0);//读取数据,发送nACK 
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       MPU_IIC_Read_Byte
000030  4605              MOV      r5,r0
;;;225        MPU_IIC_Stop();			//产生一个停止条件 
000032  f7fffffe          BL       MPU_IIC_Stop
;;;226    	return res;		
000036  4628              MOV      r0,r5
;;;227    }
000038  bd70              POP      {r4-r6,pc}
;;;228    
                          ENDP


                          AREA ||i.MPU_Read_Len||, CODE, READONLY, ALIGN=1

                  MPU_Read_Len PROC
;;;160    //    其他,错误代码
;;;161    u8 MPU_Read_Len(u8 addr,u8 reg,u8 len,u8 *buf)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;162    { 
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;163     	MPU_IIC_Start(); 
00000c  f7fffffe          BL       MPU_IIC_Start
;;;164    	MPU_IIC_Send_Byte((addr<<1)|0);//发送器件地址+写命令	
000010  2100              MOVS     r1,#0
000012  ea410146          ORR      r1,r1,r6,LSL #1
000016  b2c8              UXTB     r0,r1
000018  f7fffffe          BL       MPU_IIC_Send_Byte
;;;165    	if(MPU_IIC_Wait_Ack())	//等待应答
00001c  f7fffffe          BL       MPU_IIC_Wait_Ack
000020  b120              CBZ      r0,|L6.44|
;;;166    	{
;;;167    		MPU_IIC_Stop();		 
000022  f7fffffe          BL       MPU_IIC_Stop
;;;168    		return 1;		
000026  2001              MOVS     r0,#1
                  |L6.40|
;;;169    	}
;;;170        MPU_IIC_Send_Byte(reg);	//写寄存器地址
;;;171        MPU_IIC_Wait_Ack();		//等待应答
;;;172        MPU_IIC_Start();
;;;173    	MPU_IIC_Send_Byte((addr<<1)|1);//发送器件地址+读命令	
;;;174        MPU_IIC_Wait_Ack();		//等待应答 
;;;175    	while(len)
;;;176    	{
;;;177    		if(len==1)*buf=MPU_IIC_Read_Byte(0);//读数据,发送nACK 
;;;178    		else *buf=MPU_IIC_Read_Byte(1);		//读数据,发送ACK  
;;;179    		len--;
;;;180    		buf++; 
;;;181    	}    
;;;182        MPU_IIC_Stop();	//产生一个停止条件 
;;;183    	return 0;	
;;;184    }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L6.44|
00002c  4638              MOV      r0,r7                 ;170
00002e  f7fffffe          BL       MPU_IIC_Send_Byte
000032  f7fffffe          BL       MPU_IIC_Wait_Ack
000036  f7fffffe          BL       MPU_IIC_Start
00003a  2101              MOVS     r1,#1                 ;173
00003c  eb010146          ADD      r1,r1,r6,LSL #1       ;173
000040  b2c8              UXTB     r0,r1                 ;173
000042  f7fffffe          BL       MPU_IIC_Send_Byte
000046  f7fffffe          BL       MPU_IIC_Wait_Ack
00004a  e00d              B        |L6.104|
                  |L6.76|
00004c  2c01              CMP      r4,#1                 ;177
00004e  d104              BNE      |L6.90|
000050  2000              MOVS     r0,#0                 ;177
000052  f7fffffe          BL       MPU_IIC_Read_Byte
000056  7028              STRB     r0,[r5,#0]            ;177
000058  e003              B        |L6.98|
                  |L6.90|
00005a  2001              MOVS     r0,#1                 ;178
00005c  f7fffffe          BL       MPU_IIC_Read_Byte
000060  7028              STRB     r0,[r5,#0]            ;178
                  |L6.98|
000062  1e60              SUBS     r0,r4,#1              ;179
000064  b2c4              UXTB     r4,r0                 ;179
000066  1c6d              ADDS     r5,r5,#1              ;180
                  |L6.104|
000068  2c00              CMP      r4,#0                 ;175
00006a  d1ef              BNE      |L6.76|
00006c  f7fffffe          BL       MPU_IIC_Stop
000070  2000              MOVS     r0,#0                 ;183
000072  e7d9              B        |L6.40|
;;;185    //IIC写一个字节 
                          ENDP


                          AREA ||i.MPU_Set_Accel_Fsr||, CODE, READONLY, ALIGN=1

                  MPU_Set_Accel_Fsr PROC
;;;45     //    其他,设置失败 
;;;46     u8 MPU_Set_Accel_Fsr(u8 fsr)
000000  b510              PUSH     {r4,lr}
;;;47     {
000002  4604              MOV      r4,r0
;;;48     	return MPU_Write_Byte(MPU_ACCEL_CFG_REG,fsr<<3);//设置加速度传感器满量程范围  
000004  06e0              LSLS     r0,r4,#27
000006  0e01              LSRS     r1,r0,#24
000008  201c              MOVS     r0,#0x1c
00000a  f7fffffe          BL       MPU_Write_Byte
;;;49     }
00000e  bd10              POP      {r4,pc}
;;;50     //设置MPU6050的数字低通滤波器
                          ENDP


                          AREA ||i.MPU_Set_Gyro_Fsr||, CODE, READONLY, ALIGN=1

                  MPU_Set_Gyro_Fsr PROC
;;;37     //    其他,设置失败 
;;;38     u8 MPU_Set_Gyro_Fsr(u8 fsr)
000000  b510              PUSH     {r4,lr}
;;;39     {
000002  4604              MOV      r4,r0
;;;40     	return MPU_Write_Byte(MPU_GYRO_CFG_REG,fsr<<3);//设置陀螺仪满量程范围  
000004  06e0              LSLS     r0,r4,#27
000006  0e01              LSRS     r1,r0,#24
000008  201b              MOVS     r0,#0x1b
00000a  f7fffffe          BL       MPU_Write_Byte
;;;41     }
00000e  bd10              POP      {r4,pc}
;;;42     //设置MPU6050加速度传感器满量程范围
                          ENDP


                          AREA ||i.MPU_Set_LPF||, CODE, READONLY, ALIGN=1

                  MPU_Set_LPF PROC
;;;53     //    其他,设置失败 
;;;54     u8 MPU_Set_LPF(u16 lpf)
000000  b570              PUSH     {r4-r6,lr}
;;;55     {
000002  4604              MOV      r4,r0
;;;56     	u8 data=0;
000004  2500              MOVS     r5,#0
;;;57     	if(lpf>=188)data=1;
000006  2cbc              CMP      r4,#0xbc
000008  db01              BLT      |L9.14|
00000a  2501              MOVS     r5,#1
00000c  e010              B        |L9.48|
                  |L9.14|
;;;58     	else if(lpf>=98)data=2;
00000e  2c62              CMP      r4,#0x62
000010  db01              BLT      |L9.22|
000012  2502              MOVS     r5,#2
000014  e00c              B        |L9.48|
                  |L9.22|
;;;59     	else if(lpf>=42)data=3;
000016  2c2a              CMP      r4,#0x2a
000018  db01              BLT      |L9.30|
00001a  2503              MOVS     r5,#3
00001c  e008              B        |L9.48|
                  |L9.30|
;;;60     	else if(lpf>=20)data=4;
00001e  2c14              CMP      r4,#0x14
000020  db01              BLT      |L9.38|
000022  2504              MOVS     r5,#4
000024  e004              B        |L9.48|
                  |L9.38|
;;;61     	else if(lpf>=10)data=5;
000026  2c0a              CMP      r4,#0xa
000028  db01              BLT      |L9.46|
00002a  2505              MOVS     r5,#5
00002c  e000              B        |L9.48|
                  |L9.46|
;;;62     	else data=6; 
00002e  2506              MOVS     r5,#6
                  |L9.48|
;;;63     	return MPU_Write_Byte(MPU_CFG_REG,data);//设置数字低通滤波器  
000030  4629              MOV      r1,r5
000032  201a              MOVS     r0,#0x1a
000034  f7fffffe          BL       MPU_Write_Byte
;;;64     }
000038  bd70              POP      {r4-r6,pc}
;;;65     //设置MPU6050的采样率(假定Fs=1KHz)
                          ENDP


                          AREA ||i.MPU_Set_Rate||, CODE, READONLY, ALIGN=1

                  MPU_Set_Rate PROC
;;;68     //    其他,设置失败 
;;;69     u8 MPU_Set_Rate(u16 rate)
000000  b570              PUSH     {r4-r6,lr}
;;;70     {
000002  4604              MOV      r4,r0
;;;71     	u8 data;
;;;72     	if(rate>1000)rate=1000;
000004  f5b47f7a          CMP      r4,#0x3e8
000008  dd01              BLE      |L10.14|
00000a  f44f747a          MOV      r4,#0x3e8
                  |L10.14|
;;;73     	if(rate<4)rate=4;
00000e  2c04              CMP      r4,#4
000010  da00              BGE      |L10.20|
000012  2404              MOVS     r4,#4
                  |L10.20|
;;;74     	data=1000/rate-1;
000014  f44f707a          MOV      r0,#0x3e8
000018  fb90f0f4          SDIV     r0,r0,r4
00001c  1e40              SUBS     r0,r0,#1
00001e  b2c5              UXTB     r5,r0
;;;75     	data=MPU_Write_Byte(MPU_SAMPLE_RATE_REG,data);	//设置数字低通滤波器
000020  4629              MOV      r1,r5
000022  2019              MOVS     r0,#0x19
000024  f7fffffe          BL       MPU_Write_Byte
000028  4605              MOV      r5,r0
;;;76      	return MPU_Set_LPF(rate/2);	//自动设置LPF为采样率的一半
00002a  4626              MOV      r6,r4
00002c  eb0471d6          ADD      r1,r4,r6,LSR #31
000030  f3c1004f          UBFX     r0,r1,#1,#16
000034  f7fffffe          BL       MPU_Set_LPF
;;;77     }
000038  bd70              POP      {r4-r6,pc}
;;;78     
                          ENDP


                          AREA ||i.MPU_Write_Byte||, CODE, READONLY, ALIGN=1

                  MPU_Write_Byte PROC
;;;189    //    其他,错误代码
;;;190    u8 MPU_Write_Byte(u8 reg,u8 data) 				 
000000  b570              PUSH     {r4-r6,lr}
;;;191    { 
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;192        MPU_IIC_Start(); 
000006  f7fffffe          BL       MPU_IIC_Start
;;;193    	MPU_IIC_Send_Byte((MPU_ADDR<<1)|0);//发送器件地址+写命令	
00000a  20d0              MOVS     r0,#0xd0
00000c  f7fffffe          BL       MPU_IIC_Send_Byte
;;;194    	if(MPU_IIC_Wait_Ack())	//等待应答
000010  f7fffffe          BL       MPU_IIC_Wait_Ack
000014  b118              CBZ      r0,|L11.30|
;;;195    	{
;;;196    		MPU_IIC_Stop();		 
000016  f7fffffe          BL       MPU_IIC_Stop
;;;197    		return 1;		
00001a  2001              MOVS     r0,#1
                  |L11.28|
;;;198    	}
;;;199        MPU_IIC_Send_Byte(reg);	//写寄存器地址
;;;200        MPU_IIC_Wait_Ack();		//等待应答 
;;;201    	MPU_IIC_Send_Byte(data);//发送数据
;;;202    	if(MPU_IIC_Wait_Ack())	//等待ACK
;;;203    	{
;;;204    		MPU_IIC_Stop();	 
;;;205    		return 1;		 
;;;206    	}		 
;;;207        MPU_IIC_Stop();	 
;;;208    	return 0;
;;;209    }
00001c  bd70              POP      {r4-r6,pc}
                  |L11.30|
00001e  4628              MOV      r0,r5                 ;199
000020  f7fffffe          BL       MPU_IIC_Send_Byte
000024  f7fffffe          BL       MPU_IIC_Wait_Ack
000028  4620              MOV      r0,r4                 ;201
00002a  f7fffffe          BL       MPU_IIC_Send_Byte
00002e  f7fffffe          BL       MPU_IIC_Wait_Ack
000032  b118              CBZ      r0,|L11.60|
000034  f7fffffe          BL       MPU_IIC_Stop
000038  2001              MOVS     r0,#1                 ;205
00003a  e7ef              B        |L11.28|
                  |L11.60|
00003c  f7fffffe          BL       MPU_IIC_Stop
000040  2000              MOVS     r0,#0                 ;208
000042  e7eb              B        |L11.28|
;;;210    //IIC读一个字节 
                          ENDP


                          AREA ||i.MPU_Write_Len||, CODE, READONLY, ALIGN=1

                  MPU_Write_Len PROC
;;;129    //    其他,错误代码
;;;130    u8 MPU_Write_Len(u8 addr,u8 reg,u8 len,u8 *buf)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;131    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;132    	u8 i; 
;;;133        MPU_IIC_Start(); 
00000c  f7fffffe          BL       MPU_IIC_Start
;;;134    	MPU_IIC_Send_Byte((addr<<1)|0);//发送器件地址+写命令	
000010  2100              MOVS     r1,#0
000012  ea410145          ORR      r1,r1,r5,LSL #1
000016  b2c8              UXTB     r0,r1
000018  f7fffffe          BL       MPU_IIC_Send_Byte
;;;135    	if(MPU_IIC_Wait_Ack())	//等待应答
00001c  f7fffffe          BL       MPU_IIC_Wait_Ack
000020  b120              CBZ      r0,|L12.44|
;;;136    	{
;;;137    		MPU_IIC_Stop();		 
000022  f7fffffe          BL       MPU_IIC_Stop
;;;138    		return 1;		
000026  2001              MOVS     r0,#1
                  |L12.40|
;;;139    	}
;;;140        MPU_IIC_Send_Byte(reg);	//写寄存器地址
;;;141        MPU_IIC_Wait_Ack();		//等待应答
;;;142    	for(i=0;i<len;i++)
;;;143    	{
;;;144    		MPU_IIC_Send_Byte(buf[i]);	//发送数据
;;;145    		if(MPU_IIC_Wait_Ack())		//等待ACK
;;;146    		{
;;;147    			MPU_IIC_Stop();	 
;;;148    			return 1;		 
;;;149    		}		
;;;150    	}    
;;;151        MPU_IIC_Stop();	 
;;;152    	return 0;	
;;;153    } 
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L12.44|
00002c  4630              MOV      r0,r6                 ;140
00002e  f7fffffe          BL       MPU_IIC_Send_Byte
000032  f7fffffe          BL       MPU_IIC_Wait_Ack
000036  2400              MOVS     r4,#0                 ;142
000038  e00c              B        |L12.84|
                  |L12.58|
00003a  f8180004          LDRB     r0,[r8,r4]            ;144
00003e  f7fffffe          BL       MPU_IIC_Send_Byte
000042  f7fffffe          BL       MPU_IIC_Wait_Ack
000046  b118              CBZ      r0,|L12.80|
000048  f7fffffe          BL       MPU_IIC_Stop
00004c  2001              MOVS     r0,#1                 ;148
00004e  e7eb              B        |L12.40|
                  |L12.80|
000050  1c60              ADDS     r0,r4,#1              ;142
000052  b2c4              UXTB     r4,r0                 ;142
                  |L12.84|
000054  42bc              CMP      r4,r7                 ;142
000056  dbf0              BLT      |L12.58|
000058  f7fffffe          BL       MPU_IIC_Stop
00005c  2000              MOVS     r0,#0                 ;152
00005e  e7e3              B        |L12.40|
;;;154    //IIC连续读
                          ENDP

