; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\inv_mpu.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\inv_mpu.d --feedback=.\Objects\Project.fed --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\Start -I.\User -I.\Library -I.\System -I.\System\delay -I.\System\sys -I.\System\usart -I.\Hardware\Encoder -I.\Hardware\Motor -I.\Hardware\MPU6050 -I.\Hardware\MPU6050\eMPL -I.\Hardware\OLED -I.\Hardware\PWM -I.\Public\Bit-Band -I.\Public\SystemClock -I.\Public\SysTick-Timer -I.\Hardware\Control -IC:\Users\GCP\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__UVISION_VERSION=535 -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\inv_mpu.crf Hardware\MPU6050\eMPL\inv_mpu.c]
                          THUMB

                          AREA ||i.accel_self_test||, CODE, READONLY, ALIGN=2

                  accel_self_test PROC
;;;1929   
;;;1930   static int accel_self_test(long *bias_regular, long *bias_st)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;1931   {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;1932       int jj, result = 0;
000008  2500              MOVS     r5,#0
;;;1933       float st_shift[3], st_shift_cust, st_shift_var;
;;;1934   
;;;1935       get_accel_prod_shift(st_shift);
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       get_accel_prod_shift
;;;1936       for(jj = 0; jj < 3; jj++) {
000010  2400              MOVS     r4,#0
000012  e042              B        |L1.154|
                  |L1.20|
;;;1937           st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
000014  f8560024          LDR      r0,[r6,r4,LSL #2]
000018  f8571024          LDR      r1,[r7,r4,LSL #2]
00001c  eba00a01          SUB      r10,r0,r1
000020  f1ba0f00          CMP      r10,#0
000024  db01              BLT      |L1.42|
000026  4651              MOV      r1,r10
000028  e001              B        |L1.46|
                  |L1.42|
00002a  f1ca0100          RSB      r1,r10,#0
                  |L1.46|
00002e  4608              MOV      r0,r1
000030  f7fffffe          BL       __aeabi_i2f
000034  4683              MOV      r11,r0
000036  f04f418f          MOV      r1,#0x47800000
00003a  f7fffffe          BL       __aeabi_fdiv
00003e  4680              MOV      r8,r0
;;;1938           if (st_shift[jj]) {
000040  f85d0024          LDR      r0,[sp,r4,LSL #2]
000044  2100              MOVS     r1,#0
000046  f7fffffe          BL       __aeabi_cfcmpeq
00004a  d016              BEQ      |L1.122|
;;;1939               st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
00004c  f85d1024          LDR      r1,[sp,r4,LSL #2]
000050  4640              MOV      r0,r8
000052  f7fffffe          BL       __aeabi_fdiv
000056  4682              MOV      r10,r0
000058  f04f517e          MOV      r1,#0x3f800000
00005c  f7fffffe          BL       __aeabi_fsub
000060  4681              MOV      r9,r0
;;;1940               if (fabs(st_shift_var) > test.max_accel_var)
000062  f0294a00          BIC      r10,r9,#0x80000000
000066  480f              LDR      r0,|L1.164|
000068  6a41              LDR      r1,[r0,#0x24]  ; test
00006a  4650              MOV      r0,r10
00006c  f7fffffe          BL       __aeabi_cfrcmple
000070  d212              BCS      |L1.152|
;;;1941                   result |= 1 << jj;
000072  2001              MOVS     r0,#1
000074  40a0              LSLS     r0,r0,r4
000076  4305              ORRS     r5,r5,r0
000078  e00e              B        |L1.152|
                  |L1.122|
;;;1942           } else if ((st_shift_cust < test.min_g) ||
00007a  480a              LDR      r0,|L1.164|
00007c  69c1              LDR      r1,[r0,#0x1c]  ; test
00007e  4640              MOV      r0,r8
000080  f7fffffe          BL       __aeabi_cfcmple
000084  d305              BCC      |L1.146|
;;;1943               (st_shift_cust > test.max_g))
000086  4807              LDR      r0,|L1.164|
000088  6a01              LDR      r1,[r0,#0x20]  ; test
00008a  4640              MOV      r0,r8
00008c  f7fffffe          BL       __aeabi_cfrcmple
000090  d202              BCS      |L1.152|
                  |L1.146|
;;;1944               result |= 1 << jj;
000092  2001              MOVS     r0,#1
000094  40a0              LSLS     r0,r0,r4
000096  4305              ORRS     r5,r5,r0
                  |L1.152|
000098  1c64              ADDS     r4,r4,#1              ;1936
                  |L1.154|
00009a  2c03              CMP      r4,#3                 ;1936
00009c  dbba              BLT      |L1.20|
;;;1945       }
;;;1946   
;;;1947       return result;
00009e  4628              MOV      r0,r5
;;;1948   }
0000a0  e8bd8ffe          POP      {r1-r11,pc}
;;;1949   
                          ENDP

                  |L1.164|
                          DCD      test

                          AREA ||i.get_accel_prod_shift||, CODE, READONLY, ALIGN=2

                  get_accel_prod_shift PROC
;;;1904   #ifdef MPU6050
;;;1905   static int get_accel_prod_shift(float *st_shift)
000000  b57c              PUSH     {r2-r6,lr}
;;;1906   {
000002  4605              MOV      r5,r0
;;;1907       unsigned char tmp[4], shift_code[3], ii;
;;;1908   
;;;1909       if (i2c_read(st.hw->addr, 0x0D, 4, tmp))
000004  4928              LDR      r1,|L2.168|
000006  6849              LDR      r1,[r1,#4]  ; st
000008  7808              LDRB     r0,[r1,#0]
00000a  ab01              ADD      r3,sp,#4
00000c  2204              MOVS     r2,#4
00000e  210d              MOVS     r1,#0xd
000010  f7fffffe          BL       MPU_Read_Len
000014  b108              CBZ      r0,|L2.26|
;;;1910           return 0x07;
000016  2007              MOVS     r0,#7
                  |L2.24|
;;;1911   
;;;1912       shift_code[0] = ((tmp[0] & 0xE0) >> 3) | ((tmp[3] & 0x30) >> 4);
;;;1913       shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
;;;1914       shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
;;;1915       for (ii = 0; ii < 3; ii++) {
;;;1916           if (!shift_code[ii]) {
;;;1917               st_shift[ii] = 0.f;
;;;1918               continue;
;;;1919           }
;;;1920           /* Equivalent to..
;;;1921            * st_shift[ii] = 0.34f * powf(0.92f/0.34f, (shift_code[ii]-1) / 30.f)
;;;1922            */
;;;1923           st_shift[ii] = 0.34f;
;;;1924           while (--shift_code[ii])
;;;1925               st_shift[ii] *= 1.034f;
;;;1926       }
;;;1927       return 0;
;;;1928   }
000018  bd7c              POP      {r2-r6,pc}
                  |L2.26|
00001a  f89d0007          LDRB     r0,[sp,#7]            ;1912
00001e  f3c01001          UBFX     r0,r0,#4,#2           ;1912
000022  f89d1004          LDRB     r1,[sp,#4]            ;1912
000026  f00101e0          AND      r1,r1,#0xe0           ;1912
00002a  ea4000e1          ORR      r0,r0,r1,ASR #3       ;1912
00002e  f88d0000          STRB     r0,[sp,#0]            ;1912
000032  f89d0007          LDRB     r0,[sp,#7]            ;1913
000036  f3c00081          UBFX     r0,r0,#2,#2           ;1913
00003a  f89d1005          LDRB     r1,[sp,#5]            ;1913
00003e  f00101e0          AND      r1,r1,#0xe0           ;1913
000042  ea4000e1          ORR      r0,r0,r1,ASR #3       ;1913
000046  f88d0001          STRB     r0,[sp,#1]            ;1913
00004a  f89d0007          LDRB     r0,[sp,#7]            ;1914
00004e  f0000003          AND      r0,r0,#3              ;1914
000052  f89d1006          LDRB     r1,[sp,#6]            ;1914
000056  f00101e0          AND      r1,r1,#0xe0           ;1914
00005a  ea4000e1          ORR      r0,r0,r1,ASR #3       ;1914
00005e  f88d0002          STRB     r0,[sp,#2]            ;1914
000062  2400              MOVS     r4,#0                 ;1915
000064  e01c              B        |L2.160|
                  |L2.102|
000066  f81d0004          LDRB     r0,[sp,r4]            ;1916
00006a  b918              CBNZ     r0,|L2.116|
00006c  2000              MOVS     r0,#0                 ;1917
00006e  f8450024          STR      r0,[r5,r4,LSL #2]     ;1917
000072  e013              B        |L2.156|
                  |L2.116|
000074  480d              LDR      r0,|L2.172|
000076  f8450024          STR      r0,[r5,r4,LSL #2]     ;1923
00007a  e006              B        |L2.138|
                  |L2.124|
00007c  f8550024          LDR      r0,[r5,r4,LSL #2]     ;1925
000080  490b              LDR      r1,|L2.176|
000082  f7fffffe          BL       __aeabi_fmul
000086  f8450024          STR      r0,[r5,r4,LSL #2]     ;1925
                  |L2.138|
00008a  f81d0004          LDRB     r0,[sp,r4]            ;1924
00008e  1e40              SUBS     r0,r0,#1              ;1924
000090  b2c0              UXTB     r0,r0                 ;1924
000092  f80d0004          STRB     r0,[sp,r4]            ;1924
000096  2800              CMP      r0,#0                 ;1924
000098  d1f0              BNE      |L2.124|
00009a  bf00              NOP                            ;1918
                  |L2.156|
00009c  1c60              ADDS     r0,r4,#1              ;1915
00009e  b2c4              UXTB     r4,r0                 ;1915
                  |L2.160|
0000a0  2c03              CMP      r4,#3                 ;1915
0000a2  dbe0              BLT      |L2.102|
0000a4  2000              MOVS     r0,#0                 ;1927
0000a6  e7b7              B        |L2.24|
;;;1929   
                          ENDP

                  |L2.168|
                          DCD      ||st||
                  |L2.172|
                          DCD      0x3eae147b
                  |L2.176|
                          DCD      0x3f845a1d

                          AREA ||i.get_st_biases||, CODE, READONLY, ALIGN=2

                  get_st_biases PROC
;;;2033   
;;;2034   static int get_st_biases(long *gyro, long *accel, unsigned char hw_test)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;2035   {
000004  b087              SUB      sp,sp,#0x1c
000006  4605              MOV      r5,r0
000008  460c              MOV      r4,r1
00000a  4691              MOV      r9,r2
;;;2036       unsigned char data[MAX_PACKET_LENGTH];
;;;2037       unsigned char packet_count, ii;
;;;2038       unsigned short fifo_count;
;;;2039   
;;;2040       data[0] = 0x01;
00000c  2001              MOVS     r0,#1
00000e  f88d0010          STRB     r0,[sp,#0x10]
;;;2041       data[1] = 0;
000012  2000              MOVS     r0,#0
000014  f88d0011          STRB     r0,[sp,#0x11]
;;;2042       if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
000018  4afe              LDR      r2,|L3.1044|
00001a  6812              LDR      r2,[r2,#0]  ; st
00001c  7c91              LDRB     r1,[r2,#0x12]
00001e  4afd              LDR      r2,|L3.1044|
000020  6852              LDR      r2,[r2,#4]  ; st
000022  7810              LDRB     r0,[r2,#0]
000024  ab04              ADD      r3,sp,#0x10
000026  2202              MOVS     r2,#2
000028  f7fffffe          BL       MPU_Write_Len
00002c  b120              CBZ      r0,|L3.56|
;;;2043           return -1;
00002e  f04f30ff          MOV      r0,#0xffffffff
                  |L3.50|
;;;2044       delay_ms(200);
;;;2045       data[0] = 0;
;;;2046       if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
;;;2047           return -1;
;;;2048       if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
;;;2049           return -1;
;;;2050       if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
;;;2051           return -1;
;;;2052       if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
;;;2053           return -1;
;;;2054       if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
;;;2055           return -1;
;;;2056       data[0] = BIT_FIFO_RST | BIT_DMP_RST;
;;;2057       if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
;;;2058           return -1;
;;;2059       delay_ms(15);
;;;2060       data[0] = st.test->reg_lpf;
;;;2061       if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
;;;2062           return -1;
;;;2063       data[0] = st.test->reg_rate_div;
;;;2064       if (i2c_write(st.hw->addr, st.reg->rate_div, 1, data))
;;;2065           return -1;
;;;2066       if (hw_test)
;;;2067           data[0] = st.test->reg_gyro_fsr | 0xE0;
;;;2068       else
;;;2069           data[0] = st.test->reg_gyro_fsr;
;;;2070       if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, data))
;;;2071           return -1;
;;;2072   
;;;2073       if (hw_test)
;;;2074           data[0] = st.test->reg_accel_fsr | 0xE0;
;;;2075       else
;;;2076           data[0] = test.reg_accel_fsr;
;;;2077       if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
;;;2078           return -1;
;;;2079       if (hw_test)
;;;2080           delay_ms(200);
;;;2081   
;;;2082       /* Fill FIFO for test.wait_ms milliseconds. */
;;;2083       data[0] = BIT_FIFO_EN;
;;;2084       if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
;;;2085           return -1;
;;;2086   
;;;2087       data[0] = INV_XYZ_GYRO | INV_XYZ_ACCEL;
;;;2088       if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
;;;2089           return -1;
;;;2090       delay_ms(test.wait_ms);
;;;2091       data[0] = 0;
;;;2092       if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
;;;2093           return -1;
;;;2094   
;;;2095       if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
;;;2096           return -1;
;;;2097   
;;;2098       fifo_count = (data[0] << 8) | data[1];
;;;2099       packet_count = fifo_count / MAX_PACKET_LENGTH;
;;;2100       gyro[0] = gyro[1] = gyro[2] = 0;
;;;2101       accel[0] = accel[1] = accel[2] = 0;
;;;2102   
;;;2103       for (ii = 0; ii < packet_count; ii++) {
;;;2104           short accel_cur[3], gyro_cur[3];
;;;2105           if (i2c_read(st.hw->addr, st.reg->fifo_r_w, MAX_PACKET_LENGTH, data))
;;;2106               return -1;
;;;2107           accel_cur[0] = ((short)data[0] << 8) | data[1];
;;;2108           accel_cur[1] = ((short)data[2] << 8) | data[3];
;;;2109           accel_cur[2] = ((short)data[4] << 8) | data[5];
;;;2110           accel[0] += (long)accel_cur[0];
;;;2111           accel[1] += (long)accel_cur[1];
;;;2112           accel[2] += (long)accel_cur[2];
;;;2113           gyro_cur[0] = (((short)data[6] << 8) | data[7]);
;;;2114           gyro_cur[1] = (((short)data[8] << 8) | data[9]);
;;;2115           gyro_cur[2] = (((short)data[10] << 8) | data[11]);
;;;2116           gyro[0] += (long)gyro_cur[0];
;;;2117           gyro[1] += (long)gyro_cur[1];
;;;2118           gyro[2] += (long)gyro_cur[2];
;;;2119       }
;;;2120   #ifdef EMPL_NO_64BIT
;;;2121       gyro[0] = (long)(((float)gyro[0]*65536.f) / test.gyro_sens / packet_count);
;;;2122       gyro[1] = (long)(((float)gyro[1]*65536.f) / test.gyro_sens / packet_count);
;;;2123       gyro[2] = (long)(((float)gyro[2]*65536.f) / test.gyro_sens / packet_count);
;;;2124       if (has_accel) {
;;;2125           accel[0] = (long)(((float)accel[0]*65536.f) / test.accel_sens /
;;;2126               packet_count);
;;;2127           accel[1] = (long)(((float)accel[1]*65536.f) / test.accel_sens /
;;;2128               packet_count);
;;;2129           accel[2] = (long)(((float)accel[2]*65536.f) / test.accel_sens /
;;;2130               packet_count);
;;;2131           /* Don't remove gravity! */
;;;2132           accel[2] -= 65536L;
;;;2133       }
;;;2134   #else
;;;2135       gyro[0] = (long)(((long long)gyro[0]<<16) / test.gyro_sens / packet_count);
;;;2136       gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
;;;2137       gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
;;;2138       accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
;;;2139           packet_count);
;;;2140       accel[1] = (long)(((long long)accel[1]<<16) / test.accel_sens /
;;;2141           packet_count);
;;;2142       accel[2] = (long)(((long long)accel[2]<<16) / test.accel_sens /
;;;2143           packet_count);
;;;2144       /* Don't remove gravity! */
;;;2145       if (accel[2] > 0L)
;;;2146           accel[2] -= 65536L;
;;;2147       else
;;;2148           accel[2] += 65536L;
;;;2149   #endif
;;;2150   
;;;2151       return 0;
;;;2152   }
000032  b007              ADD      sp,sp,#0x1c
000034  e8bd8ff0          POP      {r4-r11,pc}
                  |L3.56|
000038  20c8              MOVS     r0,#0xc8              ;2044
00003a  f7fffffe          BL       delay_ms
00003e  2000              MOVS     r0,#0                 ;2045
000040  f88d0010          STRB     r0,[sp,#0x10]         ;2045
000044  4af3              LDR      r2,|L3.1044|
000046  6812              LDR      r2,[r2,#0]            ;2046  ; st
000048  7bd1              LDRB     r1,[r2,#0xf]          ;2046
00004a  4af2              LDR      r2,|L3.1044|
00004c  6852              LDR      r2,[r2,#4]            ;2046  ; st
00004e  7810              LDRB     r0,[r2,#0]            ;2046
000050  ab04              ADD      r3,sp,#0x10           ;2046
000052  2201              MOVS     r2,#1                 ;2046
000054  f7fffffe          BL       MPU_Write_Len
000058  b110              CBZ      r0,|L3.96|
00005a  f04f30ff          MOV      r0,#0xffffffff        ;2047
00005e  e7e8              B        |L3.50|
                  |L3.96|
000060  4aec              LDR      r2,|L3.1044|
000062  6812              LDR      r2,[r2,#0]            ;2048  ; st
000064  7951              LDRB     r1,[r2,#5]            ;2048
000066  4aeb              LDR      r2,|L3.1044|
000068  6852              LDR      r2,[r2,#4]            ;2048  ; st
00006a  7810              LDRB     r0,[r2,#0]            ;2048
00006c  ab04              ADD      r3,sp,#0x10           ;2048
00006e  2201              MOVS     r2,#1                 ;2048
000070  f7fffffe          BL       MPU_Write_Len
000074  b110              CBZ      r0,|L3.124|
000076  f04f30ff          MOV      r0,#0xffffffff        ;2049
00007a  e7da              B        |L3.50|
                  |L3.124|
00007c  4ae5              LDR      r2,|L3.1044|
00007e  6812              LDR      r2,[r2,#0]            ;2050  ; st
000080  7c91              LDRB     r1,[r2,#0x12]         ;2050
000082  4ae4              LDR      r2,|L3.1044|
000084  6852              LDR      r2,[r2,#4]            ;2050  ; st
000086  7810              LDRB     r0,[r2,#0]            ;2050
000088  ab04              ADD      r3,sp,#0x10           ;2050
00008a  2201              MOVS     r2,#1                 ;2050
00008c  f7fffffe          BL       MPU_Write_Len
000090  b110              CBZ      r0,|L3.152|
000092  f04f30ff          MOV      r0,#0xffffffff        ;2051
000096  e7cc              B        |L3.50|
                  |L3.152|
000098  4ade              LDR      r2,|L3.1044|
00009a  6812              LDR      r2,[r2,#0]            ;2052  ; st
00009c  7dd1              LDRB     r1,[r2,#0x17]         ;2052
00009e  4add              LDR      r2,|L3.1044|
0000a0  6852              LDR      r2,[r2,#4]            ;2052  ; st
0000a2  7810              LDRB     r0,[r2,#0]            ;2052
0000a4  ab04              ADD      r3,sp,#0x10           ;2052
0000a6  2201              MOVS     r2,#1                 ;2052
0000a8  f7fffffe          BL       MPU_Write_Len
0000ac  b110              CBZ      r0,|L3.180|
0000ae  f04f30ff          MOV      r0,#0xffffffff        ;2053
0000b2  e7be              B        |L3.50|
                  |L3.180|
0000b4  4ad7              LDR      r2,|L3.1044|
0000b6  6812              LDR      r2,[r2,#0]            ;2054  ; st
0000b8  7911              LDRB     r1,[r2,#4]            ;2054
0000ba  4ad6              LDR      r2,|L3.1044|
0000bc  6852              LDR      r2,[r2,#4]            ;2054  ; st
0000be  7810              LDRB     r0,[r2,#0]            ;2054
0000c0  ab04              ADD      r3,sp,#0x10           ;2054
0000c2  2201              MOVS     r2,#1                 ;2054
0000c4  f7fffffe          BL       MPU_Write_Len
0000c8  b110              CBZ      r0,|L3.208|
0000ca  f04f30ff          MOV      r0,#0xffffffff        ;2055
0000ce  e7b0              B        |L3.50|
                  |L3.208|
0000d0  200c              MOVS     r0,#0xc               ;2056
0000d2  f88d0010          STRB     r0,[sp,#0x10]         ;2056
0000d6  4acf              LDR      r2,|L3.1044|
0000d8  6812              LDR      r2,[r2,#0]            ;2057  ; st
0000da  7911              LDRB     r1,[r2,#4]            ;2057
0000dc  4acd              LDR      r2,|L3.1044|
0000de  6852              LDR      r2,[r2,#4]            ;2057  ; st
0000e0  7810              LDRB     r0,[r2,#0]            ;2057
0000e2  ab04              ADD      r3,sp,#0x10           ;2057
0000e4  2201              MOVS     r2,#1                 ;2057
0000e6  f7fffffe          BL       MPU_Write_Len
0000ea  b110              CBZ      r0,|L3.242|
0000ec  f04f30ff          MOV      r0,#0xffffffff        ;2058
0000f0  e79f              B        |L3.50|
                  |L3.242|
0000f2  200f              MOVS     r0,#0xf               ;2059
0000f4  f7fffffe          BL       delay_ms
0000f8  48c6              LDR      r0,|L3.1044|
0000fa  6a80              LDR      r0,[r0,#0x28]         ;2060  ; st
0000fc  7a40              LDRB     r0,[r0,#9]            ;2060
0000fe  f88d0010          STRB     r0,[sp,#0x10]         ;2060
000102  4ac4              LDR      r2,|L3.1044|
000104  6812              LDR      r2,[r2,#0]            ;2061  ; st
000106  7891              LDRB     r1,[r2,#2]            ;2061
000108  4ac2              LDR      r2,|L3.1044|
00010a  6852              LDR      r2,[r2,#4]            ;2061  ; st
00010c  7810              LDRB     r0,[r2,#0]            ;2061
00010e  ab04              ADD      r3,sp,#0x10           ;2061
000110  2201              MOVS     r2,#1                 ;2061
000112  f7fffffe          BL       MPU_Write_Len
000116  b110              CBZ      r0,|L3.286|
000118  f04f30ff          MOV      r0,#0xffffffff        ;2062
00011c  e789              B        |L3.50|
                  |L3.286|
00011e  48bd              LDR      r0,|L3.1044|
000120  6a80              LDR      r0,[r0,#0x28]         ;2063  ; st
000122  7a00              LDRB     r0,[r0,#8]            ;2063
000124  f88d0010          STRB     r0,[sp,#0x10]         ;2063
000128  4aba              LDR      r2,|L3.1044|
00012a  6812              LDR      r2,[r2,#0]            ;2064  ; st
00012c  7851              LDRB     r1,[r2,#1]            ;2064
00012e  4ab9              LDR      r2,|L3.1044|
000130  6852              LDR      r2,[r2,#4]            ;2064  ; st
000132  7810              LDRB     r0,[r2,#0]            ;2064
000134  ab04              ADD      r3,sp,#0x10           ;2064
000136  2201              MOVS     r2,#1                 ;2064
000138  f7fffffe          BL       MPU_Write_Len
00013c  b110              CBZ      r0,|L3.324|
00013e  f04f30ff          MOV      r0,#0xffffffff        ;2065
000142  e776              B        |L3.50|
                  |L3.324|
000144  f1b90f00          CMP      r9,#0                 ;2066
000148  d007              BEQ      |L3.346|
00014a  48b2              LDR      r0,|L3.1044|
00014c  6a80              LDR      r0,[r0,#0x28]         ;2067  ; st
00014e  7a80              LDRB     r0,[r0,#0xa]          ;2067
000150  f04000e0          ORR      r0,r0,#0xe0           ;2067
000154  f88d0010          STRB     r0,[sp,#0x10]         ;2067
000158  e004              B        |L3.356|
                  |L3.346|
00015a  48ae              LDR      r0,|L3.1044|
00015c  6a80              LDR      r0,[r0,#0x28]         ;2069  ; st
00015e  7a80              LDRB     r0,[r0,#0xa]          ;2069
000160  f88d0010          STRB     r0,[sp,#0x10]         ;2069
                  |L3.356|
000164  4aab              LDR      r2,|L3.1044|
000166  6812              LDR      r2,[r2,#0]            ;2070  ; st
000168  7991              LDRB     r1,[r2,#6]            ;2070
00016a  4aaa              LDR      r2,|L3.1044|
00016c  6852              LDR      r2,[r2,#4]            ;2070  ; st
00016e  7810              LDRB     r0,[r2,#0]            ;2070
000170  ab04              ADD      r3,sp,#0x10           ;2070
000172  2201              MOVS     r2,#1                 ;2070
000174  f7fffffe          BL       MPU_Write_Len
000178  b110              CBZ      r0,|L3.384|
00017a  f04f30ff          MOV      r0,#0xffffffff        ;2071
00017e  e758              B        |L3.50|
                  |L3.384|
000180  f1b90f00          CMP      r9,#0                 ;2073
000184  d007              BEQ      |L3.406|
000186  48a3              LDR      r0,|L3.1044|
000188  6a80              LDR      r0,[r0,#0x28]         ;2074  ; st
00018a  7ac0              LDRB     r0,[r0,#0xb]          ;2074
00018c  f04000e0          ORR      r0,r0,#0xe0           ;2074
000190  f88d0010          STRB     r0,[sp,#0x10]         ;2074
000194  e003              B        |L3.414|
                  |L3.406|
000196  48a0              LDR      r0,|L3.1048|
000198  7ac0              LDRB     r0,[r0,#0xb]          ;2076  ; test
00019a  f88d0010          STRB     r0,[sp,#0x10]         ;2076
                  |L3.414|
00019e  4a9d              LDR      r2,|L3.1044|
0001a0  6812              LDR      r2,[r2,#0]            ;2077  ; st
0001a2  79d1              LDRB     r1,[r2,#7]            ;2077
0001a4  4a9b              LDR      r2,|L3.1044|
0001a6  6852              LDR      r2,[r2,#4]            ;2077  ; st
0001a8  7810              LDRB     r0,[r2,#0]            ;2077
0001aa  ab04              ADD      r3,sp,#0x10           ;2077
0001ac  2201              MOVS     r2,#1                 ;2077
0001ae  f7fffffe          BL       MPU_Write_Len
0001b2  b110              CBZ      r0,|L3.442|
0001b4  f04f30ff          MOV      r0,#0xffffffff        ;2078
0001b8  e73b              B        |L3.50|
                  |L3.442|
0001ba  f1b90f00          CMP      r9,#0                 ;2079
0001be  d002              BEQ      |L3.454|
0001c0  20c8              MOVS     r0,#0xc8              ;2080
0001c2  f7fffffe          BL       delay_ms
                  |L3.454|
0001c6  2040              MOVS     r0,#0x40              ;2083
0001c8  f88d0010          STRB     r0,[sp,#0x10]         ;2083
0001cc  4a91              LDR      r2,|L3.1044|
0001ce  6812              LDR      r2,[r2,#0]            ;2084  ; st
0001d0  7911              LDRB     r1,[r2,#4]            ;2084
0001d2  4a90              LDR      r2,|L3.1044|
0001d4  6852              LDR      r2,[r2,#4]            ;2084  ; st
0001d6  7810              LDRB     r0,[r2,#0]            ;2084
0001d8  ab04              ADD      r3,sp,#0x10           ;2084
0001da  2201              MOVS     r2,#1                 ;2084
0001dc  f7fffffe          BL       MPU_Write_Len
0001e0  b110              CBZ      r0,|L3.488|
0001e2  f04f30ff          MOV      r0,#0xffffffff        ;2085
0001e6  e724              B        |L3.50|
                  |L3.488|
0001e8  2078              MOVS     r0,#0x78              ;2087
0001ea  f88d0010          STRB     r0,[sp,#0x10]         ;2087
0001ee  4a89              LDR      r2,|L3.1044|
0001f0  6812              LDR      r2,[r2,#0]            ;2088  ; st
0001f2  7951              LDRB     r1,[r2,#5]            ;2088
0001f4  4a87              LDR      r2,|L3.1044|
0001f6  6852              LDR      r2,[r2,#4]            ;2088  ; st
0001f8  7810              LDRB     r0,[r2,#0]            ;2088
0001fa  ab04              ADD      r3,sp,#0x10           ;2088
0001fc  2201              MOVS     r2,#1                 ;2088
0001fe  f7fffffe          BL       MPU_Write_Len
000202  b110              CBZ      r0,|L3.522|
000204  f04f30ff          MOV      r0,#0xffffffff        ;2089
000208  e713              B        |L3.50|
                  |L3.522|
00020a  4983              LDR      r1,|L3.1048|
00020c  8988              LDRH     r0,[r1,#0xc]          ;2090  ; test
00020e  f7fffffe          BL       delay_ms
000212  2000              MOVS     r0,#0                 ;2091
000214  f88d0010          STRB     r0,[sp,#0x10]         ;2091
000218  4a7e              LDR      r2,|L3.1044|
00021a  6812              LDR      r2,[r2,#0]            ;2092  ; st
00021c  7951              LDRB     r1,[r2,#5]            ;2092
00021e  4a7d              LDR      r2,|L3.1044|
000220  6852              LDR      r2,[r2,#4]            ;2092  ; st
000222  7810              LDRB     r0,[r2,#0]            ;2092
000224  ab04              ADD      r3,sp,#0x10           ;2092
000226  2201              MOVS     r2,#1                 ;2092
000228  f7fffffe          BL       MPU_Write_Len
00022c  b110              CBZ      r0,|L3.564|
00022e  f04f30ff          MOV      r0,#0xffffffff        ;2093
000232  e6fe              B        |L3.50|
                  |L3.564|
000234  4a77              LDR      r2,|L3.1044|
000236  6812              LDR      r2,[r2,#0]            ;2095  ; st
000238  7a91              LDRB     r1,[r2,#0xa]          ;2095
00023a  4a76              LDR      r2,|L3.1044|
00023c  6852              LDR      r2,[r2,#4]            ;2095  ; st
00023e  7810              LDRB     r0,[r2,#0]            ;2095
000240  ab04              ADD      r3,sp,#0x10           ;2095
000242  2202              MOVS     r2,#2                 ;2095
000244  f7fffffe          BL       MPU_Read_Len
000248  b110              CBZ      r0,|L3.592|
00024a  f04f30ff          MOV      r0,#0xffffffff        ;2096
00024e  e6f0              B        |L3.50|
                  |L3.592|
000250  f89d0011          LDRB     r0,[sp,#0x11]         ;2098
000254  f89d1010          LDRB     r1,[sp,#0x10]         ;2098
000258  ea402b01          ORR      r11,r0,r1,LSL #8      ;2098
00025c  200c              MOVS     r0,#0xc               ;2099
00025e  fb9bf0f0          SDIV     r0,r11,r0             ;2099
000262  b2c6              UXTB     r6,r0                 ;2099
000264  2000              MOVS     r0,#0                 ;2100
000266  60a8              STR      r0,[r5,#8]            ;2100
000268  6068              STR      r0,[r5,#4]            ;2100
00026a  6028              STR      r0,[r5,#0]            ;2100
00026c  60a0              STR      r0,[r4,#8]            ;2101
00026e  6060              STR      r0,[r4,#4]            ;2101
000270  6020              STR      r0,[r4,#0]            ;2101
000272  4682              MOV      r10,r0                ;2103
000274  e065              B        |L3.834|
                  |L3.630|
000276  4a67              LDR      r2,|L3.1044|
000278  6812              LDR      r2,[r2,#0]            ;2105  ; st
00027a  7ad1              LDRB     r1,[r2,#0xb]          ;2105
00027c  4a65              LDR      r2,|L3.1044|
00027e  6852              LDR      r2,[r2,#4]            ;2105  ; st
000280  7810              LDRB     r0,[r2,#0]            ;2105
000282  ab04              ADD      r3,sp,#0x10           ;2105
000284  220c              MOVS     r2,#0xc               ;2105
000286  f7fffffe          BL       MPU_Read_Len
00028a  b110              CBZ      r0,|L3.658|
00028c  f04f30ff          MOV      r0,#0xffffffff        ;2106
000290  e6cf              B        |L3.50|
                  |L3.658|
000292  f89d0011          LDRB     r0,[sp,#0x11]         ;2107
000296  f89d1010          LDRB     r1,[sp,#0x10]         ;2107
00029a  ea402001          ORR      r0,r0,r1,LSL #8       ;2107
00029e  b200              SXTH     r0,r0                 ;2107
0002a0  f8ad0008          STRH     r0,[sp,#8]            ;2107
0002a4  f89d0013          LDRB     r0,[sp,#0x13]         ;2108
0002a8  f89d1012          LDRB     r1,[sp,#0x12]         ;2108
0002ac  ea402001          ORR      r0,r0,r1,LSL #8       ;2108
0002b0  b200              SXTH     r0,r0                 ;2108
0002b2  f8ad000a          STRH     r0,[sp,#0xa]          ;2108
0002b6  f89d0015          LDRB     r0,[sp,#0x15]         ;2109
0002ba  f89d1014          LDRB     r1,[sp,#0x14]         ;2109
0002be  ea402001          ORR      r0,r0,r1,LSL #8       ;2109
0002c2  b200              SXTH     r0,r0                 ;2109
0002c4  f8ad000c          STRH     r0,[sp,#0xc]          ;2109
0002c8  f9bd1008          LDRSH    r1,[sp,#8]            ;2110
0002cc  6820              LDR      r0,[r4,#0]            ;2110
0002ce  4408              ADD      r0,r0,r1              ;2110
0002d0  6020              STR      r0,[r4,#0]            ;2110
0002d2  f9bd100a          LDRSH    r1,[sp,#0xa]          ;2111
0002d6  6860              LDR      r0,[r4,#4]            ;2111
0002d8  4408              ADD      r0,r0,r1              ;2111
0002da  6060              STR      r0,[r4,#4]            ;2111
0002dc  f9bd100c          LDRSH    r1,[sp,#0xc]          ;2112
0002e0  68a0              LDR      r0,[r4,#8]            ;2112
0002e2  4408              ADD      r0,r0,r1              ;2112
0002e4  60a0              STR      r0,[r4,#8]            ;2112
0002e6  f89d0017          LDRB     r0,[sp,#0x17]         ;2113
0002ea  f89d1016          LDRB     r1,[sp,#0x16]         ;2113
0002ee  ea402001          ORR      r0,r0,r1,LSL #8       ;2113
0002f2  b200              SXTH     r0,r0                 ;2113
0002f4  f8ad0000          STRH     r0,[sp,#0]            ;2113
0002f8  f89d0019          LDRB     r0,[sp,#0x19]         ;2114
0002fc  f89d1018          LDRB     r1,[sp,#0x18]         ;2114
000300  ea402001          ORR      r0,r0,r1,LSL #8       ;2114
000304  b200              SXTH     r0,r0                 ;2114
000306  f8ad0002          STRH     r0,[sp,#2]            ;2114
00030a  f89d001b          LDRB     r0,[sp,#0x1b]         ;2115
00030e  f89d101a          LDRB     r1,[sp,#0x1a]         ;2115
000312  ea402001          ORR      r0,r0,r1,LSL #8       ;2115
000316  b200              SXTH     r0,r0                 ;2115
000318  f8ad0004          STRH     r0,[sp,#4]            ;2115
00031c  f9bd1000          LDRSH    r1,[sp,#0]            ;2116
000320  6828              LDR      r0,[r5,#0]            ;2116
000322  4408              ADD      r0,r0,r1              ;2116
000324  6028              STR      r0,[r5,#0]            ;2116
000326  f9bd1002          LDRSH    r1,[sp,#2]            ;2117
00032a  6868              LDR      r0,[r5,#4]            ;2117
00032c  4408              ADD      r0,r0,r1              ;2117
00032e  6068              STR      r0,[r5,#4]            ;2117
000330  f9bd1004          LDRSH    r1,[sp,#4]            ;2118
000334  68a8              LDR      r0,[r5,#8]            ;2118
000336  4408              ADD      r0,r0,r1              ;2118
000338  60a8              STR      r0,[r5,#8]            ;2118
00033a  f10a0001          ADD      r0,r10,#1             ;2103
00033e  f0000aff          AND      r10,r0,#0xff          ;2103
                  |L3.834|
000342  45b2              CMP      r10,r6                ;2103
000344  db97              BLT      |L3.630|
000346  4834              LDR      r0,|L3.1048|
000348  f8d0c000          LDR      r12,[r0,#0]           ;2135  ; test
00034c  6828              LDR      r0,[r5,#0]            ;2135
00034e  17c1              ASRS     r1,r0,#31             ;2135
000350  0409              LSLS     r1,r1,#16             ;2135
000352  ea414110          ORR      r1,r1,r0,LSR #16      ;2135
000356  0407              LSLS     r7,r0,#16             ;2135
000358  4662              MOV      r2,r12                ;2135
00035a  2300              MOVS     r3,#0                 ;2135
00035c  4638              MOV      r0,r7                 ;2135
00035e  f7fffffe          BL       __aeabi_ldivmod
000362  4632              MOV      r2,r6                 ;2135
000364  2300              MOVS     r3,#0                 ;2135
000366  e9cd0102          STRD     r0,r1,[sp,#8]         ;2135
00036a  f7fffffe          BL       __aeabi_ldivmod
00036e  6028              STR      r0,[r5,#0]            ;2135
000370  4829              LDR      r0,|L3.1048|
000372  f8d0c000          LDR      r12,[r0,#0]           ;2136  ; test
000376  6868              LDR      r0,[r5,#4]            ;2136
000378  17c1              ASRS     r1,r0,#31             ;2136
00037a  0409              LSLS     r1,r1,#16             ;2136
00037c  ea414110          ORR      r1,r1,r0,LSR #16      ;2136
000380  0407              LSLS     r7,r0,#16             ;2136
000382  4662              MOV      r2,r12                ;2136
000384  2300              MOVS     r3,#0                 ;2136
000386  4638              MOV      r0,r7                 ;2136
000388  f7fffffe          BL       __aeabi_ldivmod
00038c  4632              MOV      r2,r6                 ;2136
00038e  2300              MOVS     r3,#0                 ;2136
000390  e9cd0102          STRD     r0,r1,[sp,#8]         ;2136
000394  f7fffffe          BL       __aeabi_ldivmod
000398  6068              STR      r0,[r5,#4]            ;2136
00039a  481f              LDR      r0,|L3.1048|
00039c  f8d0c000          LDR      r12,[r0,#0]           ;2137  ; test
0003a0  68a8              LDR      r0,[r5,#8]            ;2137
0003a2  17c1              ASRS     r1,r0,#31             ;2137
0003a4  0409              LSLS     r1,r1,#16             ;2137
0003a6  ea414110          ORR      r1,r1,r0,LSR #16      ;2137
0003aa  0407              LSLS     r7,r0,#16             ;2137
0003ac  4662              MOV      r2,r12                ;2137
0003ae  2300              MOVS     r3,#0                 ;2137
0003b0  4638              MOV      r0,r7                 ;2137
0003b2  f7fffffe          BL       __aeabi_ldivmod
0003b6  4632              MOV      r2,r6                 ;2137
0003b8  2300              MOVS     r3,#0                 ;2137
0003ba  e9cd0102          STRD     r0,r1,[sp,#8]         ;2137
0003be  f7fffffe          BL       __aeabi_ldivmod
0003c2  60a8              STR      r0,[r5,#8]            ;2137
0003c4  4814              LDR      r0,|L3.1048|
0003c6  f8d0c004          LDR      r12,[r0,#4]           ;2138  ; test
0003ca  6820              LDR      r0,[r4,#0]            ;2138
0003cc  17c1              ASRS     r1,r0,#31             ;2138
0003ce  0409              LSLS     r1,r1,#16             ;2138
0003d0  ea414110          ORR      r1,r1,r0,LSR #16      ;2138
0003d4  0407              LSLS     r7,r0,#16             ;2138
0003d6  4662              MOV      r2,r12                ;2138
0003d8  2300              MOVS     r3,#0                 ;2138
0003da  4638              MOV      r0,r7                 ;2138
0003dc  f7fffffe          BL       __aeabi_ldivmod
0003e0  4632              MOV      r2,r6                 ;2138
0003e2  2300              MOVS     r3,#0                 ;2138
0003e4  e9cd0102          STRD     r0,r1,[sp,#8]         ;2138
0003e8  f7fffffe          BL       __aeabi_ldivmod
0003ec  6020              STR      r0,[r4,#0]            ;2138
0003ee  480a              LDR      r0,|L3.1048|
0003f0  f8d0c004          LDR      r12,[r0,#4]           ;2140  ; test
0003f4  6860              LDR      r0,[r4,#4]            ;2140
0003f6  17c1              ASRS     r1,r0,#31             ;2140
0003f8  0409              LSLS     r1,r1,#16             ;2140
0003fa  ea414110          ORR      r1,r1,r0,LSR #16      ;2140
0003fe  0407              LSLS     r7,r0,#16             ;2140
000400  4662              MOV      r2,r12                ;2140
000402  2300              MOVS     r3,#0                 ;2140
000404  4638              MOV      r0,r7                 ;2140
000406  f7fffffe          BL       __aeabi_ldivmod
00040a  4632              MOV      r2,r6                 ;2140
00040c  2300              MOVS     r3,#0                 ;2140
00040e  e9cd0102          STRD     r0,r1,[sp,#8]         ;2140
000412  e003              B        |L3.1052|
                  |L3.1044|
                          DCD      ||st||
                  |L3.1048|
                          DCD      test
                  |L3.1052|
00041c  f7fffffe          BL       __aeabi_ldivmod
000420  6060              STR      r0,[r4,#4]            ;2140
000422  4811              LDR      r0,|L3.1128|
000424  f8d0c004          LDR      r12,[r0,#4]           ;2142  ; test
000428  68a0              LDR      r0,[r4,#8]            ;2142
00042a  17c1              ASRS     r1,r0,#31             ;2142
00042c  0409              LSLS     r1,r1,#16             ;2142
00042e  ea414110          ORR      r1,r1,r0,LSR #16      ;2142
000432  0407              LSLS     r7,r0,#16             ;2142
000434  4662              MOV      r2,r12                ;2142
000436  2300              MOVS     r3,#0                 ;2142
000438  4638              MOV      r0,r7                 ;2142
00043a  f7fffffe          BL       __aeabi_ldivmod
00043e  4632              MOV      r2,r6                 ;2142
000440  2300              MOVS     r3,#0                 ;2142
000442  e9cd0102          STRD     r0,r1,[sp,#8]         ;2142
000446  f7fffffe          BL       __aeabi_ldivmod
00044a  60a0              STR      r0,[r4,#8]            ;2142
00044c  68a0              LDR      r0,[r4,#8]            ;2145
00044e  2800              CMP      r0,#0                 ;2145
000450  dd04              BLE      |L3.1116|
000452  68a0              LDR      r0,[r4,#8]            ;2146
000454  f5a03080          SUB      r0,r0,#0x10000        ;2146
000458  60a0              STR      r0,[r4,#8]            ;2146
00045a  e003              B        |L3.1124|
                  |L3.1116|
00045c  68a0              LDR      r0,[r4,#8]            ;2148
00045e  f5003080          ADD      r0,r0,#0x10000        ;2148
000462  60a0              STR      r0,[r4,#8]            ;2148
                  |L3.1124|
000464  2000              MOVS     r0,#0                 ;2151
000466  e5e4              B        |L3.50|
;;;2153   
                          ENDP

                  |L3.1128|
                          DCD      test

                          AREA ||i.gyro_self_test||, CODE, READONLY, ALIGN=2

                  gyro_self_test PROC
;;;1949   
;;;1950   static int gyro_self_test(long *bias_regular, long *bias_st)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;1951   {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;1952       int jj, result = 0;
000008  2500              MOVS     r5,#0
;;;1953       unsigned char tmp[3];
;;;1954       float st_shift, st_shift_cust, st_shift_var;
;;;1955   
;;;1956       if (i2c_read(st.hw->addr, 0x0D, 3, tmp))
00000a  493d              LDR      r1,|L4.256|
00000c  6849              LDR      r1,[r1,#4]  ; st
00000e  7808              LDRB     r0,[r1,#0]
000010  ab01              ADD      r3,sp,#4
000012  2203              MOVS     r2,#3
000014  210d              MOVS     r1,#0xd
000016  f7fffffe          BL       MPU_Read_Len
00001a  b110              CBZ      r0,|L4.34|
;;;1957           return 0x07;
00001c  2007              MOVS     r0,#7
                  |L4.30|
;;;1958   
;;;1959       tmp[0] &= 0x1F;
;;;1960       tmp[1] &= 0x1F;
;;;1961       tmp[2] &= 0x1F;
;;;1962   
;;;1963       for (jj = 0; jj < 3; jj++) {
;;;1964           st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
;;;1965           if (tmp[jj]) {
;;;1966               st_shift = 3275.f / test.gyro_sens;
;;;1967               while (--tmp[jj])
;;;1968                   st_shift *= 1.046f;
;;;1969               st_shift_var = st_shift_cust / st_shift - 1.f;
;;;1970               if (fabs(st_shift_var) > test.max_gyro_var)
;;;1971                   result |= 1 << jj;
;;;1972           } else if ((st_shift_cust < test.min_dps) ||
;;;1973               (st_shift_cust > test.max_dps))
;;;1974               result |= 1 << jj;
;;;1975       }
;;;1976       return result;
;;;1977   }
00001e  e8bd9ffc          POP      {r2-r12,pc}
                  |L4.34|
000022  f89d0004          LDRB     r0,[sp,#4]            ;1959
000026  f000001f          AND      r0,r0,#0x1f           ;1959
00002a  f88d0004          STRB     r0,[sp,#4]            ;1959
00002e  f89d0005          LDRB     r0,[sp,#5]            ;1960
000032  f000001f          AND      r0,r0,#0x1f           ;1960
000036  f88d0005          STRB     r0,[sp,#5]            ;1960
00003a  f89d0006          LDRB     r0,[sp,#6]            ;1961
00003e  f000001f          AND      r0,r0,#0x1f           ;1961
000042  f88d0006          STRB     r0,[sp,#6]            ;1961
000046  2400              MOVS     r4,#0                 ;1963
000048  e056              B        |L4.248|
                  |L4.74|
00004a  f8560024          LDR      r0,[r6,r4,LSL #2]     ;1964
00004e  f8571024          LDR      r1,[r7,r4,LSL #2]     ;1964
000052  eba00b01          SUB      r11,r0,r1             ;1964
000056  f1bb0f00          CMP      r11,#0                ;1964
00005a  db01              BLT      |L4.96|
00005c  4659              MOV      r1,r11                ;1964
00005e  e001              B        |L4.100|
                  |L4.96|
000060  f1cb0100          RSB      r1,r11,#0             ;1964
                  |L4.100|
000064  4608              MOV      r0,r1                 ;1964
000066  f7fffffe          BL       __aeabi_i2f
00006a  f04f418f          MOV      r1,#0x47800000        ;1964
00006e  9000              STR      r0,[sp,#0]            ;1964
000070  f7fffffe          BL       __aeabi_fdiv
000074  4681              MOV      r9,r0                 ;1964
000076  a801              ADD      r0,sp,#4              ;1965
000078  5d00              LDRB     r0,[r0,r4]            ;1965
00007a  b368              CBZ      r0,|L4.216|
00007c  4921              LDR      r1,|L4.260|
00007e  6808              LDR      r0,[r1,#0]            ;1966  ; test
000080  f7fffffe          BL       __aeabi_ui2f
000084  4683              MOV      r11,r0                ;1966
000086  4659              MOV      r1,r11                ;1966
000088  481f              LDR      r0,|L4.264|
00008a  f7fffffe          BL       __aeabi_fdiv
00008e  4680              MOV      r8,r0                 ;1966
000090  e004              B        |L4.156|
                  |L4.146|
000092  491e              LDR      r1,|L4.268|
000094  4640              MOV      r0,r8                 ;1968
000096  f7fffffe          BL       __aeabi_fmul
00009a  4680              MOV      r8,r0                 ;1968
                  |L4.156|
00009c  a801              ADD      r0,sp,#4              ;1967
00009e  5d00              LDRB     r0,[r0,r4]            ;1967
0000a0  1e40              SUBS     r0,r0,#1              ;1967
0000a2  b2c0              UXTB     r0,r0                 ;1967
0000a4  a901              ADD      r1,sp,#4              ;1967
0000a6  5508              STRB     r0,[r1,r4]            ;1967
0000a8  2800              CMP      r0,#0                 ;1967
0000aa  d1f2              BNE      |L4.146|
0000ac  4641              MOV      r1,r8                 ;1969
0000ae  4648              MOV      r0,r9                 ;1969
0000b0  f7fffffe          BL       __aeabi_fdiv
0000b4  4683              MOV      r11,r0                ;1969
0000b6  f04f517e          MOV      r1,#0x3f800000        ;1969
0000ba  f7fffffe          BL       __aeabi_fsub
0000be  4682              MOV      r10,r0                ;1969
0000c0  f02a4b00          BIC      r11,r10,#0x80000000   ;1970
0000c4  480f              LDR      r0,|L4.260|
0000c6  6981              LDR      r1,[r0,#0x18]         ;1970  ; test
0000c8  4658              MOV      r0,r11                ;1970
0000ca  f7fffffe          BL       __aeabi_cfrcmple
0000ce  d212              BCS      |L4.246|
0000d0  2001              MOVS     r0,#1                 ;1971
0000d2  40a0              LSLS     r0,r0,r4              ;1971
0000d4  4305              ORRS     r5,r5,r0              ;1971
0000d6  e00e              B        |L4.246|
                  |L4.216|
0000d8  480a              LDR      r0,|L4.260|
0000da  6901              LDR      r1,[r0,#0x10]         ;1972  ; test
0000dc  4648              MOV      r0,r9                 ;1972
0000de  f7fffffe          BL       __aeabi_cfcmple
0000e2  d305              BCC      |L4.240|
0000e4  4807              LDR      r0,|L4.260|
0000e6  6941              LDR      r1,[r0,#0x14]         ;1973  ; test
0000e8  4648              MOV      r0,r9                 ;1973
0000ea  f7fffffe          BL       __aeabi_cfrcmple
0000ee  d202              BCS      |L4.246|
                  |L4.240|
0000f0  2001              MOVS     r0,#1                 ;1974
0000f2  40a0              LSLS     r0,r0,r4              ;1974
0000f4  4305              ORRS     r5,r5,r0              ;1974
                  |L4.246|
0000f6  1c64              ADDS     r4,r4,#1              ;1963
                  |L4.248|
0000f8  2c03              CMP      r4,#3                 ;1963
0000fa  dba6              BLT      |L4.74|
0000fc  4628              MOV      r0,r5                 ;1976
0000fe  e78e              B        |L4.30|
;;;1978   
                          ENDP

                  |L4.256|
                          DCD      ||st||
                  |L4.260|
                          DCD      test
                  |L4.264|
                          DCD      0x454cb000
                  |L4.268|
                          DCD      0x3f85e354

                          AREA ||i.inv_orientation_matrix_to_scalar||, CODE, READONLY, ALIGN=1

                  inv_orientation_matrix_to_scalar PROC
;;;2905   //ÍÓÂÝÒÇ·½Ïò¿ØÖÆ
;;;2906   unsigned short inv_orientation_matrix_to_scalar(
000000  b510              PUSH     {r4,lr}
;;;2907       const signed char *mtx)
;;;2908   {
000002  4604              MOV      r4,r0
;;;2909       unsigned short scalar; 
;;;2910       /*
;;;2911          XYZ  010_001_000 Identity Matrix
;;;2912          XZY  001_010_000
;;;2913          YXZ  010_000_001
;;;2914          YZX  000_010_001
;;;2915          ZXY  001_000_010
;;;2916          ZYX  000_001_010
;;;2917        */
;;;2918   
;;;2919       scalar = inv_row_2_scale(mtx);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       inv_row_2_scale
00000a  4603              MOV      r3,r0
;;;2920       scalar |= inv_row_2_scale(mtx + 3) << 3;
00000c  1ce0              ADDS     r0,r4,#3
00000e  f7fffffe          BL       inv_row_2_scale
000012  ea4300c0          ORR      r0,r3,r0,LSL #3
000016  b283              UXTH     r3,r0
;;;2921       scalar |= inv_row_2_scale(mtx + 6) << 6;
000018  1da0              ADDS     r0,r4,#6
00001a  f7fffffe          BL       inv_row_2_scale
00001e  ea431080          ORR      r0,r3,r0,LSL #6
000022  b283              UXTH     r3,r0
;;;2922   
;;;2923   
;;;2924       return scalar;
000024  4618              MOV      r0,r3
;;;2925   }
000026  bd10              POP      {r4,pc}
;;;2926   //·½Ïò×ª»»
                          ENDP


                          AREA ||i.inv_row_2_scale||, CODE, READONLY, ALIGN=1

                  inv_row_2_scale PROC
;;;2926   //·½Ïò×ª»»
;;;2927   unsigned short inv_row_2_scale(const signed char *row)
000000  4601              MOV      r1,r0
;;;2928   {
;;;2929       unsigned short b;
;;;2930   
;;;2931       if (row[0] > 0)
000002  f9912000          LDRSB    r2,[r1,#0]
000006  2a00              CMP      r2,#0
000008  dd01              BLE      |L6.14|
;;;2932           b = 0;
00000a  2000              MOVS     r0,#0
00000c  e01e              B        |L6.76|
                  |L6.14|
;;;2933       else if (row[0] < 0)
00000e  f9912000          LDRSB    r2,[r1,#0]
000012  2a00              CMP      r2,#0
000014  da01              BGE      |L6.26|
;;;2934           b = 4;
000016  2004              MOVS     r0,#4
000018  e018              B        |L6.76|
                  |L6.26|
;;;2935       else if (row[1] > 0)
00001a  f9912001          LDRSB    r2,[r1,#1]
00001e  2a00              CMP      r2,#0
000020  dd01              BLE      |L6.38|
;;;2936           b = 1;
000022  2001              MOVS     r0,#1
000024  e012              B        |L6.76|
                  |L6.38|
;;;2937       else if (row[1] < 0)
000026  f9912001          LDRSB    r2,[r1,#1]
00002a  2a00              CMP      r2,#0
00002c  da01              BGE      |L6.50|
;;;2938           b = 5;
00002e  2005              MOVS     r0,#5
000030  e00c              B        |L6.76|
                  |L6.50|
;;;2939       else if (row[2] > 0)
000032  f9912002          LDRSB    r2,[r1,#2]
000036  2a00              CMP      r2,#0
000038  dd01              BLE      |L6.62|
;;;2940           b = 2;
00003a  2002              MOVS     r0,#2
00003c  e006              B        |L6.76|
                  |L6.62|
;;;2941       else if (row[2] < 0)
00003e  f9912002          LDRSB    r2,[r1,#2]
000042  2a00              CMP      r2,#0
000044  da01              BGE      |L6.74|
;;;2942           b = 6;
000046  2006              MOVS     r0,#6
000048  e000              B        |L6.76|
                  |L6.74|
;;;2943       else
;;;2944           b = 7;      // error
00004a  2007              MOVS     r0,#7
                  |L6.76|
;;;2945       return b;
;;;2946   }
00004c  4770              BX       lr
;;;2947   //¿Õº¯Êý,Î´ÓÃµ½.
                          ENDP


                          AREA ||i.mget_ms||, CODE, READONLY, ALIGN=1

                  mget_ms PROC
;;;2947   //¿Õº¯Êý,Î´ÓÃµ½.
;;;2948   void mget_ms(unsigned long *time)
000000  4770              BX       lr
;;;2949   {
;;;2950   
;;;2951   }
;;;2952   //mpu6050,dmp³õÊ¼»¯
                          ENDP


                          AREA ||i.mpu_configure_fifo||, CODE, READONLY, ALIGN=2

                  mpu_configure_fifo PROC
;;;1535    */
;;;1536   int mpu_configure_fifo(unsigned char sensors)
000000  b570              PUSH     {r4-r6,lr}
;;;1537   {
000002  4604              MOV      r4,r0
;;;1538       unsigned char prev;
;;;1539       int result = 0;
000004  2600              MOVS     r6,#0
;;;1540   
;;;1541       /* Compass data isn't going into the FIFO. Stop trying. */
;;;1542       sensors &= ~INV_XYZ_COMPASS;
000006  f0240401          BIC      r4,r4,#1
;;;1543   
;;;1544       if (st.chip_cfg.dmp_on)
00000a  4818              LDR      r0,|L8.108|
00000c  f8900024          LDRB     r0,[r0,#0x24]
000010  b108              CBZ      r0,|L8.22|
;;;1545           return 0;
000012  2000              MOVS     r0,#0
                  |L8.20|
;;;1546       else {
;;;1547           if (!(st.chip_cfg.sensors))
;;;1548               return -1;
;;;1549           prev = st.chip_cfg.fifo_enable;
;;;1550           st.chip_cfg.fifo_enable = sensors & st.chip_cfg.sensors;
;;;1551           if (st.chip_cfg.fifo_enable != sensors)
;;;1552               /* You're not getting what you asked for. Some sensors are
;;;1553                * asleep.
;;;1554                */
;;;1555               result = -1;
;;;1556           else
;;;1557               result = 0;
;;;1558           if (sensors || st.chip_cfg.lp_accel_mode)
;;;1559               set_int_enable(1);
;;;1560           else
;;;1561               set_int_enable(0);
;;;1562           if (sensors) {
;;;1563               if (mpu_reset_fifo()) {
;;;1564                   st.chip_cfg.fifo_enable = prev;
;;;1565                   return -1;
;;;1566               }
;;;1567           }
;;;1568       }
;;;1569   
;;;1570       return result;
;;;1571   }
000014  bd70              POP      {r4-r6,pc}
                  |L8.22|
000016  4815              LDR      r0,|L8.108|
000018  7a80              LDRB     r0,[r0,#0xa]          ;1547
00001a  b910              CBNZ     r0,|L8.34|
00001c  f04f30ff          MOV      r0,#0xffffffff        ;1548
000020  e7f8              B        |L8.20|
                  |L8.34|
000022  4812              LDR      r0,|L8.108|
000024  7c05              LDRB     r5,[r0,#0x10]         ;1549
000026  7a80              LDRB     r0,[r0,#0xa]          ;1550
000028  4020              ANDS     r0,r0,r4              ;1550
00002a  4910              LDR      r1,|L8.108|
00002c  7408              STRB     r0,[r1,#0x10]         ;1550
00002e  4608              MOV      r0,r1                 ;1551
000030  7c00              LDRB     r0,[r0,#0x10]         ;1551
000032  42a0              CMP      r0,r4                 ;1551
000034  d002              BEQ      |L8.60|
000036  f04f36ff          MOV      r6,#0xffffffff        ;1555
00003a  e000              B        |L8.62|
                  |L8.60|
00003c  2600              MOVS     r6,#0                 ;1557
                  |L8.62|
00003e  b914              CBNZ     r4,|L8.70|
000040  480a              LDR      r0,|L8.108|
000042  7d00              LDRB     r0,[r0,#0x14]         ;1558
000044  b118              CBZ      r0,|L8.78|
                  |L8.70|
000046  2001              MOVS     r0,#1                 ;1559
000048  f7fffffe          BL       set_int_enable
00004c  e002              B        |L8.84|
                  |L8.78|
00004e  2000              MOVS     r0,#0                 ;1561
000050  f7fffffe          BL       set_int_enable
                  |L8.84|
000054  b13c              CBZ      r4,|L8.102|
000056  f7fffffe          BL       mpu_reset_fifo
00005a  b120              CBZ      r0,|L8.102|
00005c  4803              LDR      r0,|L8.108|
00005e  7405              STRB     r5,[r0,#0x10]         ;1564
000060  f04f30ff          MOV      r0,#0xffffffff        ;1565
000064  e7d6              B        |L8.20|
                  |L8.102|
000066  4630              MOV      r0,r6                 ;1570
000068  e7d4              B        |L8.20|
;;;1572   
                          ENDP

00006a  0000              DCW      0x0000
                  |L8.108|
                          DCD      ||st||

                          AREA ||i.mpu_dmp_get_data||, CODE, READONLY, ALIGN=2

                  mpu_dmp_get_data PROC
;;;2989   //    ÆäËû,Ê§°Ü
;;;2990   u8 mpu_dmp_get_data(float *pitch,float *roll,float *yaw)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;2991   {
000004  b099              SUB      sp,sp,#0x64
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
00000a  4616              MOV      r6,r2
;;;2992   	float q0=1.0f,q1=0.0f,q2=0.0f,q3=0.0f;
00000c  f04f577e          MOV      r7,#0x3f800000
000010  f04f0800          MOV      r8,#0
000014  f04f0900          MOV      r9,#0
000018  f04f0a00          MOV      r10,#0
;;;2993   	unsigned long sensor_timestamp;
;;;2994   	short gyro[3], accel[3], sensors;
;;;2995   	unsigned char more;
;;;2996   	long quat[4]; 
;;;2997   	if(dmp_read_fifo(gyro, accel, quat, &sensor_timestamp, &sensors,&more))return 1;	 
00001c  a812              ADD      r0,sp,#0x48
00001e  a913              ADD      r1,sp,#0x4c
000020  ab18              ADD      r3,sp,#0x60
000022  aa0e              ADD      r2,sp,#0x38
000024  e9cd1000          STRD     r1,r0,[sp,#0]
000028  a914              ADD      r1,sp,#0x50
00002a  a816              ADD      r0,sp,#0x58
00002c  f7fffffe          BL       dmp_read_fifo
000030  b118              CBZ      r0,|L9.58|
000032  2001              MOVS     r0,#1
                  |L9.52|
;;;2998   	/* Gyro and accel data are written to the FIFO by the DMP in chip frame and hardware units.
;;;2999   	 * This behavior is convenient because it keeps the gyro and accel outputs of dmp_read_fifo and mpu_read_fifo consistent.
;;;3000   	**/
;;;3001   	/*if (sensors & INV_XYZ_GYRO )
;;;3002   	send_packet(PACKET_TYPE_GYRO, gyro);
;;;3003   	if (sensors & INV_XYZ_ACCEL)
;;;3004   	send_packet(PACKET_TYPE_ACCEL, accel); */
;;;3005   	/* Unlike gyro and accel, quaternions are written to the FIFO in the body frame, q30.
;;;3006   	 * The orientation is set by the scalar passed to dmp_set_orientation during initialization. 
;;;3007   	**/
;;;3008   	if(sensors&INV_WXYZ_QUAT) 
;;;3009   	{
;;;3010   		q0 = quat[0] / q30;	//q30¸ñÊ½×ª»»Îª¸¡µãÊý
;;;3011   		q1 = quat[1] / q30;
;;;3012   		q2 = quat[2] / q30;
;;;3013   		q3 = quat[3] / q30; 
;;;3014   		//¼ÆËãµÃµ½¸©Ñö½Ç/ºá¹ö½Ç/º½Ïò½Ç
;;;3015   		*pitch = asin(-2 * q1 * q3 + 2 * q0* q2)* 57.3;	// pitch
;;;3016   		*roll  = atan2(2 * q2 * q3 + 2 * q0 * q1, -2 * q1 * q1 - 2 * q2* q2 + 1)* 57.3;	// roll
;;;3017   		*yaw   = atan2(2*(q1*q2 + q0*q3),q0*q0+q1*q1-q2*q2-q3*q3) * 57.3;	//yaw
;;;3018   	}else return 2;
;;;3019   	return 0;
;;;3020   }
000034  b019              ADD      sp,sp,#0x64
000036  e8bd8ff0          POP      {r4-r11,pc}
                  |L9.58|
00003a  f8bd004c          LDRH     r0,[sp,#0x4c]         ;3008
00003e  f4007080          AND      r0,r0,#0x100          ;3008
000042  2800              CMP      r0,#0                 ;3008
000044  d07e              BEQ      |L9.324|
000046  980e              LDR      r0,[sp,#0x38]         ;3010
000048  f7fffffe          BL       __aeabi_i2f
00004c  4683              MOV      r11,r0                ;3010
00004e  f04f419d          MOV      r1,#0x4e800000        ;3010
000052  f7fffffe          BL       __aeabi_fdiv
000056  4607              MOV      r7,r0                 ;3010
000058  980f              LDR      r0,[sp,#0x3c]         ;3011
00005a  f7fffffe          BL       __aeabi_i2f
00005e  4683              MOV      r11,r0                ;3011
000060  f04f419d          MOV      r1,#0x4e800000        ;3011
000064  f7fffffe          BL       __aeabi_fdiv
000068  4680              MOV      r8,r0                 ;3011
00006a  9810              LDR      r0,[sp,#0x40]         ;3012
00006c  f7fffffe          BL       __aeabi_i2f
000070  4683              MOV      r11,r0                ;3012
000072  f04f419d          MOV      r1,#0x4e800000        ;3012
000076  f7fffffe          BL       __aeabi_fdiv
00007a  4681              MOV      r9,r0                 ;3012
00007c  9811              LDR      r0,[sp,#0x44]         ;3013
00007e  f7fffffe          BL       __aeabi_i2f
000082  4683              MOV      r11,r0                ;3013
000084  f04f419d          MOV      r1,#0x4e800000        ;3013
000088  f7fffffe          BL       __aeabi_fdiv
00008c  4682              MOV      r10,r0                ;3013
00008e  4639              MOV      r1,r7                 ;3015
000090  f04f4080          MOV      r0,#0x40000000        ;3015
000094  f7fffffe          BL       __aeabi_fmul
000098  4649              MOV      r1,r9                 ;3015
00009a  9005              STR      r0,[sp,#0x14]         ;3015
00009c  f7fffffe          BL       __aeabi_fmul
0000a0  4641              MOV      r1,r8                 ;3015
0000a2  9007              STR      r0,[sp,#0x1c]         ;3015
0000a4  f04f4040          MOV      r0,#0xc0000000        ;3015
0000a8  f7fffffe          BL       __aeabi_fmul
0000ac  4651              MOV      r1,r10                ;3015
0000ae  9005              STR      r0,[sp,#0x14]         ;3015
0000b0  f7fffffe          BL       __aeabi_fmul
0000b4  9006              STR      r0,[sp,#0x18]         ;3015
0000b6  9907              LDR      r1,[sp,#0x1c]         ;3015
0000b8  f7fffffe          BL       __aeabi_fadd
0000bc  4683              MOV      r11,r0                ;3015
0000be  f7fffffe          BL       __aeabi_f2d
0000c2  e9cd0108          STRD     r0,r1,[sp,#0x20]      ;3015
0000c6  f7fffffe          BL       asin
0000ca  f04f3266          MOV      r2,#0x66666666        ;3015
0000ce  4b54              LDR      r3,|L9.544|
0000d0  e9cd010a          STRD     r0,r1,[sp,#0x28]      ;3015
0000d4  f7fffffe          BL       __aeabi_dmul
0000d8  e9cd010c          STRD     r0,r1,[sp,#0x30]      ;3015
0000dc  f7fffffe          BL       __aeabi_d2f
0000e0  6020              STR      r0,[r4,#0]            ;3015
0000e2  4649              MOV      r1,r9                 ;3016
0000e4  f04f4080          MOV      r0,#0x40000000        ;3016
0000e8  f7fffffe          BL       __aeabi_fmul
0000ec  4649              MOV      r1,r9                 ;3016
0000ee  9002              STR      r0,[sp,#8]            ;3016
0000f0  f7fffffe          BL       __aeabi_fmul
0000f4  4641              MOV      r1,r8                 ;3016
0000f6  9004              STR      r0,[sp,#0x10]         ;3016
0000f8  f04f4040          MOV      r0,#0xc0000000        ;3016
0000fc  f7fffffe          BL       __aeabi_fmul
000100  4641              MOV      r1,r8                 ;3016
000102  9002              STR      r0,[sp,#8]            ;3016
000104  f7fffffe          BL       __aeabi_fmul
000108  9003              STR      r0,[sp,#0xc]          ;3016
00010a  9904              LDR      r1,[sp,#0x10]         ;3016
00010c  f7fffffe          BL       __aeabi_fsub
000110  4683              MOV      r11,r0                ;3016
000112  f04f517e          MOV      r1,#0x3f800000        ;3016
000116  f7fffffe          BL       __aeabi_fadd
00011a  9005              STR      r0,[sp,#0x14]         ;3016
00011c  f7fffffe          BL       __aeabi_f2d
000120  e9cd0108          STRD     r0,r1,[sp,#0x20]      ;3016
000124  4639              MOV      r1,r7                 ;3016
000126  f04f4080          MOV      r0,#0x40000000        ;3016
00012a  f7fffffe          BL       __aeabi_fmul
00012e  4641              MOV      r1,r8                 ;3016
000130  9003              STR      r0,[sp,#0xc]          ;3016
000132  f7fffffe          BL       __aeabi_fmul
000136  4649              MOV      r1,r9                 ;3016
000138  9004              STR      r0,[sp,#0x10]         ;3016
00013a  f04f4080          MOV      r0,#0x40000000        ;3016
00013e  f7fffffe          BL       __aeabi_fmul
000142  e000              B        |L9.326|
                  |L9.324|
000144  e068              B        |L9.536|
                  |L9.326|
000146  4651              MOV      r1,r10                ;3016
000148  9003              STR      r0,[sp,#0xc]          ;3016
00014a  f7fffffe          BL       __aeabi_fmul
00014e  4683              MOV      r11,r0                ;3016
000150  9904              LDR      r1,[sp,#0x10]         ;3016
000152  f7fffffe          BL       __aeabi_fadd
000156  9005              STR      r0,[sp,#0x14]         ;3016
000158  f7fffffe          BL       __aeabi_f2d
00015c  e9cd0106          STRD     r0,r1,[sp,#0x18]      ;3016
000160  e9dd2308          LDRD     r2,r3,[sp,#0x20]      ;3016
000164  f7fffffe          BL       atan2
000168  f04f3266          MOV      r2,#0x66666666        ;3016
00016c  4b2c              LDR      r3,|L9.544|
00016e  e9cd010a          STRD     r0,r1,[sp,#0x28]      ;3016
000172  f7fffffe          BL       __aeabi_dmul
000176  e9cd010c          STRD     r0,r1,[sp,#0x30]      ;3016
00017a  f7fffffe          BL       __aeabi_d2f
00017e  6028              STR      r0,[r5,#0]            ;3016
000180  4651              MOV      r1,r10                ;3017
000182  4650              MOV      r0,r10                ;3017
000184  f7fffffe          BL       __aeabi_fmul
000188  4649              MOV      r1,r9                 ;3017
00018a  9004              STR      r0,[sp,#0x10]         ;3017
00018c  4648              MOV      r0,r9                 ;3017
00018e  f7fffffe          BL       __aeabi_fmul
000192  4641              MOV      r1,r8                 ;3017
000194  9003              STR      r0,[sp,#0xc]          ;3017
000196  4640              MOV      r0,r8                 ;3017
000198  f7fffffe          BL       __aeabi_fmul
00019c  4639              MOV      r1,r7                 ;3017
00019e  9001              STR      r0,[sp,#4]            ;3017
0001a0  4638              MOV      r0,r7                 ;3017
0001a2  f7fffffe          BL       __aeabi_fmul
0001a6  9000              STR      r0,[sp,#0]            ;3017
0001a8  9901              LDR      r1,[sp,#4]            ;3017
0001aa  f7fffffe          BL       __aeabi_fadd
0001ae  9002              STR      r0,[sp,#8]            ;3017
0001b0  9903              LDR      r1,[sp,#0xc]          ;3017
0001b2  f7fffffe          BL       __aeabi_fsub
0001b6  4683              MOV      r11,r0                ;3017
0001b8  9904              LDR      r1,[sp,#0x10]         ;3017
0001ba  f7fffffe          BL       __aeabi_fsub
0001be  9005              STR      r0,[sp,#0x14]         ;3017
0001c0  f7fffffe          BL       __aeabi_f2d
0001c4  e9cd0108          STRD     r0,r1,[sp,#0x20]      ;3017
0001c8  4651              MOV      r1,r10                ;3017
0001ca  4638              MOV      r0,r7                 ;3017
0001cc  f7fffffe          BL       __aeabi_fmul
0001d0  4649              MOV      r1,r9                 ;3017
0001d2  9004              STR      r0,[sp,#0x10]         ;3017
0001d4  4640              MOV      r0,r8                 ;3017
0001d6  f7fffffe          BL       __aeabi_fmul
0001da  9003              STR      r0,[sp,#0xc]          ;3017
0001dc  9904              LDR      r1,[sp,#0x10]         ;3017
0001de  f7fffffe          BL       __aeabi_fadd
0001e2  f04f4180          MOV      r1,#0x40000000        ;3017
0001e6  9005              STR      r0,[sp,#0x14]         ;3017
0001e8  f7fffffe          BL       __aeabi_fmul
0001ec  4683              MOV      r11,r0                ;3017
0001ee  f7fffffe          BL       __aeabi_f2d
0001f2  e9cd0106          STRD     r0,r1,[sp,#0x18]      ;3017
0001f6  e9dd2308          LDRD     r2,r3,[sp,#0x20]      ;3017
0001fa  f7fffffe          BL       atan2
0001fe  f04f3266          MOV      r2,#0x66666666        ;3017
000202  4b07              LDR      r3,|L9.544|
000204  e9cd010a          STRD     r0,r1,[sp,#0x28]      ;3017
000208  f7fffffe          BL       __aeabi_dmul
00020c  e9cd010c          STRD     r0,r1,[sp,#0x30]      ;3017
000210  f7fffffe          BL       __aeabi_d2f
000214  6030              STR      r0,[r6,#0]            ;3017
000216  e001              B        |L9.540|
                  |L9.536|
000218  2002              MOVS     r0,#2                 ;3018
00021a  e70b              B        |L9.52|
                  |L9.540|
00021c  2000              MOVS     r0,#0                 ;3019
00021e  e709              B        |L9.52|
                          ENDP

                  |L9.544|
                          DCD      0x404ca666

                          AREA ||i.mpu_dmp_init||, CODE, READONLY, ALIGN=2

                  mpu_dmp_init PROC
;;;2954   //    ÆäËû,Ê§°Ü
;;;2955   u8 mpu_dmp_init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;2956   {
;;;2957   	u8 res=0;
000002  2400              MOVS     r4,#0
;;;2958   	MPU_IIC_Init(); 	//³õÊ¼»¯IIC×ÜÏß
000004  f7fffffe          BL       MPU_IIC_Init
;;;2959   	if(mpu_init()==0)	//³õÊ¼»¯MPU6050
000008  f7fffffe          BL       mpu_init
00000c  2800              CMP      r0,#0
00000e  d13e              BNE      |L10.142|
;;;2960   	{	 
;;;2961   		res=mpu_set_sensors(INV_XYZ_GYRO|INV_XYZ_ACCEL);//ÉèÖÃËùÐèÒªµÄ´«¸ÐÆ÷
000010  2078              MOVS     r0,#0x78
000012  f7fffffe          BL       mpu_set_sensors
000016  b2c4              UXTB     r4,r0
;;;2962   		if(res)return 1; 
000018  b10c              CBZ      r4,|L10.30|
00001a  2001              MOVS     r0,#1
                  |L10.28|
;;;2963   		res=mpu_configure_fifo(INV_XYZ_GYRO|INV_XYZ_ACCEL);//ÉèÖÃFIFO
;;;2964   		if(res)return 2; 
;;;2965   		res=mpu_set_sample_rate(DEFAULT_MPU_HZ);	//ÉèÖÃ²ÉÑùÂÊ
;;;2966   		if(res)return 3; 
;;;2967   		res=dmp_load_motion_driver_firmware();		//¼ÓÔØdmp¹Ì¼þ
;;;2968   		if(res)return 4; 
;;;2969   		res=dmp_set_orientation(inv_orientation_matrix_to_scalar(gyro_orientation));//ÉèÖÃÍÓÂÝÒÇ·½Ïò
;;;2970   		if(res)return 5; 
;;;2971   		res=dmp_enable_feature(DMP_FEATURE_6X_LP_QUAT|DMP_FEATURE_TAP|	//ÉèÖÃdmp¹¦ÄÜ
;;;2972   		    DMP_FEATURE_ANDROID_ORIENT|DMP_FEATURE_SEND_RAW_ACCEL|DMP_FEATURE_SEND_CAL_GYRO|
;;;2973   		    DMP_FEATURE_GYRO_CAL);
;;;2974   		if(res)return 6; 
;;;2975   		res=dmp_set_fifo_rate(DEFAULT_MPU_HZ);	//ÉèÖÃDMPÊä³öËÙÂÊ(×î´ó²»³¬¹ý200Hz)
;;;2976   		if(res)return 7;   
;;;2977   		res=run_self_test();		//×Ô¼ì
;;;2978   	//	if(res)return 8;    
;;;2979   		res=mpu_set_dmp_state(1);	//Ê¹ÄÜDMP
;;;2980   		if(res)return 9;     
;;;2981   	}else return 10;
;;;2982   	//return 0;
;;;2983   }
00001c  bd70              POP      {r4-r6,pc}
                  |L10.30|
00001e  2078              MOVS     r0,#0x78              ;2963
000020  f7fffffe          BL       mpu_configure_fifo
000024  b2c4              UXTB     r4,r0                 ;2963
000026  b10c              CBZ      r4,|L10.44|
000028  2002              MOVS     r0,#2                 ;2964
00002a  e7f7              B        |L10.28|
                  |L10.44|
00002c  2064              MOVS     r0,#0x64              ;2965
00002e  f7fffffe          BL       mpu_set_sample_rate
000032  b2c4              UXTB     r4,r0                 ;2965
000034  b10c              CBZ      r4,|L10.58|
000036  2003              MOVS     r0,#3                 ;2966
000038  e7f0              B        |L10.28|
                  |L10.58|
00003a  f7fffffe          BL       dmp_load_motion_driver_firmware
00003e  b2c4              UXTB     r4,r0                 ;2967
000040  b10c              CBZ      r4,|L10.70|
000042  2004              MOVS     r0,#4                 ;2968
000044  e7ea              B        |L10.28|
                  |L10.70|
000046  4814              LDR      r0,|L10.152|
000048  f7fffffe          BL       inv_orientation_matrix_to_scalar
00004c  4605              MOV      r5,r0                 ;2969
00004e  f7fffffe          BL       dmp_set_orientation
000052  b2c4              UXTB     r4,r0                 ;2969
000054  b10c              CBZ      r4,|L10.90|
000056  2005              MOVS     r0,#5                 ;2970
000058  e7e0              B        |L10.28|
                  |L10.90|
00005a  f2401073          MOV      r0,#0x173             ;2971
00005e  f7fffffe          BL       dmp_enable_feature
000062  b2c4              UXTB     r4,r0                 ;2971
000064  b10c              CBZ      r4,|L10.106|
000066  2006              MOVS     r0,#6                 ;2974
000068  e7d8              B        |L10.28|
                  |L10.106|
00006a  2064              MOVS     r0,#0x64              ;2975
00006c  f7fffffe          BL       dmp_set_fifo_rate
000070  b2c4              UXTB     r4,r0                 ;2975
000072  b10c              CBZ      r4,|L10.120|
000074  2007              MOVS     r0,#7                 ;2976
000076  e7d1              B        |L10.28|
                  |L10.120|
000078  f7fffffe          BL       run_self_test
00007c  4604              MOV      r4,r0                 ;2977
00007e  2001              MOVS     r0,#1                 ;2979
000080  f7fffffe          BL       mpu_set_dmp_state
000084  b2c0              UXTB     r0,r0                 ;2979
000086  4604              MOV      r4,r0                 ;2979
000088  b11c              CBZ      r4,|L10.146|
00008a  2009              MOVS     r0,#9                 ;2980
00008c  e7c6              B        |L10.28|
                  |L10.142|
00008e  200a              MOVS     r0,#0xa               ;2981
000090  e7c4              B        |L10.28|
                  |L10.146|
000092  bf00              NOP      
000094  e7c2              B        |L10.28|
;;;2984   //µÃµ½dmp´¦ÀíºóµÄÊý¾Ý(×¢Òâ,±¾º¯ÊýÐèÒª±È½Ï¶à¶ÑÕ»,¾Ö²¿±äÁ¿ÓÐµã¶à)
                          ENDP

000096  0000              DCW      0x0000
                  |L10.152|
                          DCD      gyro_orientation

                          AREA ||i.mpu_get_accel_fsr||, CODE, READONLY, ALIGN=2

                  mpu_get_accel_fsr PROC
;;;1222    */
;;;1223   int mpu_get_accel_fsr(unsigned char *fsr)
000000  4601              MOV      r1,r0
;;;1224   {
;;;1225       switch (st.chip_cfg.accel_fsr) {
000002  4811              LDR      r0,|L11.72|
000004  7a40              LDRB     r0,[r0,#9]
000006  b130              CBZ      r0,|L11.22|
000008  2801              CMP      r0,#1
00000a  d007              BEQ      |L11.28|
00000c  2802              CMP      r0,#2
00000e  d008              BEQ      |L11.34|
000010  2803              CMP      r0,#3
000012  d10c              BNE      |L11.46|
000014  e008              B        |L11.40|
                  |L11.22|
;;;1226       case INV_FSR_2G:
;;;1227           fsr[0] = 2;
000016  2002              MOVS     r0,#2
000018  7008              STRB     r0,[r1,#0]
;;;1228           break;
00001a  e00b              B        |L11.52|
                  |L11.28|
;;;1229       case INV_FSR_4G:
;;;1230           fsr[0] = 4;
00001c  2004              MOVS     r0,#4
00001e  7008              STRB     r0,[r1,#0]
;;;1231           break;
000020  e008              B        |L11.52|
                  |L11.34|
;;;1232       case INV_FSR_8G:
;;;1233           fsr[0] = 8;
000022  2008              MOVS     r0,#8
000024  7008              STRB     r0,[r1,#0]
;;;1234           break;
000026  e005              B        |L11.52|
                  |L11.40|
;;;1235       case INV_FSR_16G:
;;;1236           fsr[0] = 16;
000028  2010              MOVS     r0,#0x10
00002a  7008              STRB     r0,[r1,#0]
;;;1237           break;
00002c  e002              B        |L11.52|
                  |L11.46|
;;;1238       default:
;;;1239           return -1;
00002e  f04f30ff          MOV      r0,#0xffffffff
                  |L11.50|
;;;1240       }
;;;1241       if (st.chip_cfg.accel_half)
;;;1242           fsr[0] <<= 1;
;;;1243       return 0;
;;;1244   }
000032  4770              BX       lr
                  |L11.52|
000034  bf00              NOP                            ;1228
000036  4804              LDR      r0,|L11.72|
000038  7cc0              LDRB     r0,[r0,#0x13]         ;1241
00003a  b118              CBZ      r0,|L11.68|
00003c  7808              LDRB     r0,[r1,#0]            ;1242
00003e  0640              LSLS     r0,r0,#25             ;1242
000040  0e00              LSRS     r0,r0,#24             ;1242
000042  7008              STRB     r0,[r1,#0]            ;1242
                  |L11.68|
000044  2000              MOVS     r0,#0                 ;1243
000046  e7f4              B        |L11.50|
;;;1245   
                          ENDP

                  |L11.72|
                          DCD      ||st||

                          AREA ||i.mpu_get_accel_reg||, CODE, READONLY, ALIGN=2

                  mpu_get_accel_reg PROC
;;;999     */
;;;1000   int mpu_get_accel_reg(short *data, unsigned long *timestamp)
000000  b57c              PUSH     {r2-r6,lr}
;;;1001   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1002       unsigned char tmp[6];
;;;1003   
;;;1004       if (!(st.chip_cfg.sensors & INV_XYZ_ACCEL))
000006  481a              LDR      r0,|L12.112|
000008  7a80              LDRB     r0,[r0,#0xa]
00000a  f0000008          AND      r0,r0,#8
00000e  b910              CBNZ     r0,|L12.22|
;;;1005           return -1;
000010  f04f30ff          MOV      r0,#0xffffffff
                  |L12.20|
;;;1006   
;;;1007       if (i2c_read(st.hw->addr, st.reg->raw_accel, 6, tmp))
;;;1008           return -1;
;;;1009       data[0] = (tmp[0] << 8) | tmp[1];
;;;1010       data[1] = (tmp[2] << 8) | tmp[3];
;;;1011       data[2] = (tmp[4] << 8) | tmp[5];
;;;1012       if (timestamp)
;;;1013           get_ms(timestamp);
;;;1014       return 0;
;;;1015   }
000014  bd7c              POP      {r2-r6,pc}
                  |L12.22|
000016  4a16              LDR      r2,|L12.112|
000018  6812              LDR      r2,[r2,#0]            ;1007  ; st
00001a  7b51              LDRB     r1,[r2,#0xd]          ;1007
00001c  4a14              LDR      r2,|L12.112|
00001e  6852              LDR      r2,[r2,#4]            ;1007  ; st
000020  7810              LDRB     r0,[r2,#0]            ;1007
000022  466b              MOV      r3,sp                 ;1007
000024  2206              MOVS     r2,#6                 ;1007
000026  f7fffffe          BL       MPU_Read_Len
00002a  b110              CBZ      r0,|L12.50|
00002c  f04f30ff          MOV      r0,#0xffffffff        ;1008
000030  e7f0              B        |L12.20|
                  |L12.50|
000032  f89d0001          LDRB     r0,[sp,#1]            ;1009
000036  f89d1000          LDRB     r1,[sp,#0]            ;1009
00003a  ea402001          ORR      r0,r0,r1,LSL #8       ;1009
00003e  b200              SXTH     r0,r0                 ;1009
000040  8020              STRH     r0,[r4,#0]            ;1009
000042  f89d0003          LDRB     r0,[sp,#3]            ;1010
000046  f89d1002          LDRB     r1,[sp,#2]            ;1010
00004a  ea402001          ORR      r0,r0,r1,LSL #8       ;1010
00004e  b200              SXTH     r0,r0                 ;1010
000050  8060              STRH     r0,[r4,#2]            ;1010
000052  f89d0005          LDRB     r0,[sp,#5]            ;1011
000056  f89d1004          LDRB     r1,[sp,#4]            ;1011
00005a  ea402001          ORR      r0,r0,r1,LSL #8       ;1011
00005e  b200              SXTH     r0,r0                 ;1011
000060  80a0              STRH     r0,[r4,#4]            ;1011
000062  b115              CBZ      r5,|L12.106|
000064  4628              MOV      r0,r5                 ;1013
000066  f7fffffe          BL       mget_ms
                  |L12.106|
00006a  2000              MOVS     r0,#0                 ;1014
00006c  e7d2              B        |L12.20|
;;;1016   
                          ENDP

00006e  0000              DCW      0x0000
                  |L12.112|
                          DCD      ||st||

                          AREA ||i.mpu_get_accel_sens||, CODE, READONLY, ALIGN=2

                  mpu_get_accel_sens PROC
;;;1488    */
;;;1489   int mpu_get_accel_sens(unsigned short *sens)
000000  4601              MOV      r1,r0
;;;1490   {
;;;1491       switch (st.chip_cfg.accel_fsr) {
000002  4813              LDR      r0,|L13.80|
000004  7a40              LDRB     r0,[r0,#9]
000006  b130              CBZ      r0,|L13.22|
000008  2801              CMP      r0,#1
00000a  d008              BEQ      |L13.30|
00000c  2802              CMP      r0,#2
00000e  d00a              BEQ      |L13.38|
000010  2803              CMP      r0,#3
000012  d110              BNE      |L13.54|
000014  e00b              B        |L13.46|
                  |L13.22|
;;;1492       case INV_FSR_2G:
;;;1493           sens[0] = 16384;
000016  f44f4080          MOV      r0,#0x4000
00001a  8008              STRH     r0,[r1,#0]
;;;1494           break;
00001c  e00e              B        |L13.60|
                  |L13.30|
;;;1495       case INV_FSR_4G:
;;;1496           sens[0] = 8092;
00001e  f641709c          MOV      r0,#0x1f9c
000022  8008              STRH     r0,[r1,#0]
;;;1497           break;
000024  e00a              B        |L13.60|
                  |L13.38|
;;;1498       case INV_FSR_8G:
;;;1499           sens[0] = 4096;
000026  f44f5080          MOV      r0,#0x1000
00002a  8008              STRH     r0,[r1,#0]
;;;1500           break;
00002c  e006              B        |L13.60|
                  |L13.46|
;;;1501       case INV_FSR_16G:
;;;1502           sens[0] = 2048;
00002e  f44f6000          MOV      r0,#0x800
000032  8008              STRH     r0,[r1,#0]
;;;1503           break;
000034  e002              B        |L13.60|
                  |L13.54|
;;;1504       default:
;;;1505           return -1;
000036  f04f30ff          MOV      r0,#0xffffffff
                  |L13.58|
;;;1506       }
;;;1507       if (st.chip_cfg.accel_half)
;;;1508           sens[0] >>= 1;
;;;1509       return 0;
;;;1510   }
00003a  4770              BX       lr
                  |L13.60|
00003c  bf00              NOP                            ;1494
00003e  4804              LDR      r0,|L13.80|
000040  7cc0              LDRB     r0,[r0,#0x13]         ;1507
000042  b110              CBZ      r0,|L13.74|
000044  8808              LDRH     r0,[r1,#0]            ;1508
000046  1040              ASRS     r0,r0,#1              ;1508
000048  8008              STRH     r0,[r1,#0]            ;1508
                  |L13.74|
00004a  2000              MOVS     r0,#0                 ;1509
00004c  e7f5              B        |L13.58|
;;;1511   
                          ENDP

00004e  0000              DCW      0x0000
                  |L13.80|
                          DCD      ||st||

                          AREA ||i.mpu_get_compass_fsr||, CODE, READONLY, ALIGN=1

                  mpu_get_compass_fsr PROC
;;;2592    */
;;;2593   int mpu_get_compass_fsr(unsigned short *fsr)
000000  4601              MOV      r1,r0
;;;2594   {
;;;2595   #ifdef AK89xx_SECONDARY
;;;2596       fsr[0] = st.hw->compass_fsr;
;;;2597       return 0;
;;;2598   #else
;;;2599       return -1;
000002  f04f30ff          MOV      r0,#0xffffffff
;;;2600   #endif
;;;2601   }
000006  4770              BX       lr
;;;2602   
                          ENDP


                          AREA ||i.mpu_get_compass_reg||, CODE, READONLY, ALIGN=1

                  mpu_get_compass_reg PROC
;;;2539    */
;;;2540   int mpu_get_compass_reg(short *data, unsigned long *timestamp)
000000  4602              MOV      r2,r0
;;;2541   {
;;;2542   #ifdef AK89xx_SECONDARY
;;;2543       unsigned char tmp[9];
;;;2544   
;;;2545       if (!(st.chip_cfg.sensors & INV_XYZ_COMPASS))
;;;2546           return -1;
;;;2547   
;;;2548   #ifdef AK89xx_BYPASS
;;;2549       if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ST1, 8, tmp))
;;;2550           return -1;
;;;2551       tmp[8] = AKM_SINGLE_MEASUREMENT;
;;;2552       if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp+8))
;;;2553           return -1;
;;;2554   #else
;;;2555       if (i2c_read(st.hw->addr, st.reg->raw_compass, 8, tmp))
;;;2556           return -1;
;;;2557   #endif
;;;2558   
;;;2559   #if defined AK8975_SECONDARY
;;;2560       /* AK8975 doesn't have the overrun error bit. */
;;;2561       if (!(tmp[0] & AKM_DATA_READY))
;;;2562           return -2;
;;;2563       if ((tmp[7] & AKM_OVERFLOW) || (tmp[7] & AKM_DATA_ERROR))
;;;2564           return -3;
;;;2565   #elif defined AK8963_SECONDARY
;;;2566       /* AK8963 doesn't have the data read error bit. */
;;;2567       if (!(tmp[0] & AKM_DATA_READY) || (tmp[0] & AKM_DATA_OVERRUN))
;;;2568           return -2;
;;;2569       if (tmp[7] & AKM_OVERFLOW)
;;;2570           return -3;
;;;2571   #endif
;;;2572       data[0] = (tmp[2] << 8) | tmp[1];
;;;2573       data[1] = (tmp[4] << 8) | tmp[3];
;;;2574       data[2] = (tmp[6] << 8) | tmp[5];
;;;2575   
;;;2576       data[0] = ((long)data[0] * st.chip_cfg.mag_sens_adj[0]) >> 8;
;;;2577       data[1] = ((long)data[1] * st.chip_cfg.mag_sens_adj[1]) >> 8;
;;;2578       data[2] = ((long)data[2] * st.chip_cfg.mag_sens_adj[2]) >> 8;
;;;2579   
;;;2580       if (timestamp)
;;;2581           get_ms(timestamp);
;;;2582       return 0;
;;;2583   #else
;;;2584       return -1;
000002  f04f30ff          MOV      r0,#0xffffffff
;;;2585   #endif
;;;2586   }
000006  4770              BX       lr
;;;2587   
                          ENDP


                          AREA ||i.mpu_get_compass_sample_rate||, CODE, READONLY, ALIGN=1

                  mpu_get_compass_sample_rate PROC
;;;1418    */
;;;1419   int mpu_get_compass_sample_rate(unsigned short *rate)
000000  4601              MOV      r1,r0
;;;1420   {
;;;1421   #ifdef AK89xx_SECONDARY
;;;1422       rate[0] = st.chip_cfg.compass_sample_rate;
;;;1423       return 0;
;;;1424   #else
;;;1425       rate[0] = 0;
000002  2000              MOVS     r0,#0
000004  8008              STRH     r0,[r1,#0]
;;;1426       return -1;
000006  1e40              SUBS     r0,r0,#1
;;;1427   #endif
;;;1428   }
000008  4770              BX       lr
;;;1429   
                          ENDP


                          AREA ||i.mpu_get_dmp_state||, CODE, READONLY, ALIGN=2

                  mpu_get_dmp_state PROC
;;;2420    */
;;;2421   int mpu_get_dmp_state(unsigned char *enabled)
000000  4601              MOV      r1,r0
;;;2422   {
;;;2423       enabled[0] = st.chip_cfg.dmp_on;
000002  4803              LDR      r0,|L17.16|
000004  f8900024          LDRB     r0,[r0,#0x24]
000008  7008              STRB     r0,[r1,#0]
;;;2424       return 0;
00000a  2000              MOVS     r0,#0
;;;2425   }
00000c  4770              BX       lr
;;;2426   
                          ENDP

00000e  0000              DCW      0x0000
                  |L17.16|
                          DCD      ||st||

                          AREA ||i.mpu_get_fifo_config||, CODE, READONLY, ALIGN=2

                  mpu_get_fifo_config PROC
;;;1520    */
;;;1521   int mpu_get_fifo_config(unsigned char *sensors)
000000  4601              MOV      r1,r0
;;;1522   {
;;;1523       sensors[0] = st.chip_cfg.fifo_enable;
000002  4802              LDR      r0,|L18.12|
000004  7c00              LDRB     r0,[r0,#0x10]
000006  7008              STRB     r0,[r1,#0]
;;;1524       return 0;
000008  2000              MOVS     r0,#0
;;;1525   }
00000a  4770              BX       lr
;;;1526   
                          ENDP

                  |L18.12|
                          DCD      ||st||

                          AREA ||i.mpu_get_gyro_fsr||, CODE, READONLY, ALIGN=2

                  mpu_get_gyro_fsr PROC
;;;1158    */
;;;1159   int mpu_get_gyro_fsr(unsigned short *fsr)
000000  4601              MOV      r1,r0
;;;1160   {
;;;1161       switch (st.chip_cfg.gyro_fsr) {
000002  480f              LDR      r0,|L19.64|
000004  7a00              LDRB     r0,[r0,#8]  ; st
000006  b130              CBZ      r0,|L19.22|
000008  2801              CMP      r0,#1
00000a  d007              BEQ      |L19.28|
00000c  2802              CMP      r0,#2
00000e  d009              BEQ      |L19.36|
000010  2803              CMP      r0,#3
000012  d10f              BNE      |L19.52|
000014  e00a              B        |L19.44|
                  |L19.22|
;;;1162       case INV_FSR_250DPS:
;;;1163           fsr[0] = 250;
000016  20fa              MOVS     r0,#0xfa
000018  8008              STRH     r0,[r1,#0]
;;;1164           break;
00001a  e00e              B        |L19.58|
                  |L19.28|
;;;1165       case INV_FSR_500DPS:
;;;1166           fsr[0] = 500;
00001c  f44f70fa          MOV      r0,#0x1f4
000020  8008              STRH     r0,[r1,#0]
;;;1167           break;
000022  e00a              B        |L19.58|
                  |L19.36|
;;;1168       case INV_FSR_1000DPS:
;;;1169           fsr[0] = 1000;
000024  f44f707a          MOV      r0,#0x3e8
000028  8008              STRH     r0,[r1,#0]
;;;1170           break;
00002a  e006              B        |L19.58|
                  |L19.44|
;;;1171       case INV_FSR_2000DPS:
;;;1172           fsr[0] = 2000;
00002c  f44f60fa          MOV      r0,#0x7d0
000030  8008              STRH     r0,[r1,#0]
;;;1173           break;
000032  e002              B        |L19.58|
                  |L19.52|
;;;1174       default:
;;;1175           fsr[0] = 0;
000034  2000              MOVS     r0,#0
000036  8008              STRH     r0,[r1,#0]
;;;1176           break;
000038  bf00              NOP      
                  |L19.58|
00003a  bf00              NOP                            ;1164
;;;1177       }
;;;1178       return 0;
00003c  2000              MOVS     r0,#0
;;;1179   }
00003e  4770              BX       lr
;;;1180   
                          ENDP

                  |L19.64|
                          DCD      ||st||

                          AREA ||i.mpu_get_gyro_reg||, CODE, READONLY, ALIGN=2

                  mpu_get_gyro_reg PROC
;;;976     */
;;;977    int mpu_get_gyro_reg(short *data, unsigned long *timestamp)
000000  b57c              PUSH     {r2-r6,lr}
;;;978    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;979        unsigned char tmp[6];
;;;980    
;;;981        if (!(st.chip_cfg.sensors & INV_XYZ_GYRO))
000006  481a              LDR      r0,|L20.112|
000008  7a80              LDRB     r0,[r0,#0xa]
00000a  f0000070          AND      r0,r0,#0x70
00000e  b910              CBNZ     r0,|L20.22|
;;;982            return -1;
000010  f04f30ff          MOV      r0,#0xffffffff
                  |L20.20|
;;;983    
;;;984        if (i2c_read(st.hw->addr, st.reg->raw_gyro, 6, tmp))
;;;985            return -1;
;;;986        data[0] = (tmp[0] << 8) | tmp[1];
;;;987        data[1] = (tmp[2] << 8) | tmp[3];
;;;988        data[2] = (tmp[4] << 8) | tmp[5];
;;;989        if (timestamp)
;;;990            get_ms(timestamp);
;;;991        return 0;
;;;992    }
000014  bd7c              POP      {r2-r6,pc}
                  |L20.22|
000016  4a16              LDR      r2,|L20.112|
000018  6812              LDR      r2,[r2,#0]            ;984  ; st
00001a  7b11              LDRB     r1,[r2,#0xc]          ;984
00001c  4a14              LDR      r2,|L20.112|
00001e  6852              LDR      r2,[r2,#4]            ;984  ; st
000020  7810              LDRB     r0,[r2,#0]            ;984
000022  466b              MOV      r3,sp                 ;984
000024  2206              MOVS     r2,#6                 ;984
000026  f7fffffe          BL       MPU_Read_Len
00002a  b110              CBZ      r0,|L20.50|
00002c  f04f30ff          MOV      r0,#0xffffffff        ;985
000030  e7f0              B        |L20.20|
                  |L20.50|
000032  f89d0001          LDRB     r0,[sp,#1]            ;986
000036  f89d1000          LDRB     r1,[sp,#0]            ;986
00003a  ea402001          ORR      r0,r0,r1,LSL #8       ;986
00003e  b200              SXTH     r0,r0                 ;986
000040  8020              STRH     r0,[r4,#0]            ;986
000042  f89d0003          LDRB     r0,[sp,#3]            ;987
000046  f89d1002          LDRB     r1,[sp,#2]            ;987
00004a  ea402001          ORR      r0,r0,r1,LSL #8       ;987
00004e  b200              SXTH     r0,r0                 ;987
000050  8060              STRH     r0,[r4,#2]            ;987
000052  f89d0005          LDRB     r0,[sp,#5]            ;988
000056  f89d1004          LDRB     r1,[sp,#4]            ;988
00005a  ea402001          ORR      r0,r0,r1,LSL #8       ;988
00005e  b200              SXTH     r0,r0                 ;988
000060  80a0              STRH     r0,[r4,#4]            ;988
000062  b115              CBZ      r5,|L20.106|
000064  4628              MOV      r0,r5                 ;990
000066  f7fffffe          BL       mget_ms
                  |L20.106|
00006a  2000              MOVS     r0,#0                 ;991
00006c  e7d2              B        |L20.20|
;;;993    
                          ENDP

00006e  0000              DCW      0x0000
                  |L20.112|
                          DCD      ||st||

                          AREA ||i.mpu_get_gyro_sens||, CODE, READONLY, ALIGN=2

                  mpu_get_gyro_sens PROC
;;;1462    */
;;;1463   int mpu_get_gyro_sens(float *sens)
000000  4601              MOV      r1,r0
;;;1464   {
;;;1465       switch (st.chip_cfg.gyro_fsr) {
000002  480e              LDR      r0,|L21.60|
000004  7a00              LDRB     r0,[r0,#8]  ; st
000006  b130              CBZ      r0,|L21.22|
000008  2801              CMP      r0,#1
00000a  d007              BEQ      |L21.28|
00000c  2802              CMP      r0,#2
00000e  d008              BEQ      |L21.34|
000010  2803              CMP      r0,#3
000012  d10c              BNE      |L21.46|
000014  e008              B        |L21.40|
                  |L21.22|
;;;1466       case INV_FSR_250DPS:
;;;1467           sens[0] = 131.f;
000016  480a              LDR      r0,|L21.64|
000018  6008              STR      r0,[r1,#0]
;;;1468           break;
00001a  e00b              B        |L21.52|
                  |L21.28|
;;;1469       case INV_FSR_500DPS:
;;;1470           sens[0] = 65.5f;
00001c  4809              LDR      r0,|L21.68|
00001e  6008              STR      r0,[r1,#0]
;;;1471           break;
000020  e008              B        |L21.52|
                  |L21.34|
;;;1472       case INV_FSR_1000DPS:
;;;1473           sens[0] = 32.8f;
000022  4809              LDR      r0,|L21.72|
000024  6008              STR      r0,[r1,#0]
;;;1474           break;
000026  e005              B        |L21.52|
                  |L21.40|
;;;1475       case INV_FSR_2000DPS:
;;;1476           sens[0] = 16.4f;
000028  4808              LDR      r0,|L21.76|
00002a  6008              STR      r0,[r1,#0]
;;;1477           break;
00002c  e002              B        |L21.52|
                  |L21.46|
;;;1478       default:
;;;1479           return -1;
00002e  f04f30ff          MOV      r0,#0xffffffff
                  |L21.50|
;;;1480       }
;;;1481       return 0;
;;;1482   }
000032  4770              BX       lr
                  |L21.52|
000034  bf00              NOP                            ;1468
000036  2000              MOVS     r0,#0                 ;1481
000038  e7fb              B        |L21.50|
;;;1483   
                          ENDP

00003a  0000              DCW      0x0000
                  |L21.60|
                          DCD      ||st||
                  |L21.64|
                          DCD      0x43030000
                  |L21.68|
                          DCD      0x42830000
                  |L21.72|
                          DCD      0x42033333
                  |L21.76|
                          DCD      0x41833333

                          AREA ||i.mpu_get_int_status||, CODE, READONLY, ALIGN=2

                  mpu_get_int_status PROC
;;;1673    */
;;;1674   int mpu_get_int_status(short *status)
000000  b538              PUSH     {r3-r5,lr}
;;;1675   {
000002  4604              MOV      r4,r0
;;;1676       unsigned char tmp[2];
;;;1677       if (!st.chip_cfg.sensors)
000004  480e              LDR      r0,|L22.64|
000006  7a80              LDRB     r0,[r0,#0xa]
000008  b910              CBNZ     r0,|L22.16|
;;;1678           return -1;
00000a  f04f30ff          MOV      r0,#0xffffffff
                  |L22.14|
;;;1679       if (i2c_read(st.hw->addr, st.reg->dmp_int_status, 2, tmp))
;;;1680           return -1;
;;;1681       status[0] = (tmp[0] << 8) | tmp[1];
;;;1682       return 0;
;;;1683   }
00000e  bd38              POP      {r3-r5,pc}
                  |L22.16|
000010  4a0b              LDR      r2,|L22.64|
000012  6812              LDR      r2,[r2,#0]            ;1679  ; st
000014  7c11              LDRB     r1,[r2,#0x10]         ;1679
000016  4a0a              LDR      r2,|L22.64|
000018  6852              LDR      r2,[r2,#4]            ;1679  ; st
00001a  7810              LDRB     r0,[r2,#0]            ;1679
00001c  466b              MOV      r3,sp                 ;1679
00001e  2202              MOVS     r2,#2                 ;1679
000020  f7fffffe          BL       MPU_Read_Len
000024  b110              CBZ      r0,|L22.44|
000026  f04f30ff          MOV      r0,#0xffffffff        ;1680
00002a  e7f0              B        |L22.14|
                  |L22.44|
00002c  f89d0001          LDRB     r0,[sp,#1]            ;1681
000030  f89d1000          LDRB     r1,[sp,#0]            ;1681
000034  ea402001          ORR      r0,r0,r1,LSL #8       ;1681
000038  b200              SXTH     r0,r0                 ;1681
00003a  8020              STRH     r0,[r4,#0]            ;1681
00003c  2000              MOVS     r0,#0                 ;1682
00003e  e7e6              B        |L22.14|
;;;1684   
                          ENDP

                  |L22.64|
                          DCD      ||st||

                          AREA ||i.mpu_get_lpf||, CODE, READONLY, ALIGN=2

                  mpu_get_lpf PROC
;;;1287    */
;;;1288   int mpu_get_lpf(unsigned short *lpf)
000000  4601              MOV      r1,r0
;;;1289   {
;;;1290       switch (st.chip_cfg.lpf) {
000002  4812              LDR      r0,|L23.76|
000004  7ac0              LDRB     r0,[r0,#0xb]
000006  2808              CMP      r0,#8
000008  d217              BCS      |L23.58|
00000a  e8dff000          TBB      [pc,r0]
00000e  1704              DCB      0x17,0x04
000010  070a0d10          DCB      0x07,0x0a,0x0d,0x10
000014  1318              DCB      0x13,0x18
;;;1291       case INV_FILTER_188HZ:
;;;1292           lpf[0] = 188;
000016  20bc              MOVS     r0,#0xbc
000018  8008              STRH     r0,[r1,#0]
;;;1293           break;
00001a  e013              B        |L23.68|
;;;1294       case INV_FILTER_98HZ:
;;;1295           lpf[0] = 98;
00001c  2062              MOVS     r0,#0x62
00001e  8008              STRH     r0,[r1,#0]
;;;1296           break;
000020  e010              B        |L23.68|
;;;1297       case INV_FILTER_42HZ:
;;;1298           lpf[0] = 42;
000022  202a              MOVS     r0,#0x2a
000024  8008              STRH     r0,[r1,#0]
;;;1299           break;
000026  e00d              B        |L23.68|
;;;1300       case INV_FILTER_20HZ:
;;;1301           lpf[0] = 20;
000028  2014              MOVS     r0,#0x14
00002a  8008              STRH     r0,[r1,#0]
;;;1302           break;
00002c  e00a              B        |L23.68|
;;;1303       case INV_FILTER_10HZ:
;;;1304           lpf[0] = 10;
00002e  200a              MOVS     r0,#0xa
000030  8008              STRH     r0,[r1,#0]
;;;1305           break;
000032  e007              B        |L23.68|
;;;1306       case INV_FILTER_5HZ:
;;;1307           lpf[0] = 5;
000034  2005              MOVS     r0,#5
000036  8008              STRH     r0,[r1,#0]
;;;1308           break;
000038  e004              B        |L23.68|
                  |L23.58|
;;;1309       case INV_FILTER_256HZ_NOLPF2:
00003a  bf00              NOP      
;;;1310       case INV_FILTER_2100HZ_NOLPF:
00003c  bf00              NOP      
;;;1311       default:
;;;1312           lpf[0] = 0;
00003e  2000              MOVS     r0,#0
000040  8008              STRH     r0,[r1,#0]
;;;1313           break;
000042  bf00              NOP      
                  |L23.68|
000044  bf00              NOP                            ;1293
;;;1314       }
;;;1315       return 0;
000046  2000              MOVS     r0,#0
;;;1316   }
000048  4770              BX       lr
;;;1317   
                          ENDP

00004a  0000              DCW      0x0000
                  |L23.76|
                          DCD      ||st||

                          AREA ||i.mpu_get_power_state||, CODE, READONLY, ALIGN=2

                  mpu_get_power_state PROC
;;;1577    */
;;;1578   int mpu_get_power_state(unsigned char *power_on)
000000  4601              MOV      r1,r0
;;;1579   {
;;;1580       if (st.chip_cfg.sensors)
000002  4805              LDR      r0,|L24.24|
000004  7a80              LDRB     r0,[r0,#0xa]
000006  b110              CBZ      r0,|L24.14|
;;;1581           power_on[0] = 1;
000008  2001              MOVS     r0,#1
00000a  7008              STRB     r0,[r1,#0]
00000c  e001              B        |L24.18|
                  |L24.14|
;;;1582       else
;;;1583           power_on[0] = 0;
00000e  2000              MOVS     r0,#0
000010  7008              STRB     r0,[r1,#0]
                  |L24.18|
;;;1584       return 0;
000012  2000              MOVS     r0,#0
;;;1585   }
000014  4770              BX       lr
;;;1586   
                          ENDP

000016  0000              DCW      0x0000
                  |L24.24|
                          DCD      ||st||

                          AREA ||i.mpu_get_sample_rate||, CODE, READONLY, ALIGN=2

                  mpu_get_sample_rate PROC
;;;1356    */
;;;1357   int mpu_get_sample_rate(unsigned short *rate)
000000  4601              MOV      r1,r0
;;;1358   {
;;;1359       if (st.chip_cfg.dmp_on)
000002  4806              LDR      r0,|L25.28|
000004  f8900024          LDRB     r0,[r0,#0x24]
000008  b110              CBZ      r0,|L25.16|
;;;1360           return -1;
00000a  f04f30ff          MOV      r0,#0xffffffff
                  |L25.14|
;;;1361       else
;;;1362           rate[0] = st.chip_cfg.sample_rate;
;;;1363       return 0;
;;;1364   }
00000e  4770              BX       lr
                  |L25.16|
000010  4802              LDR      r0,|L25.28|
000012  89c0              LDRH     r0,[r0,#0xe]          ;1362
000014  8008              STRH     r0,[r1,#0]            ;1362
000016  2000              MOVS     r0,#0                 ;1363
000018  e7f9              B        |L25.14|
;;;1365   
                          ENDP

00001a  0000              DCW      0x0000
                  |L25.28|
                          DCD      ||st||

                          AREA ||i.mpu_get_temperature||, CODE, READONLY, ALIGN=2

                  mpu_get_temperature PROC
;;;1022    */
;;;1023   int mpu_get_temperature(long *data, unsigned long *timestamp)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;1024   {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;1025       unsigned char tmp[2];
;;;1026       short raw;
;;;1027   
;;;1028       if (!(st.chip_cfg.sensors))
000008  4823              LDR      r0,|L26.152|
00000a  7a80              LDRB     r0,[r0,#0xa]
00000c  b918              CBNZ     r0,|L26.22|
;;;1029           return -1;
00000e  f04f30ff          MOV      r0,#0xffffffff
                  |L26.18|
;;;1030   
;;;1031       if (i2c_read(st.hw->addr, st.reg->temp, 2, tmp))
;;;1032           return -1;
;;;1033       raw = (tmp[0] << 8) | tmp[1];
;;;1034       if (timestamp)
;;;1035           get_ms(timestamp);
;;;1036   
;;;1037       data[0] = (long)((35 + ((raw - (float)st.hw->temp_offset) / st.hw->temp_sens)) * 65536L);
;;;1038       return 0;
;;;1039   }
000012  e8bd8ffe          POP      {r1-r11,pc}
                  |L26.22|
000016  4a20              LDR      r2,|L26.152|
000018  6812              LDR      r2,[r2,#0]            ;1031  ; st
00001a  7b91              LDRB     r1,[r2,#0xe]          ;1031
00001c  4a1e              LDR      r2,|L26.152|
00001e  6852              LDR      r2,[r2,#4]            ;1031  ; st
000020  7810              LDRB     r0,[r2,#0]            ;1031
000022  ab02              ADD      r3,sp,#8              ;1031
000024  2202              MOVS     r2,#2                 ;1031
000026  f7fffffe          BL       MPU_Read_Len
00002a  b110              CBZ      r0,|L26.50|
00002c  f04f30ff          MOV      r0,#0xffffffff        ;1032
000030  e7ef              B        |L26.18|
                  |L26.50|
000032  f89d0009          LDRB     r0,[sp,#9]            ;1033
000036  f89d1008          LDRB     r1,[sp,#8]            ;1033
00003a  ea402001          ORR      r0,r0,r1,LSL #8       ;1033
00003e  b206              SXTH     r6,r0                 ;1033
000040  b114              CBZ      r4,|L26.72|
000042  4620              MOV      r0,r4                 ;1035
000044  f7fffffe          BL       mget_ms
                  |L26.72|
000048  4913              LDR      r1,|L26.152|
00004a  6849              LDR      r1,[r1,#4]            ;1037  ; st
00004c  88c8              LDRH     r0,[r1,#6]            ;1037
00004e  f7fffffe          BL       __aeabi_ui2f
000052  4911              LDR      r1,|L26.152|
000054  9001              STR      r0,[sp,#4]            ;1037
000056  6849              LDR      r1,[r1,#4]            ;1037  ; st
000058  f9b10008          LDRSH    r0,[r1,#8]            ;1037
00005c  f7fffffe          BL       __aeabi_i2f
000060  4683              MOV      r11,r0                ;1037
000062  4630              MOV      r0,r6                 ;1037
000064  f7fffffe          BL       __aeabi_i2f
000068  4659              MOV      r1,r11                ;1037
00006a  9000              STR      r0,[sp,#0]            ;1037
00006c  f7fffffe          BL       __aeabi_fsub
000070  4682              MOV      r10,r0                ;1037
000072  9901              LDR      r1,[sp,#4]            ;1037
000074  f7fffffe          BL       __aeabi_fdiv
000078  4681              MOV      r9,r0                 ;1037
00007a  4908              LDR      r1,|L26.156|
00007c  f7fffffe          BL       __aeabi_fadd
000080  4680              MOV      r8,r0                 ;1037
000082  f04f418f          MOV      r1,#0x47800000        ;1037
000086  f7fffffe          BL       __aeabi_fmul
00008a  4607              MOV      r7,r0                 ;1037
00008c  f7fffffe          BL       __aeabi_f2iz
000090  6028              STR      r0,[r5,#0]            ;1037
000092  2000              MOVS     r0,#0                 ;1038
000094  e7bd              B        |L26.18|
;;;1040   
                          ENDP

000096  0000              DCW      0x0000
                  |L26.152|
                          DCD      ||st||
                  |L26.156|
                          DCD      0x420c0000

                          AREA ||i.mpu_init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  mpu_init PROC
;;;761     */
;;;762    int mpu_init(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;763    {
;;;764        unsigned char data[6], rev;
;;;765    
;;;766        /* Reset device. */
;;;767        data[0] = BIT_RESET;
000002  2080              MOVS     r0,#0x80
000004  f88d0000          STRB     r0,[sp,#0]
;;;768        if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
000008  4a65              LDR      r2,|L27.416|
00000a  6812              LDR      r2,[r2,#0]  ; st
00000c  7c91              LDRB     r1,[r2,#0x12]
00000e  4a64              LDR      r2,|L27.416|
000010  6852              LDR      r2,[r2,#4]  ; st
000012  7810              LDRB     r0,[r2,#0]
000014  466b              MOV      r3,sp
000016  2201              MOVS     r2,#1
000018  f7fffffe          BL       MPU_Write_Len
00001c  b110              CBZ      r0,|L27.36|
;;;769            return -1;
00001e  f04f30ff          MOV      r0,#0xffffffff
                  |L27.34|
;;;770        delay_ms(100);
;;;771    
;;;772        /* Wake up chip. */
;;;773        data[0] = 0x00;
;;;774        if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
;;;775            return -1;
;;;776    
;;;777    #if defined MPU6050
;;;778        /* Check product revision. */
;;;779        if (i2c_read(st.hw->addr, st.reg->accel_offs, 6, data))
;;;780            return -1;
;;;781        rev = ((data[5] & 0x01) << 2) | ((data[3] & 0x01) << 1) |
;;;782            (data[1] & 0x01);
;;;783    
;;;784        if (rev) {
;;;785            /* Congrats, these parts are better. */
;;;786            if (rev == 1)
;;;787                st.chip_cfg.accel_half = 1;
;;;788            else if (rev == 2)
;;;789                st.chip_cfg.accel_half = 0;
;;;790            else {
;;;791                log_e("Unsupported software product rev %d.\n", rev);
;;;792                return -1;
;;;793            }
;;;794        } else {
;;;795            if (i2c_read(st.hw->addr, st.reg->prod_id, 1, data))
;;;796                return -1;
;;;797            rev = data[0] & 0x0F;
;;;798            if (!rev) {
;;;799                log_e("Product ID read as 0 indicates device is either "
;;;800                    "incompatible or an MPU3050.\n");
;;;801                return -1;
;;;802            } else if (rev == 4) {
;;;803                log_i("Half sensitivity part found.\n");
;;;804                st.chip_cfg.accel_half = 1;
;;;805            } else
;;;806                st.chip_cfg.accel_half = 0;
;;;807        }
;;;808    #elif defined MPU6500
;;;809    #define MPU6500_MEM_REV_ADDR    (0x17)
;;;810        if (mpu_read_mem(MPU6500_MEM_REV_ADDR, 1, &rev))
;;;811            return -1;
;;;812        if (rev == 0x1)
;;;813            st.chip_cfg.accel_half = 0;
;;;814        else {
;;;815            log_e("Unsupported software product rev %d.\n", rev);
;;;816            return -1;
;;;817        }
;;;818    
;;;819        /* MPU6500 shares 4kB of memory between the DMP and the FIFO. Since the
;;;820         * first 3kB are needed by the DMP, we'll use the last 1kB for the FIFO.
;;;821         */
;;;822        data[0] = BIT_FIFO_SIZE_1024 | 0x8;
;;;823        if (i2c_write(st.hw->addr, st.reg->accel_cfg2, 1, data))
;;;824            return -1;
;;;825    #endif
;;;826    
;;;827        /* Set to invalid values to ensure no I2C writes are skipped. */
;;;828        st.chip_cfg.sensors = 0xFF;
;;;829        st.chip_cfg.gyro_fsr = 0xFF;
;;;830        st.chip_cfg.accel_fsr = 0xFF;
;;;831        st.chip_cfg.lpf = 0xFF;
;;;832        st.chip_cfg.sample_rate = 0xFFFF;
;;;833        st.chip_cfg.fifo_enable = 0xFF;
;;;834        st.chip_cfg.bypass_mode = 0xFF;
;;;835    #ifdef AK89xx_SECONDARY
;;;836        st.chip_cfg.compass_sample_rate = 0xFFFF;
;;;837    #endif
;;;838        /* mpu_set_sensors always preserves this setting. */
;;;839        st.chip_cfg.clk_src = INV_CLK_PLL;
;;;840        /* Handled in next call to mpu_set_bypass. */
;;;841        st.chip_cfg.active_low_int = 1;
;;;842        st.chip_cfg.latched_int = 0;
;;;843        st.chip_cfg.int_motion_only = 0;
;;;844        st.chip_cfg.lp_accel_mode = 0;
;;;845        memset(&st.chip_cfg.cache, 0, sizeof(st.chip_cfg.cache));
;;;846        st.chip_cfg.dmp_on = 0;
;;;847        st.chip_cfg.dmp_loaded = 0;
;;;848        st.chip_cfg.dmp_sample_rate = 0;
;;;849    
;;;850        if (mpu_set_gyro_fsr(2000))
;;;851            return -1;
;;;852        if (mpu_set_accel_fsr(2))
;;;853            return -1;
;;;854        if (mpu_set_lpf(42))
;;;855            return -1;
;;;856        if (mpu_set_sample_rate(50))
;;;857            return -1;
;;;858        if (mpu_configure_fifo(0))
;;;859            return -1;
;;;860    
;;;861    //    if (int_param)
;;;862    //        reg_int_cb(int_param);
;;;863    
;;;864    #ifdef AK89xx_SECONDARY
;;;865        setup_compass();
;;;866        if (mpu_set_compass_sample_rate(10))
;;;867            return -1;
;;;868    #else
;;;869        /* Already disabled by setup_compass. */
;;;870        if (mpu_set_bypass(0))
;;;871            return -1;
;;;872    #endif
;;;873    
;;;874        mpu_set_sensors(0);
;;;875        return 0;
;;;876    }
000022  bd1c              POP      {r2-r4,pc}
                  |L27.36|
000024  2064              MOVS     r0,#0x64              ;770
000026  f7fffffe          BL       delay_ms
00002a  2000              MOVS     r0,#0                 ;773
00002c  f88d0000          STRB     r0,[sp,#0]            ;773
000030  4a5b              LDR      r2,|L27.416|
000032  6812              LDR      r2,[r2,#0]            ;774  ; st
000034  7c91              LDRB     r1,[r2,#0x12]         ;774
000036  4a5a              LDR      r2,|L27.416|
000038  6852              LDR      r2,[r2,#4]            ;774  ; st
00003a  7810              LDRB     r0,[r2,#0]            ;774
00003c  466b              MOV      r3,sp                 ;774
00003e  2201              MOVS     r2,#1                 ;774
000040  f7fffffe          BL       MPU_Write_Len
000044  b110              CBZ      r0,|L27.76|
000046  f04f30ff          MOV      r0,#0xffffffff        ;775
00004a  e7ea              B        |L27.34|
                  |L27.76|
00004c  4a54              LDR      r2,|L27.416|
00004e  6812              LDR      r2,[r2,#0]            ;779  ; st
000050  7d91              LDRB     r1,[r2,#0x16]         ;779
000052  4a53              LDR      r2,|L27.416|
000054  6852              LDR      r2,[r2,#4]            ;779  ; st
000056  7810              LDRB     r0,[r2,#0]            ;779
000058  466b              MOV      r3,sp                 ;779
00005a  2206              MOVS     r2,#6                 ;779
00005c  f7fffffe          BL       MPU_Read_Len
000060  b110              CBZ      r0,|L27.104|
000062  f04f30ff          MOV      r0,#0xffffffff        ;780
000066  e7dc              B        |L27.34|
                  |L27.104|
000068  f89d0005          LDRB     r0,[sp,#5]            ;781
00006c  07c0              LSLS     r0,r0,#31             ;781
00006e  0f40              LSRS     r0,r0,#29             ;781
000070  f89d1003          LDRB     r1,[sp,#3]            ;781
000074  f0010101          AND      r1,r1,#1              ;781
000078  ea400041          ORR      r0,r0,r1,LSL #1       ;781
00007c  f89d1001          LDRB     r1,[sp,#1]            ;781
000080  f0010101          AND      r1,r1,#1              ;781
000084  ea400401          ORR      r4,r0,r1              ;781
000088  b194              CBZ      r4,|L27.176|
00008a  2c01              CMP      r4,#1                 ;786
00008c  d103              BNE      |L27.150|
00008e  2101              MOVS     r1,#1                 ;787
000090  4843              LDR      r0,|L27.416|
000092  74c1              STRB     r1,[r0,#0x13]         ;787
000094  e031              B        |L27.250|
                  |L27.150|
000096  2c02              CMP      r4,#2                 ;788
000098  d103              BNE      |L27.162|
00009a  2100              MOVS     r1,#0                 ;789
00009c  4840              LDR      r0,|L27.416|
00009e  74c1              STRB     r1,[r0,#0x13]         ;789
0000a0  e02b              B        |L27.250|
                  |L27.162|
0000a2  4621              MOV      r1,r4                 ;791
0000a4  a03f              ADR      r0,|L27.420|
0000a6  f7fffffe          BL       __2printf
0000aa  f04f30ff          MOV      r0,#0xffffffff        ;792
0000ae  e7b8              B        |L27.34|
                  |L27.176|
0000b0  4a3b              LDR      r2,|L27.416|
0000b2  6812              LDR      r2,[r2,#0]            ;795  ; st
0000b4  78d1              LDRB     r1,[r2,#3]            ;795
0000b6  4a3a              LDR      r2,|L27.416|
0000b8  6852              LDR      r2,[r2,#4]            ;795  ; st
0000ba  7810              LDRB     r0,[r2,#0]            ;795
0000bc  466b              MOV      r3,sp                 ;795
0000be  2201              MOVS     r2,#1                 ;795
0000c0  f7fffffe          BL       MPU_Read_Len
0000c4  b110              CBZ      r0,|L27.204|
0000c6  f04f30ff          MOV      r0,#0xffffffff        ;796
0000ca  e7aa              B        |L27.34|
                  |L27.204|
0000cc  f89d0000          LDRB     r0,[sp,#0]            ;797
0000d0  f000040f          AND      r4,r0,#0xf            ;797
0000d4  b92c              CBNZ     r4,|L27.226|
0000d6  483d              LDR      r0,|L27.460|
0000d8  f7fffffe          BL       __2printf
0000dc  f04f30ff          MOV      r0,#0xffffffff        ;801
0000e0  e79f              B        |L27.34|
                  |L27.226|
0000e2  2c04              CMP      r4,#4                 ;802
0000e4  d106              BNE      |L27.244|
0000e6  a03a              ADR      r0,|L27.464|
0000e8  f7fffffe          BL       __2printf
0000ec  2101              MOVS     r1,#1                 ;804
0000ee  482c              LDR      r0,|L27.416|
0000f0  74c1              STRB     r1,[r0,#0x13]         ;804
0000f2  e002              B        |L27.250|
                  |L27.244|
0000f4  2100              MOVS     r1,#0                 ;806
0000f6  482a              LDR      r0,|L27.416|
0000f8  74c1              STRB     r1,[r0,#0x13]         ;806
                  |L27.250|
0000fa  21ff              MOVS     r1,#0xff              ;828
0000fc  4828              LDR      r0,|L27.416|
0000fe  7281              STRB     r1,[r0,#0xa]          ;828
000100  20ff              MOVS     r0,#0xff              ;829
000102  4927              LDR      r1,|L27.416|
000104  7208              STRB     r0,[r1,#8]            ;829
000106  21ff              MOVS     r1,#0xff              ;830
000108  4825              LDR      r0,|L27.416|
00010a  7241              STRB     r1,[r0,#9]            ;830
00010c  72c1              STRB     r1,[r0,#0xb]          ;831
00010e  f64f71ff          MOV      r1,#0xffff            ;832
000112  81c1              STRH     r1,[r0,#0xe]          ;832
000114  21ff              MOVS     r1,#0xff              ;833
000116  7401              STRB     r1,[r0,#0x10]         ;833
000118  7481              STRB     r1,[r0,#0x12]         ;834
00011a  2101              MOVS     r1,#1                 ;839
00011c  7301              STRB     r1,[r0,#0xc]          ;839
00011e  f8801022          STRB     r1,[r0,#0x22]         ;841
000122  2100              MOVS     r1,#0                 ;842
000124  f8801023          STRB     r1,[r0,#0x23]         ;842
000128  7541              STRB     r1,[r0,#0x15]         ;843
00012a  7501              STRB     r1,[r0,#0x14]         ;844
00012c  3016              ADDS     r0,r0,#0x16           ;845
00012e  6001              STR      r1,[r0,#0]            ;845
000130  6041              STR      r1,[r0,#4]            ;845
000132  6081              STR      r1,[r0,#8]            ;845
000134  3816              SUBS     r0,r0,#0x16           ;846
000136  f8801024          STRB     r1,[r0,#0x24]         ;846
00013a  f8801025          STRB     r1,[r0,#0x25]         ;847
00013e  84c1              STRH     r1,[r0,#0x26]         ;848
000140  f44f60fa          MOV      r0,#0x7d0             ;850
000144  f7fffffe          BL       mpu_set_gyro_fsr
000148  b110              CBZ      r0,|L27.336|
00014a  f04f30ff          MOV      r0,#0xffffffff        ;851
00014e  e768              B        |L27.34|
                  |L27.336|
000150  2002              MOVS     r0,#2                 ;852
000152  f7fffffe          BL       mpu_set_accel_fsr
000156  b110              CBZ      r0,|L27.350|
000158  f04f30ff          MOV      r0,#0xffffffff        ;853
00015c  e761              B        |L27.34|
                  |L27.350|
00015e  202a              MOVS     r0,#0x2a              ;854
000160  f7fffffe          BL       mpu_set_lpf
000164  b110              CBZ      r0,|L27.364|
000166  f04f30ff          MOV      r0,#0xffffffff        ;855
00016a  e75a              B        |L27.34|
                  |L27.364|
00016c  2032              MOVS     r0,#0x32              ;856
00016e  f7fffffe          BL       mpu_set_sample_rate
000172  b110              CBZ      r0,|L27.378|
000174  f04f30ff          MOV      r0,#0xffffffff        ;857
000178  e753              B        |L27.34|
                  |L27.378|
00017a  2000              MOVS     r0,#0                 ;858
00017c  f7fffffe          BL       mpu_configure_fifo
000180  b110              CBZ      r0,|L27.392|
000182  f04f30ff          MOV      r0,#0xffffffff        ;859
000186  e74c              B        |L27.34|
                  |L27.392|
000188  2000              MOVS     r0,#0                 ;870
00018a  f7fffffe          BL       mpu_set_bypass
00018e  b110              CBZ      r0,|L27.406|
000190  f04f30ff          MOV      r0,#0xffffffff        ;871
000194  e745              B        |L27.34|
                  |L27.406|
000196  2000              MOVS     r0,#0                 ;874
000198  f7fffffe          BL       mpu_set_sensors
00019c  2000              MOVS     r0,#0                 ;875
00019e  e740              B        |L27.34|
;;;877    
                          ENDP

                  |L27.416|
                          DCD      ||st||
                  |L27.420|
0001a4  556e7375          DCB      "Unsupported software product rev %d.\n",0
0001a8  70706f72
0001ac  74656420
0001b0  736f6674
0001b4  77617265
0001b8  2070726f
0001bc  64756374
0001c0  20726576
0001c4  2025642e
0001c8  0a00    
0001ca  00                DCB      0
0001cb  00                DCB      0
                  |L27.460|
                          DCD      ||.conststring||
                  |L27.464|
0001d0  48616c66          DCB      "Half sensitivity part found.\n",0
0001d4  2073656e
0001d8  73697469
0001dc  76697479
0001e0  20706172
0001e4  7420666f
0001e8  756e642e
0001ec  0a00    
0001ee  00                DCB      0
0001ef  00                DCB      0

                          AREA ||i.mpu_load_firmware||, CODE, READONLY, ALIGN=2

                  mpu_load_firmware PROC
;;;2340    */
;;;2341   int mpu_load_firmware(unsigned short length, const unsigned char *firmware,
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;2342       unsigned short start_addr, unsigned short sample_rate)
;;;2343   {
000004  b085              SUB      sp,sp,#0x14
000006  4605              MOV      r5,r0
000008  460e              MOV      r6,r1
00000a  4690              MOV      r8,r2
00000c  4699              MOV      r9,r3
;;;2344       unsigned short ii;
;;;2345       unsigned short this_write;
;;;2346       /* Must divide evenly into st.hw->bank_size to avoid bank crossings. */
;;;2347   #define LOAD_CHUNK  (16)
;;;2348       unsigned char cur[LOAD_CHUNK], tmp[2];
;;;2349   
;;;2350       if (st.chip_cfg.dmp_loaded)
00000e  4829              LDR      r0,|L28.180|
000010  f8900025          LDRB     r0,[r0,#0x25]
000014  b120              CBZ      r0,|L28.32|
;;;2351           /* DMP should only be loaded once. */
;;;2352           return -1;
000016  f04f30ff          MOV      r0,#0xffffffff
                  |L28.26|
;;;2353   
;;;2354       if (!firmware)
;;;2355           return -1;
;;;2356       for (ii = 0; ii < length; ii += this_write) {
;;;2357           this_write = min(LOAD_CHUNK, length - ii);
;;;2358           if (mpu_write_mem(ii, this_write, (unsigned char*)&firmware[ii]))
;;;2359               return -1;
;;;2360           if (mpu_read_mem(ii, this_write, cur))
;;;2361               return -1;
;;;2362           if (memcmp(firmware+ii, cur, this_write))
;;;2363               return -2;
;;;2364       }
;;;2365   
;;;2366       /* Set program start address. */
;;;2367       tmp[0] = start_addr >> 8;
;;;2368       tmp[1] = start_addr & 0xFF;
;;;2369       if (i2c_write(st.hw->addr, st.reg->prgm_start_h, 2, tmp))
;;;2370           return -1;
;;;2371   
;;;2372       st.chip_cfg.dmp_loaded = 1;
;;;2373       st.chip_cfg.dmp_sample_rate = sample_rate;
;;;2374       return 0;
;;;2375   }
00001a  b005              ADD      sp,sp,#0x14
00001c  e8bd83f0          POP      {r4-r9,pc}
                  |L28.32|
000020  b916              CBNZ     r6,|L28.40|
000022  f04f30ff          MOV      r0,#0xffffffff        ;2355
000026  e7f8              B        |L28.26|
                  |L28.40|
000028  2400              MOVS     r4,#0                 ;2356
00002a  e023              B        |L28.116|
                  |L28.44|
00002c  1b28              SUBS     r0,r5,r4              ;2357
00002e  2810              CMP      r0,#0x10              ;2357
000030  dd01              BLE      |L28.54|
000032  2010              MOVS     r0,#0x10              ;2357
000034  e000              B        |L28.56|
                  |L28.54|
000036  1b28              SUBS     r0,r5,r4              ;2357
                  |L28.56|
000038  b287              UXTH     r7,r0                 ;2357
00003a  1932              ADDS     r2,r6,r4              ;2358
00003c  4639              MOV      r1,r7                 ;2358
00003e  4620              MOV      r0,r4                 ;2358
000040  f7fffffe          BL       mpu_write_mem
000044  b110              CBZ      r0,|L28.76|
000046  f04f30ff          MOV      r0,#0xffffffff        ;2359
00004a  e7e6              B        |L28.26|
                  |L28.76|
00004c  aa01              ADD      r2,sp,#4              ;2360
00004e  4639              MOV      r1,r7                 ;2360
000050  4620              MOV      r0,r4                 ;2360
000052  f7fffffe          BL       mpu_read_mem
000056  b110              CBZ      r0,|L28.94|
000058  f04f30ff          MOV      r0,#0xffffffff        ;2361
00005c  e7dd              B        |L28.26|
                  |L28.94|
00005e  1930              ADDS     r0,r6,r4              ;2362
000060  463a              MOV      r2,r7                 ;2362
000062  a901              ADD      r1,sp,#4              ;2362
000064  f7fffffe          BL       memcmp
000068  b110              CBZ      r0,|L28.112|
00006a  f06f0001          MVN      r0,#1                 ;2363
00006e  e7d4              B        |L28.26|
                  |L28.112|
000070  19e0              ADDS     r0,r4,r7              ;2356
000072  b284              UXTH     r4,r0                 ;2356
                  |L28.116|
000074  42ac              CMP      r4,r5                 ;2356
000076  dbd9              BLT      |L28.44|
000078  ea4f2028          ASR      r0,r8,#8              ;2367
00007c  f88d0000          STRB     r0,[sp,#0]            ;2367
000080  f00800ff          AND      r0,r8,#0xff           ;2368
000084  f88d0001          STRB     r0,[sp,#1]            ;2368
000088  4a0a              LDR      r2,|L28.180|
00008a  6812              LDR      r2,[r2,#0]            ;2369  ; st
00008c  7e91              LDRB     r1,[r2,#0x1a]         ;2369
00008e  4a09              LDR      r2,|L28.180|
000090  6852              LDR      r2,[r2,#4]            ;2369  ; st
000092  7810              LDRB     r0,[r2,#0]            ;2369
000094  466b              MOV      r3,sp                 ;2369
000096  2202              MOVS     r2,#2                 ;2369
000098  f7fffffe          BL       MPU_Write_Len
00009c  b110              CBZ      r0,|L28.164|
00009e  f04f30ff          MOV      r0,#0xffffffff        ;2370
0000a2  e7ba              B        |L28.26|
                  |L28.164|
0000a4  2101              MOVS     r1,#1                 ;2372
0000a6  4803              LDR      r0,|L28.180|
0000a8  f8801025          STRB     r1,[r0,#0x25]         ;2372
0000ac  f8a09026          STRH     r9,[r0,#0x26]         ;2373
0000b0  2000              MOVS     r0,#0                 ;2374
0000b2  e7b2              B        |L28.26|
;;;2376   
                          ENDP

                  |L28.180|
                          DCD      ||st||

                          AREA ||i.mpu_lp_accel_mode||, CODE, READONLY, ALIGN=2

                  mpu_lp_accel_mode PROC
;;;892     */
;;;893    int mpu_lp_accel_mode(unsigned char rate)
000000  b538              PUSH     {r3-r5,lr}
;;;894    {
000002  4604              MOV      r4,r0
;;;895        unsigned char tmp[2];
;;;896    
;;;897        if (rate > 40)
000004  2c28              CMP      r4,#0x28
000006  dd02              BLE      |L29.14|
;;;898            return -1;
000008  f04f30ff          MOV      r0,#0xffffffff
                  |L29.12|
;;;899    
;;;900        if (!rate) {
;;;901            mpu_set_int_latched(0);
;;;902            tmp[0] = 0;
;;;903            tmp[1] = BIT_STBY_XYZG;
;;;904            if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
;;;905                return -1;
;;;906            st.chip_cfg.lp_accel_mode = 0;
;;;907            return 0;
;;;908        }
;;;909        /* For LP accel, we automatically configure the hardware to produce latched
;;;910         * interrupts. In LP accel mode, the hardware cycles into sleep mode before
;;;911         * it gets a chance to deassert the interrupt pin; therefore, we shift this
;;;912         * responsibility over to the MCU.
;;;913         *
;;;914         * Any register read will clear the interrupt.
;;;915         */
;;;916        mpu_set_int_latched(1);
;;;917    #if defined MPU6050
;;;918        tmp[0] = BIT_LPA_CYCLE;
;;;919        if (rate == 1) {
;;;920            tmp[1] = INV_LPA_1_25HZ;
;;;921            mpu_set_lpf(5);
;;;922        } else if (rate <= 5) {
;;;923            tmp[1] = INV_LPA_5HZ;
;;;924            mpu_set_lpf(5);
;;;925        } else if (rate <= 20) {
;;;926            tmp[1] = INV_LPA_20HZ;
;;;927            mpu_set_lpf(10);
;;;928        } else {
;;;929            tmp[1] = INV_LPA_40HZ;
;;;930            mpu_set_lpf(20);
;;;931        }
;;;932        tmp[1] = (tmp[1] << 6) | BIT_STBY_XYZG;
;;;933        if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
;;;934            return -1;
;;;935    #elif defined MPU6500
;;;936        /* Set wake frequency. */
;;;937        if (rate == 1)
;;;938            tmp[0] = INV_LPA_1_25HZ;
;;;939        else if (rate == 2)
;;;940            tmp[0] = INV_LPA_2_5HZ;
;;;941        else if (rate <= 5)
;;;942            tmp[0] = INV_LPA_5HZ;
;;;943        else if (rate <= 10)
;;;944            tmp[0] = INV_LPA_10HZ;
;;;945        else if (rate <= 20)
;;;946            tmp[0] = INV_LPA_20HZ;
;;;947        else if (rate <= 40)
;;;948            tmp[0] = INV_LPA_40HZ;
;;;949        else if (rate <= 80)
;;;950            tmp[0] = INV_LPA_80HZ;
;;;951        else if (rate <= 160)
;;;952            tmp[0] = INV_LPA_160HZ;
;;;953        else if (rate <= 320)
;;;954            tmp[0] = INV_LPA_320HZ;
;;;955        else
;;;956            tmp[0] = INV_LPA_640HZ;
;;;957        if (i2c_write(st.hw->addr, st.reg->lp_accel_odr, 1, tmp))
;;;958            return -1;
;;;959        tmp[0] = BIT_LPA_CYCLE;
;;;960        if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, tmp))
;;;961            return -1;
;;;962    #endif
;;;963        st.chip_cfg.sensors = INV_XYZ_ACCEL;
;;;964        st.chip_cfg.clk_src = 0;
;;;965        st.chip_cfg.lp_accel_mode = 1;
;;;966        mpu_configure_fifo(0);
;;;967    
;;;968        return 0;
;;;969    }
00000c  bd38              POP      {r3-r5,pc}
                  |L29.14|
00000e  b9dc              CBNZ     r4,|L29.72|
000010  2000              MOVS     r0,#0                 ;901
000012  f7fffffe          BL       mpu_set_int_latched
000016  2000              MOVS     r0,#0                 ;902
000018  f88d0000          STRB     r0,[sp,#0]            ;902
00001c  2007              MOVS     r0,#7                 ;903
00001e  f88d0001          STRB     r0,[sp,#1]            ;903
000022  4a2e              LDR      r2,|L29.220|
000024  6812              LDR      r2,[r2,#0]            ;904  ; st
000026  7c91              LDRB     r1,[r2,#0x12]         ;904
000028  4a2c              LDR      r2,|L29.220|
00002a  6852              LDR      r2,[r2,#4]            ;904  ; st
00002c  7810              LDRB     r0,[r2,#0]            ;904
00002e  466b              MOV      r3,sp                 ;904
000030  2202              MOVS     r2,#2                 ;904
000032  f7fffffe          BL       MPU_Write_Len
000036  b110              CBZ      r0,|L29.62|
000038  f04f30ff          MOV      r0,#0xffffffff        ;905
00003c  e7e6              B        |L29.12|
                  |L29.62|
00003e  2100              MOVS     r1,#0                 ;906
000040  4826              LDR      r0,|L29.220|
000042  7501              STRB     r1,[r0,#0x14]         ;906
000044  2000              MOVS     r0,#0                 ;907
000046  e7e1              B        |L29.12|
                  |L29.72|
000048  2001              MOVS     r0,#1                 ;916
00004a  f7fffffe          BL       mpu_set_int_latched
00004e  2020              MOVS     r0,#0x20              ;918
000050  f88d0000          STRB     r0,[sp,#0]            ;918
000054  2c01              CMP      r4,#1                 ;919
000056  d106              BNE      |L29.102|
000058  2000              MOVS     r0,#0                 ;920
00005a  f88d0001          STRB     r0,[sp,#1]            ;920
00005e  2005              MOVS     r0,#5                 ;921
000060  f7fffffe          BL       mpu_set_lpf
000064  e017              B        |L29.150|
                  |L29.102|
000066  2c05              CMP      r4,#5                 ;922
000068  dc06              BGT      |L29.120|
00006a  2001              MOVS     r0,#1                 ;923
00006c  f88d0001          STRB     r0,[sp,#1]            ;923
000070  2005              MOVS     r0,#5                 ;924
000072  f7fffffe          BL       mpu_set_lpf
000076  e00e              B        |L29.150|
                  |L29.120|
000078  2c14              CMP      r4,#0x14              ;925
00007a  dc06              BGT      |L29.138|
00007c  2002              MOVS     r0,#2                 ;926
00007e  f88d0001          STRB     r0,[sp,#1]            ;926
000082  200a              MOVS     r0,#0xa               ;927
000084  f7fffffe          BL       mpu_set_lpf
000088  e005              B        |L29.150|
                  |L29.138|
00008a  2003              MOVS     r0,#3                 ;929
00008c  f88d0001          STRB     r0,[sp,#1]            ;929
000090  2014              MOVS     r0,#0x14              ;930
000092  f7fffffe          BL       mpu_set_lpf
                  |L29.150|
000096  f89d0001          LDRB     r0,[sp,#1]            ;932
00009a  2107              MOVS     r1,#7                 ;932
00009c  eb011080          ADD      r0,r1,r0,LSL #6       ;932
0000a0  b2c0              UXTB     r0,r0                 ;932
0000a2  f88d0001          STRB     r0,[sp,#1]            ;932
0000a6  4a0d              LDR      r2,|L29.220|
0000a8  6812              LDR      r2,[r2,#0]            ;933  ; st
0000aa  7c91              LDRB     r1,[r2,#0x12]         ;933
0000ac  4a0b              LDR      r2,|L29.220|
0000ae  6852              LDR      r2,[r2,#4]            ;933  ; st
0000b0  7810              LDRB     r0,[r2,#0]            ;933
0000b2  466b              MOV      r3,sp                 ;933
0000b4  2202              MOVS     r2,#2                 ;933
0000b6  f7fffffe          BL       MPU_Write_Len
0000ba  b110              CBZ      r0,|L29.194|
0000bc  f04f30ff          MOV      r0,#0xffffffff        ;934
0000c0  e7a4              B        |L29.12|
                  |L29.194|
0000c2  2108              MOVS     r1,#8                 ;963
0000c4  4805              LDR      r0,|L29.220|
0000c6  7281              STRB     r1,[r0,#0xa]          ;963
0000c8  2100              MOVS     r1,#0                 ;964
0000ca  7301              STRB     r1,[r0,#0xc]          ;964
0000cc  2101              MOVS     r1,#1                 ;965
0000ce  7501              STRB     r1,[r0,#0x14]         ;965
0000d0  2000              MOVS     r0,#0                 ;966
0000d2  f7fffffe          BL       mpu_configure_fifo
0000d6  2000              MOVS     r0,#0                 ;968
0000d8  e798              B        |L29.12|
;;;970    
                          ENDP

0000da  0000              DCW      0x0000
                  |L29.220|
                          DCD      ||st||

                          AREA ||i.mpu_lp_motion_interrupt||, CODE, READONLY, ALIGN=2

                  mpu_lp_motion_interrupt PROC
;;;2646    */
;;;2647   int mpu_lp_motion_interrupt(unsigned short thresh, unsigned char time,
000000  b5f8              PUSH     {r3-r7,lr}
;;;2648       unsigned char lpa_freq)
;;;2649   {
000002  4605              MOV      r5,r0
000004  460f              MOV      r7,r1
000006  4614              MOV      r4,r2
;;;2650       unsigned char data[3];
;;;2651   
;;;2652       if (lpa_freq) {
000008  2c00              CMP      r4,#0
00000a  d070              BEQ      |L30.238|
;;;2653           unsigned char thresh_hw;
;;;2654   
;;;2655   #if defined MPU6050
;;;2656           /* TODO: Make these const/#defines. */
;;;2657           /* 1LSb = 32mg. */
;;;2658           if (thresh > 8160)
00000c  f5b55fff          CMP      r5,#0x1fe0
000010  dd01              BLE      |L30.22|
;;;2659               thresh_hw = 255;
000012  26ff              MOVS     r6,#0xff
000014  e005              B        |L30.34|
                  |L30.22|
;;;2660           else if (thresh < 32)
000016  2d20              CMP      r5,#0x20
000018  da01              BGE      |L30.30|
;;;2661               thresh_hw = 1;
00001a  2601              MOVS     r6,#1
00001c  e001              B        |L30.34|
                  |L30.30|
;;;2662           else
;;;2663               thresh_hw = thresh >> 5;
00001e  f3c51647          UBFX     r6,r5,#5,#8
                  |L30.34|
;;;2664   #elif defined MPU6500
;;;2665           /* 1LSb = 4mg. */
;;;2666           if (thresh > 1020)
;;;2667               thresh_hw = 255;
;;;2668           else if (thresh < 4)
;;;2669               thresh_hw = 1;
;;;2670           else
;;;2671               thresh_hw = thresh >> 2;
;;;2672   #endif
;;;2673   
;;;2674           if (!time)
000022  b907              CBNZ     r7,|L30.38|
;;;2675               /* Minimum duration must be 1ms. */
;;;2676               time = 1;
000024  2701              MOVS     r7,#1
                  |L30.38|
;;;2677   
;;;2678   #if defined MPU6050
;;;2679           if (lpa_freq > 40)
000026  2c28              CMP      r4,#0x28
000028  dd02              BLE      |L30.48|
;;;2680   #elif defined MPU6500
;;;2681           if (lpa_freq > 640)
;;;2682   #endif
;;;2683               /* At this point, the chip has not been re-configured, so the
;;;2684                * function can safely exit.
;;;2685                */
;;;2686               return -1;
00002a  f04f30ff          MOV      r0,#0xffffffff
                  |L30.46|
;;;2687   
;;;2688           if (!st.chip_cfg.int_motion_only) {
;;;2689               /* Store current settings for later. */
;;;2690               if (st.chip_cfg.dmp_on) {
;;;2691                   mpu_set_dmp_state(0);
;;;2692                   st.chip_cfg.cache.dmp_on = 1;
;;;2693               } else
;;;2694                   st.chip_cfg.cache.dmp_on = 0;
;;;2695               mpu_get_gyro_fsr(&st.chip_cfg.cache.gyro_fsr);
;;;2696               mpu_get_accel_fsr(&st.chip_cfg.cache.accel_fsr);
;;;2697               mpu_get_lpf(&st.chip_cfg.cache.lpf);
;;;2698               mpu_get_sample_rate(&st.chip_cfg.cache.sample_rate);
;;;2699               st.chip_cfg.cache.sensors_on = st.chip_cfg.sensors;
;;;2700               mpu_get_fifo_config(&st.chip_cfg.cache.fifo_sensors);
;;;2701           }
;;;2702   
;;;2703   #ifdef MPU6050
;;;2704           /* Disable hardware interrupts for now. */
;;;2705           set_int_enable(0);
;;;2706   
;;;2707           /* Enter full-power accel-only mode. */
;;;2708           mpu_lp_accel_mode(0);
;;;2709   
;;;2710           /* Override current LPF (and HPF) settings to obtain a valid accel
;;;2711            * reading.
;;;2712            */
;;;2713           data[0] = INV_FILTER_256HZ_NOLPF2;
;;;2714           if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
;;;2715               return -1;
;;;2716   
;;;2717           /* NOTE: Digital high pass filter should be configured here. Since this
;;;2718            * driver doesn't modify those bits anywhere, they should already be
;;;2719            * cleared by default.
;;;2720            */
;;;2721   
;;;2722           /* Configure the device to send motion interrupts. */
;;;2723           /* Enable motion interrupt. */
;;;2724           data[0] = BIT_MOT_INT_EN;
;;;2725           if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
;;;2726               goto lp_int_restore;
;;;2727   
;;;2728           /* Set motion interrupt parameters. */
;;;2729           data[0] = thresh_hw;
;;;2730           data[1] = time;
;;;2731           if (i2c_write(st.hw->addr, st.reg->motion_thr, 2, data))
;;;2732               goto lp_int_restore;
;;;2733   
;;;2734           /* Force hardware to "lock" current accel sample. */
;;;2735           delay_ms(5);
;;;2736           data[0] = (st.chip_cfg.accel_fsr << 3) | BITS_HPF;
;;;2737           if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
;;;2738               goto lp_int_restore;
;;;2739   
;;;2740           /* Set up LP accel mode. */
;;;2741           data[0] = BIT_LPA_CYCLE;
;;;2742           if (lpa_freq == 1)
;;;2743               data[1] = INV_LPA_1_25HZ;
;;;2744           else if (lpa_freq <= 5)
;;;2745               data[1] = INV_LPA_5HZ;
;;;2746           else if (lpa_freq <= 20)
;;;2747               data[1] = INV_LPA_20HZ;
;;;2748           else
;;;2749               data[1] = INV_LPA_40HZ;
;;;2750           data[1] = (data[1] << 6) | BIT_STBY_XYZG;
;;;2751           if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
;;;2752               goto lp_int_restore;
;;;2753   
;;;2754           st.chip_cfg.int_motion_only = 1;
;;;2755           return 0;
;;;2756   #elif defined MPU6500
;;;2757           /* Disable hardware interrupts. */
;;;2758           set_int_enable(0);
;;;2759   
;;;2760           /* Enter full-power accel-only mode, no FIFO/DMP. */
;;;2761           data[0] = 0;
;;;2762           data[1] = 0;
;;;2763           data[2] = BIT_STBY_XYZG;
;;;2764           if (i2c_write(st.hw->addr, st.reg->user_ctrl, 3, data))
;;;2765               goto lp_int_restore;
;;;2766   
;;;2767           /* Set motion threshold. */
;;;2768           data[0] = thresh_hw;
;;;2769           if (i2c_write(st.hw->addr, st.reg->motion_thr, 1, data))
;;;2770               goto lp_int_restore;
;;;2771   
;;;2772           /* Set wake frequency. */
;;;2773           if (lpa_freq == 1)
;;;2774               data[0] = INV_LPA_1_25HZ;
;;;2775           else if (lpa_freq == 2)
;;;2776               data[0] = INV_LPA_2_5HZ;
;;;2777           else if (lpa_freq <= 5)
;;;2778               data[0] = INV_LPA_5HZ;
;;;2779           else if (lpa_freq <= 10)
;;;2780               data[0] = INV_LPA_10HZ;
;;;2781           else if (lpa_freq <= 20)
;;;2782               data[0] = INV_LPA_20HZ;
;;;2783           else if (lpa_freq <= 40)
;;;2784               data[0] = INV_LPA_40HZ;
;;;2785           else if (lpa_freq <= 80)
;;;2786               data[0] = INV_LPA_80HZ;
;;;2787           else if (lpa_freq <= 160)
;;;2788               data[0] = INV_LPA_160HZ;
;;;2789           else if (lpa_freq <= 320)
;;;2790               data[0] = INV_LPA_320HZ;
;;;2791           else
;;;2792               data[0] = INV_LPA_640HZ;
;;;2793           if (i2c_write(st.hw->addr, st.reg->lp_accel_odr, 1, data))
;;;2794               goto lp_int_restore;
;;;2795   
;;;2796           /* Enable motion interrupt (MPU6500 version). */
;;;2797           data[0] = BITS_WOM_EN;
;;;2798           if (i2c_write(st.hw->addr, st.reg->accel_intel, 1, data))
;;;2799               goto lp_int_restore;
;;;2800   
;;;2801           /* Enable cycle mode. */
;;;2802           data[0] = BIT_LPA_CYCLE;
;;;2803           if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
;;;2804               goto lp_int_restore;
;;;2805   
;;;2806           /* Enable interrupt. */
;;;2807           data[0] = BIT_MOT_INT_EN;
;;;2808           if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
;;;2809               goto lp_int_restore;
;;;2810   
;;;2811           st.chip_cfg.int_motion_only = 1;
;;;2812           return 0;
;;;2813   #endif
;;;2814       } else {
;;;2815           /* Don't "restore" the previous state if no state has been saved. */
;;;2816           int ii;
;;;2817           char *cache_ptr = (char*)&st.chip_cfg.cache;
;;;2818           for (ii = 0; ii < sizeof(st.chip_cfg.cache); ii++) {
;;;2819               if (cache_ptr[ii] != 0)
;;;2820                   goto lp_int_restore;
;;;2821           }
;;;2822           /* If we reach this point, motion interrupt mode hasn't been used yet. */
;;;2823           return -1;
;;;2824       }
;;;2825   lp_int_restore:
;;;2826       /* Set to invalid values to ensure no I2C writes are skipped. */
;;;2827       st.chip_cfg.gyro_fsr = 0xFF;
;;;2828       st.chip_cfg.accel_fsr = 0xFF;
;;;2829       st.chip_cfg.lpf = 0xFF;
;;;2830       st.chip_cfg.sample_rate = 0xFFFF;
;;;2831       st.chip_cfg.sensors = 0xFF;
;;;2832       st.chip_cfg.fifo_enable = 0xFF;
;;;2833       st.chip_cfg.clk_src = INV_CLK_PLL;
;;;2834       mpu_set_sensors(st.chip_cfg.cache.sensors_on);
;;;2835       mpu_set_gyro_fsr(st.chip_cfg.cache.gyro_fsr);
;;;2836       mpu_set_accel_fsr(st.chip_cfg.cache.accel_fsr);
;;;2837       mpu_set_lpf(st.chip_cfg.cache.lpf);
;;;2838       mpu_set_sample_rate(st.chip_cfg.cache.sample_rate);
;;;2839       mpu_configure_fifo(st.chip_cfg.cache.fifo_sensors);
;;;2840   
;;;2841       if (st.chip_cfg.cache.dmp_on)
;;;2842           mpu_set_dmp_state(1);
;;;2843   
;;;2844   #ifdef MPU6500
;;;2845       /* Disable motion interrupt (MPU6500 version). */
;;;2846       data[0] = 0;
;;;2847       if (i2c_write(st.hw->addr, st.reg->accel_intel, 1, data))
;;;2848           goto lp_int_restore;
;;;2849   #endif
;;;2850   
;;;2851       st.chip_cfg.int_motion_only = 0;
;;;2852       return 0;
;;;2853   }
00002e  bdf8              POP      {r3-r7,pc}
                  |L30.48|
000030  4873              LDR      r0,|L30.512|
000032  7d40              LDRB     r0,[r0,#0x15]         ;2688
000034  bb28              CBNZ     r0,|L30.130|
000036  4872              LDR      r0,|L30.512|
000038  f8900024          LDRB     r0,[r0,#0x24]         ;2690
00003c  b138              CBZ      r0,|L30.78|
00003e  2000              MOVS     r0,#0                 ;2691
000040  f7fffffe          BL       mpu_set_dmp_state
000044  2101              MOVS     r1,#1                 ;2692
000046  486e              LDR      r0,|L30.512|
000048  f8801020          STRB     r1,[r0,#0x20]         ;2692
00004c  e003              B        |L30.86|
                  |L30.78|
00004e  2100              MOVS     r1,#0                 ;2694
000050  486b              LDR      r0,|L30.512|
000052  f8801020          STRB     r1,[r0,#0x20]         ;2694
                  |L30.86|
000056  486a              LDR      r0,|L30.512|
000058  3016              ADDS     r0,r0,#0x16           ;2695
00005a  f7fffffe          BL       mpu_get_gyro_fsr
00005e  4868              LDR      r0,|L30.512|
000060  3018              ADDS     r0,r0,#0x18           ;2696
000062  f7fffffe          BL       mpu_get_accel_fsr
000066  4866              LDR      r0,|L30.512|
000068  301a              ADDS     r0,r0,#0x1a           ;2697
00006a  f7fffffe          BL       mpu_get_lpf
00006e  4864              LDR      r0,|L30.512|
000070  301c              ADDS     r0,r0,#0x1c           ;2698
000072  f7fffffe          BL       mpu_get_sample_rate
000076  4862              LDR      r0,|L30.512|
000078  7a81              LDRB     r1,[r0,#0xa]          ;2699
00007a  7781              STRB     r1,[r0,#0x1e]         ;2699
00007c  301f              ADDS     r0,r0,#0x1f           ;2700
00007e  f7fffffe          BL       mpu_get_fifo_config
                  |L30.130|
000082  2000              MOVS     r0,#0                 ;2705
000084  f7fffffe          BL       set_int_enable
000088  2000              MOVS     r0,#0                 ;2708
00008a  f7fffffe          BL       mpu_lp_accel_mode
00008e  2000              MOVS     r0,#0                 ;2713
000090  f88d0000          STRB     r0,[sp,#0]            ;2713
000094  4a5a              LDR      r2,|L30.512|
000096  6812              LDR      r2,[r2,#0]            ;2714  ; st
000098  7891              LDRB     r1,[r2,#2]            ;2714
00009a  4a59              LDR      r2,|L30.512|
00009c  6852              LDR      r2,[r2,#4]            ;2714  ; st
00009e  7810              LDRB     r0,[r2,#0]            ;2714
0000a0  466b              MOV      r3,sp                 ;2714
0000a2  2201              MOVS     r2,#1                 ;2714
0000a4  f7fffffe          BL       MPU_Write_Len
0000a8  b110              CBZ      r0,|L30.176|
0000aa  f04f30ff          MOV      r0,#0xffffffff        ;2715
0000ae  e7be              B        |L30.46|
                  |L30.176|
0000b0  2040              MOVS     r0,#0x40              ;2724
0000b2  f88d0000          STRB     r0,[sp,#0]            ;2724
0000b6  4a52              LDR      r2,|L30.512|
0000b8  6812              LDR      r2,[r2,#0]            ;2725  ; st
0000ba  7bd1              LDRB     r1,[r2,#0xf]          ;2725
0000bc  4a50              LDR      r2,|L30.512|
0000be  6852              LDR      r2,[r2,#4]            ;2725  ; st
0000c0  7810              LDRB     r0,[r2,#0]            ;2725
0000c2  466b              MOV      r3,sp                 ;2725
0000c4  2201              MOVS     r2,#1                 ;2725
0000c6  f7fffffe          BL       MPU_Write_Len
0000ca  b100              CBZ      r0,|L30.206|
0000cc  e065              B        |L30.410|
                  |L30.206|
0000ce  f88d6000          STRB     r6,[sp,#0]            ;2729
0000d2  f88d7001          STRB     r7,[sp,#1]            ;2730
0000d6  4a4a              LDR      r2,|L30.512|
0000d8  6812              LDR      r2,[r2,#0]            ;2731  ; st
0000da  7a11              LDRB     r1,[r2,#8]            ;2731
0000dc  4a48              LDR      r2,|L30.512|
0000de  6852              LDR      r2,[r2,#4]            ;2731  ; st
0000e0  7810              LDRB     r0,[r2,#0]            ;2731
0000e2  466b              MOV      r3,sp                 ;2731
0000e4  2202              MOVS     r2,#2                 ;2731
0000e6  f7fffffe          BL       MPU_Write_Len
0000ea  b108              CBZ      r0,|L30.240|
0000ec  e055              B        |L30.410|
                  |L30.238|
0000ee  e047              B        |L30.384|
                  |L30.240|
0000f0  2005              MOVS     r0,#5                 ;2735
0000f2  f7fffffe          BL       delay_ms
0000f6  4842              LDR      r0,|L30.512|
0000f8  7a40              LDRB     r0,[r0,#9]            ;2736
0000fa  2107              MOVS     r1,#7                 ;2736
0000fc  eb0100c0          ADD      r0,r1,r0,LSL #3       ;2736
000100  b2c0              UXTB     r0,r0                 ;2736
000102  f88d0000          STRB     r0,[sp,#0]            ;2736
000106  4a3e              LDR      r2,|L30.512|
000108  6812              LDR      r2,[r2,#0]            ;2737  ; st
00010a  79d1              LDRB     r1,[r2,#7]            ;2737
00010c  4a3c              LDR      r2,|L30.512|
00010e  6852              LDR      r2,[r2,#4]            ;2737  ; st
000110  7810              LDRB     r0,[r2,#0]            ;2737
000112  466b              MOV      r3,sp                 ;2737
000114  2201              MOVS     r2,#1                 ;2737
000116  f7fffffe          BL       MPU_Write_Len
00011a  b100              CBZ      r0,|L30.286|
00011c  e03d              B        |L30.410|
                  |L30.286|
00011e  2020              MOVS     r0,#0x20              ;2741
000120  f88d0000          STRB     r0,[sp,#0]            ;2741
000124  2c01              CMP      r4,#1                 ;2742
000126  d103              BNE      |L30.304|
000128  2000              MOVS     r0,#0                 ;2743
00012a  f88d0001          STRB     r0,[sp,#1]            ;2743
00012e  e00e              B        |L30.334|
                  |L30.304|
000130  2c05              CMP      r4,#5                 ;2744
000132  dc03              BGT      |L30.316|
000134  2001              MOVS     r0,#1                 ;2745
000136  f88d0001          STRB     r0,[sp,#1]            ;2745
00013a  e008              B        |L30.334|
                  |L30.316|
00013c  2c14              CMP      r4,#0x14              ;2746
00013e  dc03              BGT      |L30.328|
000140  2002              MOVS     r0,#2                 ;2747
000142  f88d0001          STRB     r0,[sp,#1]            ;2747
000146  e002              B        |L30.334|
                  |L30.328|
000148  2003              MOVS     r0,#3                 ;2749
00014a  f88d0001          STRB     r0,[sp,#1]            ;2749
                  |L30.334|
00014e  f89d0001          LDRB     r0,[sp,#1]            ;2750
000152  2107              MOVS     r1,#7                 ;2750
000154  eb011080          ADD      r0,r1,r0,LSL #6       ;2750
000158  b2c0              UXTB     r0,r0                 ;2750
00015a  f88d0001          STRB     r0,[sp,#1]            ;2750
00015e  4a28              LDR      r2,|L30.512|
000160  6812              LDR      r2,[r2,#0]            ;2751  ; st
000162  7c91              LDRB     r1,[r2,#0x12]         ;2751
000164  4a26              LDR      r2,|L30.512|
000166  6852              LDR      r2,[r2,#4]            ;2751  ; st
000168  7810              LDRB     r0,[r2,#0]            ;2751
00016a  466b              MOV      r3,sp                 ;2751
00016c  2202              MOVS     r2,#2                 ;2751
00016e  f7fffffe          BL       MPU_Write_Len
000172  b100              CBZ      r0,|L30.374|
000174  e011              B        |L30.410|
                  |L30.374|
000176  2101              MOVS     r1,#1                 ;2754
000178  4821              LDR      r0,|L30.512|
00017a  7541              STRB     r1,[r0,#0x15]         ;2754
00017c  2000              MOVS     r0,#0                 ;2755
00017e  e756              B        |L30.46|
                  |L30.384|
000180  4a1f              LDR      r2,|L30.512|
000182  3216              ADDS     r2,r2,#0x16           ;2817
000184  2100              MOVS     r1,#0                 ;2818
000186  e003              B        |L30.400|
                  |L30.392|
000188  5c50              LDRB     r0,[r2,r1]            ;2819
00018a  b100              CBZ      r0,|L30.398|
00018c  e005              B        |L30.410|
                  |L30.398|
00018e  1c49              ADDS     r1,r1,#1              ;2818
                  |L30.400|
000190  290c              CMP      r1,#0xc               ;2818
000192  d3f9              BCC      |L30.392|
000194  f04f30ff          MOV      r0,#0xffffffff        ;2823
000198  e749              B        |L30.46|
                  |L30.410|
00019a  20ff              MOVS     r0,#0xff              ;2827
00019c  4918              LDR      r1,|L30.512|
00019e  7208              STRB     r0,[r1,#8]            ;2827
0001a0  21ff              MOVS     r1,#0xff              ;2828
0001a2  4817              LDR      r0,|L30.512|
0001a4  7241              STRB     r1,[r0,#9]            ;2828
0001a6  72c1              STRB     r1,[r0,#0xb]          ;2829
0001a8  f64f71ff          MOV      r1,#0xffff            ;2830
0001ac  81c1              STRH     r1,[r0,#0xe]          ;2830
0001ae  21ff              MOVS     r1,#0xff              ;2831
0001b0  7281              STRB     r1,[r0,#0xa]          ;2831
0001b2  7401              STRB     r1,[r0,#0x10]         ;2832
0001b4  2101              MOVS     r1,#1                 ;2833
0001b6  7301              STRB     r1,[r0,#0xc]          ;2833
0001b8  4601              MOV      r1,r0                 ;2834
0001ba  7f88              LDRB     r0,[r1,#0x1e]         ;2834
0001bc  f7fffffe          BL       mpu_set_sensors
0001c0  490f              LDR      r1,|L30.512|
0001c2  8ac8              LDRH     r0,[r1,#0x16]         ;2835
0001c4  f7fffffe          BL       mpu_set_gyro_fsr
0001c8  490d              LDR      r1,|L30.512|
0001ca  7e08              LDRB     r0,[r1,#0x18]         ;2836
0001cc  f7fffffe          BL       mpu_set_accel_fsr
0001d0  490b              LDR      r1,|L30.512|
0001d2  8b48              LDRH     r0,[r1,#0x1a]         ;2837
0001d4  f7fffffe          BL       mpu_set_lpf
0001d8  4909              LDR      r1,|L30.512|
0001da  8b88              LDRH     r0,[r1,#0x1c]         ;2838
0001dc  f7fffffe          BL       mpu_set_sample_rate
0001e0  4907              LDR      r1,|L30.512|
0001e2  7fc8              LDRB     r0,[r1,#0x1f]         ;2839
0001e4  f7fffffe          BL       mpu_configure_fifo
0001e8  4805              LDR      r0,|L30.512|
0001ea  f8900020          LDRB     r0,[r0,#0x20]         ;2841
0001ee  b110              CBZ      r0,|L30.502|
0001f0  2001              MOVS     r0,#1                 ;2842
0001f2  f7fffffe          BL       mpu_set_dmp_state
                  |L30.502|
0001f6  2100              MOVS     r1,#0                 ;2851
0001f8  4801              LDR      r0,|L30.512|
0001fa  7541              STRB     r1,[r0,#0x15]         ;2851
0001fc  2000              MOVS     r0,#0                 ;2852
0001fe  e716              B        |L30.46|
;;;2854   //////////////////////////////////////////////////////////////////////////////////
                          ENDP

                  |L30.512|
                          DCD      ||st||

                          AREA ||i.mpu_read_fifo||, CODE, READONLY, ALIGN=2

                  mpu_read_fifo PROC
;;;1702    */
;;;1703   int mpu_read_fifo(short *gyro, short *accel, unsigned long *timestamp,
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;1704           unsigned char *sensors, unsigned char *more)
;;;1705   {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4692              MOV      r10,r2
00000a  461d              MOV      r5,r3
00000c  f8ddb030          LDR      r11,[sp,#0x30]
;;;1706       /* Assumes maximum packet size is gyro (6) + accel (6). */
;;;1707       unsigned char data[MAX_PACKET_LENGTH];
;;;1708       unsigned char packet_size = 0;
000010  2600              MOVS     r6,#0
;;;1709       unsigned short fifo_count, index = 0;
000012  2400              MOVS     r4,#0
;;;1710   
;;;1711       if (st.chip_cfg.dmp_on)
000014  4877              LDR      r0,|L31.500|
000016  f8900024          LDRB     r0,[r0,#0x24]
00001a  b110              CBZ      r0,|L31.34|
;;;1712           return -1;
00001c  1e60              SUBS     r0,r4,#1
                  |L31.30|
;;;1713   
;;;1714       sensors[0] = 0;
;;;1715       if (!st.chip_cfg.sensors)
;;;1716           return -1;
;;;1717       if (!st.chip_cfg.fifo_enable)
;;;1718           return -1;
;;;1719   
;;;1720       if (st.chip_cfg.fifo_enable & INV_X_GYRO)
;;;1721           packet_size += 2;
;;;1722       if (st.chip_cfg.fifo_enable & INV_Y_GYRO)
;;;1723           packet_size += 2;
;;;1724       if (st.chip_cfg.fifo_enable & INV_Z_GYRO)
;;;1725           packet_size += 2;
;;;1726       if (st.chip_cfg.fifo_enable & INV_XYZ_ACCEL)
;;;1727           packet_size += 6;
;;;1728   
;;;1729       if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
;;;1730           return -1;
;;;1731       fifo_count = (data[0] << 8) | data[1];
;;;1732       if (fifo_count < packet_size)
;;;1733           return 0;
;;;1734   //    log_i("FIFO count: %hd\n", fifo_count);
;;;1735       if (fifo_count > (st.hw->max_fifo >> 1)) {
;;;1736           /* FIFO is 50% full, better check overflow bit. */
;;;1737           if (i2c_read(st.hw->addr, st.reg->int_status, 1, data))
;;;1738               return -1;
;;;1739           if (data[0] & BIT_FIFO_OVERFLOW) {
;;;1740               mpu_reset_fifo();
;;;1741               return -2;
;;;1742           }
;;;1743       }
;;;1744       get_ms((unsigned long*)timestamp);
;;;1745   
;;;1746       if (i2c_read(st.hw->addr, st.reg->fifo_r_w, packet_size, data))
;;;1747           return -1;
;;;1748       more[0] = fifo_count / packet_size - 1;
;;;1749       sensors[0] = 0;
;;;1750   
;;;1751       if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_XYZ_ACCEL) {
;;;1752           accel[0] = (data[index+0] << 8) | data[index+1];
;;;1753           accel[1] = (data[index+2] << 8) | data[index+3];
;;;1754           accel[2] = (data[index+4] << 8) | data[index+5];
;;;1755           sensors[0] |= INV_XYZ_ACCEL;
;;;1756           index += 6;
;;;1757       }
;;;1758       if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_X_GYRO) {
;;;1759           gyro[0] = (data[index+0] << 8) | data[index+1];
;;;1760           sensors[0] |= INV_X_GYRO;
;;;1761           index += 2;
;;;1762       }
;;;1763       if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Y_GYRO) {
;;;1764           gyro[1] = (data[index+0] << 8) | data[index+1];
;;;1765           sensors[0] |= INV_Y_GYRO;
;;;1766           index += 2;
;;;1767       }
;;;1768       if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Z_GYRO) {
;;;1769           gyro[2] = (data[index+0] << 8) | data[index+1];
;;;1770           sensors[0] |= INV_Z_GYRO;
;;;1771           index += 2;
;;;1772       }
;;;1773   
;;;1774       return 0;
;;;1775   }
00001e  e8bd8ffe          POP      {r1-r11,pc}
                  |L31.34|
000022  2000              MOVS     r0,#0                 ;1714
000024  7028              STRB     r0,[r5,#0]            ;1714
000026  4873              LDR      r0,|L31.500|
000028  7a80              LDRB     r0,[r0,#0xa]          ;1715
00002a  b910              CBNZ     r0,|L31.50|
00002c  f04f30ff          MOV      r0,#0xffffffff        ;1716
000030  e7f5              B        |L31.30|
                  |L31.50|
000032  4870              LDR      r0,|L31.500|
000034  7c00              LDRB     r0,[r0,#0x10]         ;1717
000036  b910              CBNZ     r0,|L31.62|
000038  f04f30ff          MOV      r0,#0xffffffff        ;1718
00003c  e7ef              B        |L31.30|
                  |L31.62|
00003e  486d              LDR      r0,|L31.500|
000040  7c00              LDRB     r0,[r0,#0x10]         ;1720
000042  f0000040          AND      r0,r0,#0x40           ;1720
000046  b108              CBZ      r0,|L31.76|
000048  1cb0              ADDS     r0,r6,#2              ;1721
00004a  b2c6              UXTB     r6,r0                 ;1721
                  |L31.76|
00004c  4869              LDR      r0,|L31.500|
00004e  7c00              LDRB     r0,[r0,#0x10]         ;1722
000050  f0000020          AND      r0,r0,#0x20           ;1722
000054  b108              CBZ      r0,|L31.90|
000056  1cb0              ADDS     r0,r6,#2              ;1723
000058  b2c6              UXTB     r6,r0                 ;1723
                  |L31.90|
00005a  4866              LDR      r0,|L31.500|
00005c  7c00              LDRB     r0,[r0,#0x10]         ;1724
00005e  f0000010          AND      r0,r0,#0x10           ;1724
000062  b108              CBZ      r0,|L31.104|
000064  1cb0              ADDS     r0,r6,#2              ;1725
000066  b2c6              UXTB     r6,r0                 ;1725
                  |L31.104|
000068  4862              LDR      r0,|L31.500|
00006a  7c00              LDRB     r0,[r0,#0x10]         ;1726
00006c  f0000008          AND      r0,r0,#8              ;1726
000070  b108              CBZ      r0,|L31.118|
000072  1db0              ADDS     r0,r6,#6              ;1727
000074  b2c6              UXTB     r6,r0                 ;1727
                  |L31.118|
000076  4a5f              LDR      r2,|L31.500|
000078  6812              LDR      r2,[r2,#0]            ;1729  ; st
00007a  7a91              LDRB     r1,[r2,#0xa]          ;1729
00007c  4a5d              LDR      r2,|L31.500|
00007e  6852              LDR      r2,[r2,#4]            ;1729  ; st
000080  7810              LDRB     r0,[r2,#0]            ;1729
000082  466b              MOV      r3,sp                 ;1729
000084  2202              MOVS     r2,#2                 ;1729
000086  f7fffffe          BL       MPU_Read_Len
00008a  b110              CBZ      r0,|L31.146|
00008c  f04f30ff          MOV      r0,#0xffffffff        ;1730
000090  e7c5              B        |L31.30|
                  |L31.146|
000092  f89d0001          LDRB     r0,[sp,#1]            ;1731
000096  f89d1000          LDRB     r1,[sp,#0]            ;1731
00009a  ea402901          ORR      r9,r0,r1,LSL #8       ;1731
00009e  45b1              CMP      r9,r6                 ;1732
0000a0  da01              BGE      |L31.166|
0000a2  2000              MOVS     r0,#0                 ;1733
0000a4  e7bb              B        |L31.30|
                  |L31.166|
0000a6  4853              LDR      r0,|L31.500|
0000a8  6840              LDR      r0,[r0,#4]            ;1735  ; st
0000aa  8840              LDRH     r0,[r0,#2]            ;1735
0000ac  ebb90f60          CMP      r9,r0,ASR #1          ;1735
0000b0  dd17              BLE      |L31.226|
0000b2  4a50              LDR      r2,|L31.500|
0000b4  6812              LDR      r2,[r2,#0]            ;1737  ; st
0000b6  7c51              LDRB     r1,[r2,#0x11]         ;1737
0000b8  4a4e              LDR      r2,|L31.500|
0000ba  6852              LDR      r2,[r2,#4]            ;1737  ; st
0000bc  7810              LDRB     r0,[r2,#0]            ;1737
0000be  466b              MOV      r3,sp                 ;1737
0000c0  2201              MOVS     r2,#1                 ;1737
0000c2  f7fffffe          BL       MPU_Read_Len
0000c6  b110              CBZ      r0,|L31.206|
0000c8  f04f30ff          MOV      r0,#0xffffffff        ;1738
0000cc  e7a7              B        |L31.30|
                  |L31.206|
0000ce  f89d0000          LDRB     r0,[sp,#0]            ;1739
0000d2  f0000010          AND      r0,r0,#0x10           ;1739
0000d6  b120              CBZ      r0,|L31.226|
0000d8  f7fffffe          BL       mpu_reset_fifo
0000dc  f06f0001          MVN      r0,#1                 ;1741
0000e0  e79d              B        |L31.30|
                  |L31.226|
0000e2  4650              MOV      r0,r10                ;1744
0000e4  f7fffffe          BL       mget_ms
0000e8  4a42              LDR      r2,|L31.500|
0000ea  6812              LDR      r2,[r2,#0]            ;1746  ; st
0000ec  7ad1              LDRB     r1,[r2,#0xb]          ;1746
0000ee  4a41              LDR      r2,|L31.500|
0000f0  6852              LDR      r2,[r2,#4]            ;1746  ; st
0000f2  7810              LDRB     r0,[r2,#0]            ;1746
0000f4  466b              MOV      r3,sp                 ;1746
0000f6  4632              MOV      r2,r6                 ;1746
0000f8  f7fffffe          BL       MPU_Read_Len
0000fc  b110              CBZ      r0,|L31.260|
0000fe  f04f30ff          MOV      r0,#0xffffffff        ;1747
000102  e78c              B        |L31.30|
                  |L31.260|
000104  fb99f0f6          SDIV     r0,r9,r6              ;1748
000108  1e40              SUBS     r0,r0,#1              ;1748
00010a  f88b0000          STRB     r0,[r11,#0]           ;1748
00010e  2000              MOVS     r0,#0                 ;1749
000110  7028              STRB     r0,[r5,#0]            ;1749
000112  42b4              CMP      r4,r6                 ;1751
000114  d02a              BEQ      |L31.364|
000116  4837              LDR      r0,|L31.500|
000118  7c00              LDRB     r0,[r0,#0x10]         ;1751
00011a  f0000008          AND      r0,r0,#8              ;1751
00011e  b328              CBZ      r0,|L31.364|
000120  1c60              ADDS     r0,r4,#1              ;1752
000122  f81d0000          LDRB     r0,[sp,r0]            ;1752
000126  f81d1004          LDRB     r1,[sp,r4]            ;1752
00012a  ea402001          ORR      r0,r0,r1,LSL #8       ;1752
00012e  b200              SXTH     r0,r0                 ;1752
000130  f8a80000          STRH     r0,[r8,#0]            ;1752
000134  1ce0              ADDS     r0,r4,#3              ;1753
000136  f81d1000          LDRB     r1,[sp,r0]            ;1753
00013a  1ca0              ADDS     r0,r4,#2              ;1753
00013c  f81d0000          LDRB     r0,[sp,r0]            ;1753
000140  ea412000          ORR      r0,r1,r0,LSL #8       ;1753
000144  b200              SXTH     r0,r0                 ;1753
000146  f8a80002          STRH     r0,[r8,#2]            ;1753
00014a  1d60              ADDS     r0,r4,#5              ;1754
00014c  f81d1000          LDRB     r1,[sp,r0]            ;1754
000150  1d20              ADDS     r0,r4,#4              ;1754
000152  f81d0000          LDRB     r0,[sp,r0]            ;1754
000156  ea412000          ORR      r0,r1,r0,LSL #8       ;1754
00015a  b200              SXTH     r0,r0                 ;1754
00015c  f8a80004          STRH     r0,[r8,#4]            ;1754
000160  7828              LDRB     r0,[r5,#0]            ;1755
000162  f0400008          ORR      r0,r0,#8              ;1755
000166  7028              STRB     r0,[r5,#0]            ;1755
000168  1da0              ADDS     r0,r4,#6              ;1756
00016a  b284              UXTH     r4,r0                 ;1756
                  |L31.364|
00016c  42b4              CMP      r4,r6                 ;1758
00016e  d013              BEQ      |L31.408|
000170  4820              LDR      r0,|L31.500|
000172  7c00              LDRB     r0,[r0,#0x10]         ;1758
000174  f0000040          AND      r0,r0,#0x40           ;1758
000178  b170              CBZ      r0,|L31.408|
00017a  1c60              ADDS     r0,r4,#1              ;1759
00017c  f81d0000          LDRB     r0,[sp,r0]            ;1759
000180  f81d1004          LDRB     r1,[sp,r4]            ;1759
000184  ea402001          ORR      r0,r0,r1,LSL #8       ;1759
000188  b200              SXTH     r0,r0                 ;1759
00018a  8038              STRH     r0,[r7,#0]            ;1759
00018c  7828              LDRB     r0,[r5,#0]            ;1760
00018e  f0400040          ORR      r0,r0,#0x40           ;1760
000192  7028              STRB     r0,[r5,#0]            ;1760
000194  1ca0              ADDS     r0,r4,#2              ;1761
000196  b284              UXTH     r4,r0                 ;1761
                  |L31.408|
000198  42b4              CMP      r4,r6                 ;1763
00019a  d013              BEQ      |L31.452|
00019c  4815              LDR      r0,|L31.500|
00019e  7c00              LDRB     r0,[r0,#0x10]         ;1763
0001a0  f0000020          AND      r0,r0,#0x20           ;1763
0001a4  b170              CBZ      r0,|L31.452|
0001a6  1c60              ADDS     r0,r4,#1              ;1764
0001a8  f81d0000          LDRB     r0,[sp,r0]            ;1764
0001ac  f81d1004          LDRB     r1,[sp,r4]            ;1764
0001b0  ea402001          ORR      r0,r0,r1,LSL #8       ;1764
0001b4  b200              SXTH     r0,r0                 ;1764
0001b6  8078              STRH     r0,[r7,#2]            ;1764
0001b8  7828              LDRB     r0,[r5,#0]            ;1765
0001ba  f0400020          ORR      r0,r0,#0x20           ;1765
0001be  7028              STRB     r0,[r5,#0]            ;1765
0001c0  1ca0              ADDS     r0,r4,#2              ;1766
0001c2  b284              UXTH     r4,r0                 ;1766
                  |L31.452|
0001c4  42b4              CMP      r4,r6                 ;1768
0001c6  d013              BEQ      |L31.496|
0001c8  480a              LDR      r0,|L31.500|
0001ca  7c00              LDRB     r0,[r0,#0x10]         ;1768
0001cc  f0000010          AND      r0,r0,#0x10           ;1768
0001d0  b170              CBZ      r0,|L31.496|
0001d2  1c60              ADDS     r0,r4,#1              ;1769
0001d4  f81d0000          LDRB     r0,[sp,r0]            ;1769
0001d8  f81d1004          LDRB     r1,[sp,r4]            ;1769
0001dc  ea402001          ORR      r0,r0,r1,LSL #8       ;1769
0001e0  b200              SXTH     r0,r0                 ;1769
0001e2  80b8              STRH     r0,[r7,#4]            ;1769
0001e4  7828              LDRB     r0,[r5,#0]            ;1770
0001e6  f0400010          ORR      r0,r0,#0x10           ;1770
0001ea  7028              STRB     r0,[r5,#0]            ;1770
0001ec  1ca0              ADDS     r0,r4,#2              ;1771
0001ee  b284              UXTH     r4,r0                 ;1771
                  |L31.496|
0001f0  2000              MOVS     r0,#0                 ;1774
0001f2  e714              B        |L31.30|
;;;1776   
                          ENDP

                  |L31.500|
                          DCD      ||st||

                          AREA ||i.mpu_read_fifo_stream||, CODE, READONLY, ALIGN=2

                  mpu_read_fifo_stream PROC
;;;1783    */
;;;1784   int mpu_read_fifo_stream(unsigned short length, unsigned char *data,
000000  b5f8              PUSH     {r3-r7,lr}
;;;1785       unsigned char *more)
;;;1786   {
000002  4604              MOV      r4,r0
000004  460f              MOV      r7,r1
000006  4616              MOV      r6,r2
;;;1787       unsigned char tmp[2];
;;;1788       unsigned short fifo_count;
;;;1789       if (!st.chip_cfg.dmp_on)
000008  482c              LDR      r0,|L32.188|
00000a  f8900024          LDRB     r0,[r0,#0x24]
00000e  b910              CBNZ     r0,|L32.22|
;;;1790           return -1;
000010  f04f30ff          MOV      r0,#0xffffffff
                  |L32.20|
;;;1791       if (!st.chip_cfg.sensors)
;;;1792           return -1;
;;;1793   
;;;1794       if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, tmp))
;;;1795           return -1;
;;;1796       fifo_count = (tmp[0] << 8) | tmp[1];
;;;1797       if (fifo_count < length) {
;;;1798           more[0] = 0;
;;;1799           return -1;
;;;1800       }
;;;1801       if (fifo_count > (st.hw->max_fifo >> 1)) {
;;;1802           /* FIFO is 50% full, better check overflow bit. */
;;;1803           if (i2c_read(st.hw->addr, st.reg->int_status, 1, tmp))
;;;1804               return -1;
;;;1805           if (tmp[0] & BIT_FIFO_OVERFLOW) {
;;;1806               mpu_reset_fifo();
;;;1807               return -2;
;;;1808           }
;;;1809       }
;;;1810   
;;;1811       if (i2c_read(st.hw->addr, st.reg->fifo_r_w, length, data))
;;;1812           return -1;
;;;1813       more[0] = fifo_count / length - 1;
;;;1814       return 0;
;;;1815   }
000014  bdf8              POP      {r3-r7,pc}
                  |L32.22|
000016  4829              LDR      r0,|L32.188|
000018  7a80              LDRB     r0,[r0,#0xa]          ;1791
00001a  b910              CBNZ     r0,|L32.34|
00001c  f04f30ff          MOV      r0,#0xffffffff        ;1792
000020  e7f8              B        |L32.20|
                  |L32.34|
000022  4a26              LDR      r2,|L32.188|
000024  6812              LDR      r2,[r2,#0]            ;1794  ; st
000026  7a91              LDRB     r1,[r2,#0xa]          ;1794
000028  4a24              LDR      r2,|L32.188|
00002a  6852              LDR      r2,[r2,#4]            ;1794  ; st
00002c  7810              LDRB     r0,[r2,#0]            ;1794
00002e  466b              MOV      r3,sp                 ;1794
000030  2202              MOVS     r2,#2                 ;1794
000032  f7fffffe          BL       MPU_Read_Len
000036  b110              CBZ      r0,|L32.62|
000038  f04f30ff          MOV      r0,#0xffffffff        ;1795
00003c  e7ea              B        |L32.20|
                  |L32.62|
00003e  f89d0001          LDRB     r0,[sp,#1]            ;1796
000042  f89d1000          LDRB     r1,[sp,#0]            ;1796
000046  ea402501          ORR      r5,r0,r1,LSL #8       ;1796
00004a  42a5              CMP      r5,r4                 ;1797
00004c  da03              BGE      |L32.86|
00004e  2000              MOVS     r0,#0                 ;1798
000050  7030              STRB     r0,[r6,#0]            ;1798
000052  1e40              SUBS     r0,r0,#1              ;1799
000054  e7de              B        |L32.20|
                  |L32.86|
000056  4819              LDR      r0,|L32.188|
000058  6840              LDR      r0,[r0,#4]            ;1801  ; st
00005a  8840              LDRH     r0,[r0,#2]            ;1801
00005c  ebb50f60          CMP      r5,r0,ASR #1          ;1801
000060  dd17              BLE      |L32.146|
000062  4a16              LDR      r2,|L32.188|
000064  6812              LDR      r2,[r2,#0]            ;1803  ; st
000066  7c51              LDRB     r1,[r2,#0x11]         ;1803
000068  4a14              LDR      r2,|L32.188|
00006a  6852              LDR      r2,[r2,#4]            ;1803  ; st
00006c  7810              LDRB     r0,[r2,#0]            ;1803
00006e  466b              MOV      r3,sp                 ;1803
000070  2201              MOVS     r2,#1                 ;1803
000072  f7fffffe          BL       MPU_Read_Len
000076  b110              CBZ      r0,|L32.126|
000078  f04f30ff          MOV      r0,#0xffffffff        ;1804
00007c  e7ca              B        |L32.20|
                  |L32.126|
00007e  f89d0000          LDRB     r0,[sp,#0]            ;1805
000082  f0000010          AND      r0,r0,#0x10           ;1805
000086  b120              CBZ      r0,|L32.146|
000088  f7fffffe          BL       mpu_reset_fifo
00008c  f06f0001          MVN      r0,#1                 ;1807
000090  e7c0              B        |L32.20|
                  |L32.146|
000092  b2e2              UXTB     r2,r4                 ;1811
000094  4b09              LDR      r3,|L32.188|
000096  681b              LDR      r3,[r3,#0]            ;1811  ; st
000098  7ad9              LDRB     r1,[r3,#0xb]          ;1811
00009a  4b08              LDR      r3,|L32.188|
00009c  685b              LDR      r3,[r3,#4]            ;1811  ; st
00009e  7818              LDRB     r0,[r3,#0]            ;1811
0000a0  463b              MOV      r3,r7                 ;1811
0000a2  f7fffffe          BL       MPU_Read_Len
0000a6  b110              CBZ      r0,|L32.174|
0000a8  f04f30ff          MOV      r0,#0xffffffff        ;1812
0000ac  e7b2              B        |L32.20|
                  |L32.174|
0000ae  fb95f0f4          SDIV     r0,r5,r4              ;1813
0000b2  1e40              SUBS     r0,r0,#1              ;1813
0000b4  7030              STRB     r0,[r6,#0]            ;1813
0000b6  2000              MOVS     r0,#0                 ;1814
0000b8  e7ac              B        |L32.20|
;;;1816   
                          ENDP

0000ba  0000              DCW      0x0000
                  |L32.188|
                          DCD      ||st||

                          AREA ||i.mpu_read_mem||, CODE, READONLY, ALIGN=2

                  mpu_read_mem PROC
;;;2308    */
;;;2309   int mpu_read_mem(unsigned short mem_addr, unsigned short length,
000000  b5f8              PUSH     {r3-r7,lr}
;;;2310           unsigned char *data)
;;;2311   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;2312       unsigned char tmp[2];
;;;2313   
;;;2314       if (!data)
000008  b916              CBNZ     r6,|L33.16|
;;;2315           return -1;
00000a  f04f30ff          MOV      r0,#0xffffffff
                  |L33.14|
;;;2316       if (!st.chip_cfg.sensors)
;;;2317           return -1;
;;;2318   
;;;2319       tmp[0] = (unsigned char)(mem_addr >> 8);
;;;2320       tmp[1] = (unsigned char)(mem_addr & 0xFF);
;;;2321   
;;;2322       /* Check bank boundaries. */
;;;2323       if (tmp[1] + length > st.hw->bank_size)
;;;2324           return -1;
;;;2325   
;;;2326       if (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))
;;;2327           return -1;
;;;2328       if (i2c_read(st.hw->addr, st.reg->mem_r_w, length, data))
;;;2329           return -1;
;;;2330       return 0;
;;;2331   }
00000e  bdf8              POP      {r3-r7,pc}
                  |L33.16|
000010  481a              LDR      r0,|L33.124|
000012  7a80              LDRB     r0,[r0,#0xa]          ;2316
000014  b910              CBNZ     r0,|L33.28|
000016  f04f30ff          MOV      r0,#0xffffffff        ;2317
00001a  e7f8              B        |L33.14|
                  |L33.28|
00001c  1220              ASRS     r0,r4,#8              ;2319
00001e  f88d0000          STRB     r0,[sp,#0]            ;2319
000022  b2e0              UXTB     r0,r4                 ;2320
000024  f88d0001          STRB     r0,[sp,#1]            ;2320
000028  f89d0001          LDRB     r0,[sp,#1]            ;2323
00002c  4428              ADD      r0,r0,r5              ;2323
00002e  4913              LDR      r1,|L33.124|
000030  6849              LDR      r1,[r1,#4]            ;2323  ; st
000032  8949              LDRH     r1,[r1,#0xa]          ;2323
000034  4288              CMP      r0,r1                 ;2323
000036  dd02              BLE      |L33.62|
000038  f04f30ff          MOV      r0,#0xffffffff        ;2324
00003c  e7e7              B        |L33.14|
                  |L33.62|
00003e  4a0f              LDR      r2,|L33.124|
000040  6812              LDR      r2,[r2,#0]            ;2326  ; st
000042  7e11              LDRB     r1,[r2,#0x18]         ;2326
000044  4a0d              LDR      r2,|L33.124|
000046  6852              LDR      r2,[r2,#4]            ;2326  ; st
000048  7810              LDRB     r0,[r2,#0]            ;2326
00004a  466b              MOV      r3,sp                 ;2326
00004c  2202              MOVS     r2,#2                 ;2326
00004e  f7fffffe          BL       MPU_Write_Len
000052  b110              CBZ      r0,|L33.90|
000054  f04f30ff          MOV      r0,#0xffffffff        ;2327
000058  e7d9              B        |L33.14|
                  |L33.90|
00005a  b2ea              UXTB     r2,r5                 ;2328
00005c  4b07              LDR      r3,|L33.124|
00005e  681b              LDR      r3,[r3,#0]            ;2328  ; st
000060  7d59              LDRB     r1,[r3,#0x15]         ;2328
000062  4b06              LDR      r3,|L33.124|
000064  685b              LDR      r3,[r3,#4]            ;2328  ; st
000066  7818              LDRB     r0,[r3,#0]            ;2328
000068  4633              MOV      r3,r6                 ;2328
00006a  f7fffffe          BL       MPU_Read_Len
00006e  b110              CBZ      r0,|L33.118|
000070  f04f30ff          MOV      r0,#0xffffffff        ;2329
000074  e7cb              B        |L33.14|
                  |L33.118|
000076  2000              MOVS     r0,#0                 ;2330
000078  e7c9              B        |L33.14|
;;;2332   
                          ENDP

00007a  0000              DCW      0x0000
                  |L33.124|
                          DCD      ||st||

                          AREA ||i.mpu_read_reg||, CODE, READONLY, ALIGN=2

                  mpu_read_reg PROC
;;;739     */
;;;740    int mpu_read_reg(unsigned char reg, unsigned char *data)
000000  b570              PUSH     {r4-r6,lr}
;;;741    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;742        if (reg == st.reg->fifo_r_w || reg == st.reg->mem_r_w)
000006  480f              LDR      r0,|L34.68|
000008  6800              LDR      r0,[r0,#0]  ; st
00000a  7ac0              LDRB     r0,[r0,#0xb]
00000c  42a0              CMP      r0,r4
00000e  d004              BEQ      |L34.26|
000010  480c              LDR      r0,|L34.68|
000012  6800              LDR      r0,[r0,#0]  ; st
000014  7d40              LDRB     r0,[r0,#0x15]
000016  42a0              CMP      r0,r4
000018  d102              BNE      |L34.32|
                  |L34.26|
;;;743            return -1;
00001a  f04f30ff          MOV      r0,#0xffffffff
                  |L34.30|
;;;744        if (reg >= st.hw->num_reg)
;;;745            return -1;
;;;746        return i2c_read(st.hw->addr, reg, 1, data);
;;;747    }
00001e  bd70              POP      {r4-r6,pc}
                  |L34.32|
000020  4808              LDR      r0,|L34.68|
000022  6840              LDR      r0,[r0,#4]            ;744  ; st
000024  7900              LDRB     r0,[r0,#4]            ;744
000026  42a0              CMP      r0,r4                 ;744
000028  dc02              BGT      |L34.48|
00002a  f04f30ff          MOV      r0,#0xffffffff        ;745
00002e  e7f6              B        |L34.30|
                  |L34.48|
000030  4904              LDR      r1,|L34.68|
000032  6849              LDR      r1,[r1,#4]            ;746  ; st
000034  7808              LDRB     r0,[r1,#0]            ;746
000036  462b              MOV      r3,r5                 ;746
000038  2201              MOVS     r2,#1                 ;746
00003a  4621              MOV      r1,r4                 ;746
00003c  f7fffffe          BL       MPU_Read_Len
000040  e7ed              B        |L34.30|
;;;748    
                          ENDP

000042  0000              DCW      0x0000
                  |L34.68|
                          DCD      ||st||

                          AREA ||i.mpu_reg_dump||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  mpu_reg_dump PROC
;;;717     */
;;;718    int mpu_reg_dump(void)
000000  b538              PUSH     {r3-r5,lr}
;;;719    {
;;;720        unsigned char ii;
;;;721        unsigned char data;
;;;722    
;;;723        for (ii = 0; ii < st.hw->num_reg; ii++) {
000002  2400              MOVS     r4,#0
000004  e01f              B        |L35.70|
                  |L35.6|
;;;724            if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
000006  4813              LDR      r0,|L35.84|
000008  6800              LDR      r0,[r0,#0]  ; st
00000a  7ac0              LDRB     r0,[r0,#0xb]
00000c  42a0              CMP      r0,r4
00000e  d004              BEQ      |L35.26|
000010  4810              LDR      r0,|L35.84|
000012  6800              LDR      r0,[r0,#0]  ; st
000014  7d40              LDRB     r0,[r0,#0x15]
000016  42a0              CMP      r0,r4
000018  d100              BNE      |L35.28|
                  |L35.26|
;;;725                continue;
00001a  e012              B        |L35.66|
                  |L35.28|
;;;726            if (i2c_read(st.hw->addr, ii, 1, &data))
00001c  490d              LDR      r1,|L35.84|
00001e  6849              LDR      r1,[r1,#4]  ; st
000020  7808              LDRB     r0,[r1,#0]
000022  466b              MOV      r3,sp
000024  2201              MOVS     r2,#1
000026  4621              MOV      r1,r4
000028  f7fffffe          BL       MPU_Read_Len
00002c  b110              CBZ      r0,|L35.52|
;;;727                return -1;
00002e  f04f30ff          MOV      r0,#0xffffffff
                  |L35.50|
;;;728            log_i("%#5x: %#5x\r\n", ii, data);
;;;729        }
;;;730        return 0;
;;;731    }
000032  bd38              POP      {r3-r5,pc}
                  |L35.52|
000034  f89d2000          LDRB     r2,[sp,#0]            ;728
000038  4621              MOV      r1,r4                 ;728
00003a  a007              ADR      r0,|L35.88|
00003c  f7fffffe          BL       __2printf
000040  bf00              NOP                            ;725
                  |L35.66|
000042  1c60              ADDS     r0,r4,#1              ;723
000044  b2c4              UXTB     r4,r0                 ;723
                  |L35.70|
000046  4803              LDR      r0,|L35.84|
000048  6840              LDR      r0,[r0,#4]            ;723  ; st
00004a  7900              LDRB     r0,[r0,#4]            ;723
00004c  42a0              CMP      r0,r4                 ;723
00004e  dcda              BGT      |L35.6|
000050  2000              MOVS     r0,#0                 ;730
000052  e7ee              B        |L35.50|
;;;732    
                          ENDP

                  |L35.84|
                          DCD      ||st||
                  |L35.88|
000058  25233578          DCB      "%#5x: %#5x\r\n",0
00005c  3a202523
000060  35780d0a
000064  00      
000065  00                DCB      0
000066  00                DCB      0
000067  00                DCB      0

                          AREA ||i.mpu_reset_fifo||, CODE, READONLY, ALIGN=2

                  mpu_reset_fifo PROC
;;;1096    */
;;;1097   int mpu_reset_fifo(void)
000000  b508              PUSH     {r3,lr}
;;;1098   {
;;;1099       unsigned char data;
;;;1100   
;;;1101       if (!(st.chip_cfg.sensors))
000002  4870              LDR      r0,|L36.452|
000004  7a80              LDRB     r0,[r0,#0xa]
000006  b910              CBNZ     r0,|L36.14|
;;;1102           return -1;
000008  f04f30ff          MOV      r0,#0xffffffff
                  |L36.12|
;;;1103   
;;;1104       data = 0;
;;;1105       if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
;;;1106           return -1;
;;;1107       if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
;;;1108           return -1;
;;;1109       if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
;;;1110           return -1;
;;;1111   
;;;1112       if (st.chip_cfg.dmp_on) {
;;;1113           data = BIT_FIFO_RST | BIT_DMP_RST;
;;;1114           if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
;;;1115               return -1;
;;;1116           delay_ms(50);
;;;1117           data = BIT_DMP_EN | BIT_FIFO_EN;
;;;1118           if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
;;;1119               data |= BIT_AUX_IF_EN;
;;;1120           if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
;;;1121               return -1;
;;;1122           if (st.chip_cfg.int_enable)
;;;1123               data = BIT_DMP_INT_EN;
;;;1124           else
;;;1125               data = 0;
;;;1126           if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
;;;1127               return -1;
;;;1128           data = 0;
;;;1129           if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
;;;1130               return -1;
;;;1131       } else {
;;;1132           data = BIT_FIFO_RST;
;;;1133           if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
;;;1134               return -1;
;;;1135           if (st.chip_cfg.bypass_mode || !(st.chip_cfg.sensors & INV_XYZ_COMPASS))
;;;1136               data = BIT_FIFO_EN;
;;;1137           else
;;;1138               data = BIT_FIFO_EN | BIT_AUX_IF_EN;
;;;1139           if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
;;;1140               return -1;
;;;1141           delay_ms(50);
;;;1142           if (st.chip_cfg.int_enable)
;;;1143               data = BIT_DATA_RDY_EN;
;;;1144           else
;;;1145               data = 0;
;;;1146           if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
;;;1147               return -1;
;;;1148           if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &st.chip_cfg.fifo_enable))
;;;1149               return -1;
;;;1150       }
;;;1151       return 0;
;;;1152   }
00000c  bd08              POP      {r3,pc}
                  |L36.14|
00000e  2000              MOVS     r0,#0                 ;1104
000010  9000              STR      r0,[sp,#0]            ;1104
000012  4a6c              LDR      r2,|L36.452|
000014  6812              LDR      r2,[r2,#0]            ;1105  ; st
000016  7bd1              LDRB     r1,[r2,#0xf]          ;1105
000018  4a6a              LDR      r2,|L36.452|
00001a  6852              LDR      r2,[r2,#4]            ;1105  ; st
00001c  7810              LDRB     r0,[r2,#0]            ;1105
00001e  466b              MOV      r3,sp                 ;1105
000020  2201              MOVS     r2,#1                 ;1105
000022  f7fffffe          BL       MPU_Write_Len
000026  b110              CBZ      r0,|L36.46|
000028  f04f30ff          MOV      r0,#0xffffffff        ;1106
00002c  e7ee              B        |L36.12|
                  |L36.46|
00002e  4a65              LDR      r2,|L36.452|
000030  6812              LDR      r2,[r2,#0]            ;1107  ; st
000032  7951              LDRB     r1,[r2,#5]            ;1107
000034  4a63              LDR      r2,|L36.452|
000036  6852              LDR      r2,[r2,#4]            ;1107  ; st
000038  7810              LDRB     r0,[r2,#0]            ;1107
00003a  466b              MOV      r3,sp                 ;1107
00003c  2201              MOVS     r2,#1                 ;1107
00003e  f7fffffe          BL       MPU_Write_Len
000042  b110              CBZ      r0,|L36.74|
000044  f04f30ff          MOV      r0,#0xffffffff        ;1108
000048  e7e0              B        |L36.12|
                  |L36.74|
00004a  4a5e              LDR      r2,|L36.452|
00004c  6812              LDR      r2,[r2,#0]            ;1109  ; st
00004e  7911              LDRB     r1,[r2,#4]            ;1109
000050  4a5c              LDR      r2,|L36.452|
000052  6852              LDR      r2,[r2,#4]            ;1109  ; st
000054  7810              LDRB     r0,[r2,#0]            ;1109
000056  466b              MOV      r3,sp                 ;1109
000058  2201              MOVS     r2,#1                 ;1109
00005a  f7fffffe          BL       MPU_Write_Len
00005e  b110              CBZ      r0,|L36.102|
000060  f04f30ff          MOV      r0,#0xffffffff        ;1110
000064  e7d2              B        |L36.12|
                  |L36.102|
000066  4857              LDR      r0,|L36.452|
000068  f8900024          LDRB     r0,[r0,#0x24]         ;1112
00006c  2800              CMP      r0,#0                 ;1112
00006e  d053              BEQ      |L36.280|
000070  200c              MOVS     r0,#0xc               ;1113
000072  9000              STR      r0,[sp,#0]            ;1113
000074  4a53              LDR      r2,|L36.452|
000076  6812              LDR      r2,[r2,#0]            ;1114  ; st
000078  7911              LDRB     r1,[r2,#4]            ;1114
00007a  4a52              LDR      r2,|L36.452|
00007c  6852              LDR      r2,[r2,#4]            ;1114  ; st
00007e  7810              LDRB     r0,[r2,#0]            ;1114
000080  466b              MOV      r3,sp                 ;1114
000082  2201              MOVS     r2,#1                 ;1114
000084  f7fffffe          BL       MPU_Write_Len
000088  b110              CBZ      r0,|L36.144|
00008a  f04f30ff          MOV      r0,#0xffffffff        ;1115
00008e  e7bd              B        |L36.12|
                  |L36.144|
000090  2032              MOVS     r0,#0x32              ;1116
000092  f7fffffe          BL       delay_ms
000096  20c0              MOVS     r0,#0xc0              ;1117
000098  9000              STR      r0,[sp,#0]            ;1117
00009a  484a              LDR      r0,|L36.452|
00009c  7a80              LDRB     r0,[r0,#0xa]          ;1118
00009e  f0000001          AND      r0,r0,#1              ;1118
0000a2  b120              CBZ      r0,|L36.174|
0000a4  f89d0000          LDRB     r0,[sp,#0]            ;1119
0000a8  f0400020          ORR      r0,r0,#0x20           ;1119
0000ac  9000              STR      r0,[sp,#0]            ;1119
                  |L36.174|
0000ae  4a45              LDR      r2,|L36.452|
0000b0  6812              LDR      r2,[r2,#0]            ;1120  ; st
0000b2  7911              LDRB     r1,[r2,#4]            ;1120
0000b4  4a43              LDR      r2,|L36.452|
0000b6  6852              LDR      r2,[r2,#4]            ;1120  ; st
0000b8  7810              LDRB     r0,[r2,#0]            ;1120
0000ba  466b              MOV      r3,sp                 ;1120
0000bc  2201              MOVS     r2,#1                 ;1120
0000be  f7fffffe          BL       MPU_Write_Len
0000c2  b110              CBZ      r0,|L36.202|
0000c4  f04f30ff          MOV      r0,#0xffffffff        ;1121
0000c8  e7a0              B        |L36.12|
                  |L36.202|
0000ca  483e              LDR      r0,|L36.452|
0000cc  7c40              LDRB     r0,[r0,#0x11]         ;1122
0000ce  b110              CBZ      r0,|L36.214|
0000d0  2002              MOVS     r0,#2                 ;1123
0000d2  9000              STR      r0,[sp,#0]            ;1123
0000d4  e001              B        |L36.218|
                  |L36.214|
0000d6  2000              MOVS     r0,#0                 ;1125
0000d8  9000              STR      r0,[sp,#0]            ;1125
                  |L36.218|
0000da  4a3a              LDR      r2,|L36.452|
0000dc  6812              LDR      r2,[r2,#0]            ;1126  ; st
0000de  7bd1              LDRB     r1,[r2,#0xf]          ;1126
0000e0  4a38              LDR      r2,|L36.452|
0000e2  6852              LDR      r2,[r2,#4]            ;1126  ; st
0000e4  7810              LDRB     r0,[r2,#0]            ;1126
0000e6  466b              MOV      r3,sp                 ;1126
0000e8  2201              MOVS     r2,#1                 ;1126
0000ea  f7fffffe          BL       MPU_Write_Len
0000ee  b110              CBZ      r0,|L36.246|
0000f0  f04f30ff          MOV      r0,#0xffffffff        ;1127
0000f4  e78a              B        |L36.12|
                  |L36.246|
0000f6  2000              MOVS     r0,#0                 ;1128
0000f8  9000              STR      r0,[sp,#0]            ;1128
0000fa  4a32              LDR      r2,|L36.452|
0000fc  6812              LDR      r2,[r2,#0]            ;1129  ; st
0000fe  7951              LDRB     r1,[r2,#5]            ;1129
000100  4a30              LDR      r2,|L36.452|
000102  6852              LDR      r2,[r2,#4]            ;1129  ; st
000104  7810              LDRB     r0,[r2,#0]            ;1129
000106  466b              MOV      r3,sp                 ;1129
000108  2201              MOVS     r2,#1                 ;1129
00010a  f7fffffe          BL       MPU_Write_Len
00010e  2800              CMP      r0,#0                 ;1129
000110  d055              BEQ      |L36.446|
000112  f04f30ff          MOV      r0,#0xffffffff        ;1130
000116  e779              B        |L36.12|
                  |L36.280|
000118  2004              MOVS     r0,#4                 ;1132
00011a  9000              STR      r0,[sp,#0]            ;1132
00011c  4a29              LDR      r2,|L36.452|
00011e  6812              LDR      r2,[r2,#0]            ;1133  ; st
000120  7911              LDRB     r1,[r2,#4]            ;1133
000122  4a28              LDR      r2,|L36.452|
000124  6852              LDR      r2,[r2,#4]            ;1133  ; st
000126  7810              LDRB     r0,[r2,#0]            ;1133
000128  466b              MOV      r3,sp                 ;1133
00012a  2201              MOVS     r2,#1                 ;1133
00012c  f7fffffe          BL       MPU_Write_Len
000130  b110              CBZ      r0,|L36.312|
000132  f04f30ff          MOV      r0,#0xffffffff        ;1134
000136  e769              B        |L36.12|
                  |L36.312|
000138  4822              LDR      r0,|L36.452|
00013a  7c80              LDRB     r0,[r0,#0x12]         ;1135
00013c  b920              CBNZ     r0,|L36.328|
00013e  4821              LDR      r0,|L36.452|
000140  7a80              LDRB     r0,[r0,#0xa]          ;1135
000142  f0000001          AND      r0,r0,#1              ;1135
000146  b910              CBNZ     r0,|L36.334|
                  |L36.328|
000148  2040              MOVS     r0,#0x40              ;1136
00014a  9000              STR      r0,[sp,#0]            ;1136
00014c  e001              B        |L36.338|
                  |L36.334|
00014e  2060              MOVS     r0,#0x60              ;1138
000150  9000              STR      r0,[sp,#0]            ;1138
                  |L36.338|
000152  4a1c              LDR      r2,|L36.452|
000154  6812              LDR      r2,[r2,#0]            ;1139  ; st
000156  7911              LDRB     r1,[r2,#4]            ;1139
000158  4a1a              LDR      r2,|L36.452|
00015a  6852              LDR      r2,[r2,#4]            ;1139  ; st
00015c  7810              LDRB     r0,[r2,#0]            ;1139
00015e  466b              MOV      r3,sp                 ;1139
000160  2201              MOVS     r2,#1                 ;1139
000162  f7fffffe          BL       MPU_Write_Len
000166  b110              CBZ      r0,|L36.366|
000168  f04f30ff          MOV      r0,#0xffffffff        ;1140
00016c  e74e              B        |L36.12|
                  |L36.366|
00016e  2032              MOVS     r0,#0x32              ;1141
000170  f7fffffe          BL       delay_ms
000174  4813              LDR      r0,|L36.452|
000176  7c40              LDRB     r0,[r0,#0x11]         ;1142
000178  b110              CBZ      r0,|L36.384|
00017a  2001              MOVS     r0,#1                 ;1143
00017c  9000              STR      r0,[sp,#0]            ;1143
00017e  e001              B        |L36.388|
                  |L36.384|
000180  2000              MOVS     r0,#0                 ;1145
000182  9000              STR      r0,[sp,#0]            ;1145
                  |L36.388|
000184  4a0f              LDR      r2,|L36.452|
000186  6812              LDR      r2,[r2,#0]            ;1146  ; st
000188  7bd1              LDRB     r1,[r2,#0xf]          ;1146
00018a  4a0e              LDR      r2,|L36.452|
00018c  6852              LDR      r2,[r2,#4]            ;1146  ; st
00018e  7810              LDRB     r0,[r2,#0]            ;1146
000190  466b              MOV      r3,sp                 ;1146
000192  2201              MOVS     r2,#1                 ;1146
000194  f7fffffe          BL       MPU_Write_Len
000198  b110              CBZ      r0,|L36.416|
00019a  f04f30ff          MOV      r0,#0xffffffff        ;1147
00019e  e735              B        |L36.12|
                  |L36.416|
0001a0  4a08              LDR      r2,|L36.452|
0001a2  6812              LDR      r2,[r2,#0]            ;1148  ; st
0001a4  7951              LDRB     r1,[r2,#5]            ;1148
0001a6  4a07              LDR      r2,|L36.452|
0001a8  6852              LDR      r2,[r2,#4]            ;1148  ; st
0001aa  7810              LDRB     r0,[r2,#0]            ;1148
0001ac  4b05              LDR      r3,|L36.452|
0001ae  3310              ADDS     r3,r3,#0x10           ;1148
0001b0  2201              MOVS     r2,#1                 ;1148
0001b2  f7fffffe          BL       MPU_Write_Len
0001b6  b110              CBZ      r0,|L36.446|
0001b8  f04f30ff          MOV      r0,#0xffffffff        ;1149
0001bc  e726              B        |L36.12|
                  |L36.446|
0001be  2000              MOVS     r0,#0                 ;1151
0001c0  e724              B        |L36.12|
;;;1153   
                          ENDP

0001c2  0000              DCW      0x0000
                  |L36.452|
                          DCD      ||st||

                          AREA ||i.mpu_run_self_test||, CODE, READONLY, ALIGN=2

                  mpu_run_self_test PROC
;;;2173    */
;;;2174   int mpu_run_self_test(long *gyro, long *accel)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;2175   {
000004  b08d              SUB      sp,sp,#0x34
000006  4683              MOV      r11,r0
000008  460f              MOV      r7,r1
;;;2176   #ifdef MPU6050
;;;2177       const unsigned char tries = 2;
00000a  2002              MOVS     r0,#2
00000c  900c              STR      r0,[sp,#0x30]
;;;2178       long gyro_st[3], accel_st[3];
;;;2179       unsigned char accel_result, gyro_result;
;;;2180   #ifdef AK89xx_SECONDARY
;;;2181       unsigned char compass_result;
;;;2182   #endif
;;;2183       int ii;
;;;2184   #endif
;;;2185       int result;
;;;2186       unsigned char accel_fsr, fifo_sensors, sensors_on;
;;;2187       unsigned short gyro_fsr, sample_rate, lpf;
;;;2188       unsigned char dmp_was_on;
;;;2189   
;;;2190       if (st.chip_cfg.dmp_on) {
00000e  4842              LDR      r0,|L37.280|
000010  f8900024          LDRB     r0,[r0,#0x24]
000014  b120              CBZ      r0,|L37.32|
;;;2191           mpu_set_dmp_state(0);
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       mpu_set_dmp_state
;;;2192           dmp_was_on = 1;
00001c  2601              MOVS     r6,#1
00001e  e000              B        |L37.34|
                  |L37.32|
;;;2193       } else
;;;2194           dmp_was_on = 0;
000020  2600              MOVS     r6,#0
                  |L37.34|
;;;2195   
;;;2196       /* Get initial settings. */
;;;2197       mpu_get_gyro_fsr(&gyro_fsr);
000022  a803              ADD      r0,sp,#0xc
000024  f7fffffe          BL       mpu_get_gyro_fsr
;;;2198       mpu_get_accel_fsr(&accel_fsr);
000028  a805              ADD      r0,sp,#0x14
00002a  f7fffffe          BL       mpu_get_accel_fsr
;;;2199       mpu_get_lpf(&lpf);
00002e  a801              ADD      r0,sp,#4
000030  f7fffffe          BL       mpu_get_lpf
;;;2200       mpu_get_sample_rate(&sample_rate);
000034  a802              ADD      r0,sp,#8
000036  f7fffffe          BL       mpu_get_sample_rate
;;;2201       sensors_on = st.chip_cfg.sensors;
00003a  4837              LDR      r0,|L37.280|
00003c  f890a00a          LDRB     r10,[r0,#0xa]
;;;2202       mpu_get_fifo_config(&fifo_sensors);
000040  a804              ADD      r0,sp,#0x10
000042  f7fffffe          BL       mpu_get_fifo_config
;;;2203   
;;;2204       /* For older chips, the self-test will be different. */
;;;2205   #if defined MPU6050
;;;2206       for (ii = 0; ii < tries; ii++)
000046  2400              MOVS     r4,#0
000048  e007              B        |L37.90|
                  |L37.74|
;;;2207           if (!get_st_biases(gyro, accel, 0))
00004a  2200              MOVS     r2,#0
00004c  4639              MOV      r1,r7
00004e  4658              MOV      r0,r11
000050  f7fffffe          BL       get_st_biases
000054  b900              CBNZ     r0,|L37.88|
;;;2208               break;
000056  e002              B        |L37.94|
                  |L37.88|
000058  1c64              ADDS     r4,r4,#1              ;2206
                  |L37.90|
00005a  2c02              CMP      r4,#2                 ;2206
00005c  dbf5              BLT      |L37.74|
                  |L37.94|
00005e  bf00              NOP      
;;;2209       if (ii == tries) {
000060  2c02              CMP      r4,#2
000062  d101              BNE      |L37.104|
;;;2210           /* If we reach this point, we most likely encountered an I2C error.
;;;2211            * We'll just report an error for all three sensors.
;;;2212            */
;;;2213           result = 0;
000064  2500              MOVS     r5,#0
;;;2214           goto restore;
000066  e028              B        |L37.186|
                  |L37.104|
;;;2215       }
;;;2216       for (ii = 0; ii < tries; ii++)
000068  2400              MOVS     r4,#0
00006a  e007              B        |L37.124|
                  |L37.108|
;;;2217           if (!get_st_biases(gyro_st, accel_st, 1))
00006c  2201              MOVS     r2,#1
00006e  a906              ADD      r1,sp,#0x18
000070  a809              ADD      r0,sp,#0x24
000072  f7fffffe          BL       get_st_biases
000076  b900              CBNZ     r0,|L37.122|
;;;2218               break;
000078  e002              B        |L37.128|
                  |L37.122|
00007a  1c64              ADDS     r4,r4,#1              ;2216
                  |L37.124|
00007c  2c02              CMP      r4,#2                 ;2216
00007e  dbf5              BLT      |L37.108|
                  |L37.128|
000080  bf00              NOP      
;;;2219       if (ii == tries) {
000082  2c02              CMP      r4,#2
000084  d101              BNE      |L37.138|
;;;2220           /* Again, probably an I2C error. */
;;;2221           result = 0;
000086  2500              MOVS     r5,#0
;;;2222           goto restore;
000088  e017              B        |L37.186|
                  |L37.138|
;;;2223       }
;;;2224       accel_result = accel_self_test(accel, accel_st);
00008a  a906              ADD      r1,sp,#0x18
00008c  4638              MOV      r0,r7
00008e  f7fffffe          BL       accel_self_test
000092  f00008ff          AND      r8,r0,#0xff
;;;2225       gyro_result = gyro_self_test(gyro, gyro_st);
000096  a909              ADD      r1,sp,#0x24
000098  4658              MOV      r0,r11
00009a  f7fffffe          BL       gyro_self_test
00009e  f00009ff          AND      r9,r0,#0xff
;;;2226   
;;;2227       result = 0;
0000a2  2500              MOVS     r5,#0
;;;2228       if (!gyro_result)
0000a4  f1b90f00          CMP      r9,#0
0000a8  d101              BNE      |L37.174|
;;;2229           result |= 0x01;
0000aa  f0450501          ORR      r5,r5,#1
                  |L37.174|
;;;2230       if (!accel_result)
0000ae  f1b80f00          CMP      r8,#0
0000b2  d101              BNE      |L37.184|
;;;2231           result |= 0x02;
0000b4  f0450502          ORR      r5,r5,#2
                  |L37.184|
;;;2232   
;;;2233   #ifdef AK89xx_SECONDARY
;;;2234       compass_result = compass_self_test();
;;;2235       if (!compass_result)
;;;2236           result |= 0x04;
;;;2237   #endif
;;;2238   restore:
0000b8  bf00              NOP      
                  |L37.186|
;;;2239   #elif defined MPU6500
;;;2240       /* For now, this function will return a "pass" result for all three sensors
;;;2241        * for compatibility with current test applications.
;;;2242        */
;;;2243       get_st_biases(gyro, accel, 0);
;;;2244       result = 0x7;
;;;2245   #endif
;;;2246       /* Set to invalid values to ensure no I2C writes are skipped. */
;;;2247       st.chip_cfg.gyro_fsr = 0xFF;
0000ba  20ff              MOVS     r0,#0xff
0000bc  4916              LDR      r1,|L37.280|
0000be  7208              STRB     r0,[r1,#8]
;;;2248       st.chip_cfg.accel_fsr = 0xFF;
0000c0  21ff              MOVS     r1,#0xff
0000c2  4815              LDR      r0,|L37.280|
0000c4  7241              STRB     r1,[r0,#9]
;;;2249       st.chip_cfg.lpf = 0xFF;
0000c6  72c1              STRB     r1,[r0,#0xb]
;;;2250       st.chip_cfg.sample_rate = 0xFFFF;
0000c8  f64f71ff          MOV      r1,#0xffff
0000cc  81c1              STRH     r1,[r0,#0xe]
;;;2251       st.chip_cfg.sensors = 0xFF;
0000ce  21ff              MOVS     r1,#0xff
0000d0  7281              STRB     r1,[r0,#0xa]
;;;2252       st.chip_cfg.fifo_enable = 0xFF;
0000d2  7401              STRB     r1,[r0,#0x10]
;;;2253       st.chip_cfg.clk_src = INV_CLK_PLL;
0000d4  2101              MOVS     r1,#1
0000d6  7301              STRB     r1,[r0,#0xc]
;;;2254       mpu_set_gyro_fsr(gyro_fsr);
0000d8  f8bd000c          LDRH     r0,[sp,#0xc]
0000dc  f7fffffe          BL       mpu_set_gyro_fsr
;;;2255       mpu_set_accel_fsr(accel_fsr);
0000e0  f89d0014          LDRB     r0,[sp,#0x14]
0000e4  f7fffffe          BL       mpu_set_accel_fsr
;;;2256       mpu_set_lpf(lpf);
0000e8  f8bd0004          LDRH     r0,[sp,#4]
0000ec  f7fffffe          BL       mpu_set_lpf
;;;2257       mpu_set_sample_rate(sample_rate);
0000f0  f8bd0008          LDRH     r0,[sp,#8]
0000f4  f7fffffe          BL       mpu_set_sample_rate
;;;2258       mpu_set_sensors(sensors_on);
0000f8  4650              MOV      r0,r10
0000fa  f7fffffe          BL       mpu_set_sensors
;;;2259       mpu_configure_fifo(fifo_sensors);
0000fe  f89d0010          LDRB     r0,[sp,#0x10]
000102  f7fffffe          BL       mpu_configure_fifo
;;;2260   
;;;2261       if (dmp_was_on)
000106  b116              CBZ      r6,|L37.270|
;;;2262           mpu_set_dmp_state(1);
000108  2001              MOVS     r0,#1
00010a  f7fffffe          BL       mpu_set_dmp_state
                  |L37.270|
;;;2263   
;;;2264       return result;
00010e  4628              MOV      r0,r5
;;;2265   }
000110  b00d              ADD      sp,sp,#0x34
000112  e8bd8ff0          POP      {r4-r11,pc}
;;;2266   
                          ENDP

000116  0000              DCW      0x0000
                  |L37.280|
                          DCD      ||st||

                          AREA ||i.mpu_set_accel_bias||, CODE, READONLY, ALIGN=2

                  mpu_set_accel_bias PROC
;;;1047    */
;;;1048   int mpu_set_accel_bias(const long *accel_bias)
000000  b510              PUSH     {r4,lr}
;;;1049   {
000002  b088              SUB      sp,sp,#0x20
000004  4604              MOV      r4,r0
;;;1050       unsigned char data[6];
;;;1051       short accel_hw[3];
;;;1052       short got_accel[3];
;;;1053       short fg[3];
;;;1054   
;;;1055       if (!accel_bias)
000006  b91c              CBNZ     r4,|L38.16|
;;;1056           return -1;
000008  f04f30ff          MOV      r0,#0xffffffff
                  |L38.12|
;;;1057       if (!accel_bias[0] && !accel_bias[1] && !accel_bias[2])
;;;1058           return 0;
;;;1059   
;;;1060       if (i2c_read(st.hw->addr, 3, 3, data))
;;;1061           return -1;
;;;1062       fg[0] = ((data[0] >> 4) + 8) & 0xf;
;;;1063       fg[1] = ((data[1] >> 4) + 8) & 0xf;
;;;1064       fg[2] = ((data[2] >> 4) + 8) & 0xf;
;;;1065   
;;;1066       accel_hw[0] = (short)(accel_bias[0] * 2 / (64 + fg[0]));
;;;1067       accel_hw[1] = (short)(accel_bias[1] * 2 / (64 + fg[1]));
;;;1068       accel_hw[2] = (short)(accel_bias[2] * 2 / (64 + fg[2]));
;;;1069   
;;;1070       if (i2c_read(st.hw->addr, 0x06, 6, data))
;;;1071           return -1;
;;;1072   
;;;1073       got_accel[0] = ((short)data[0] << 8) | data[1];
;;;1074       got_accel[1] = ((short)data[2] << 8) | data[3];
;;;1075       got_accel[2] = ((short)data[4] << 8) | data[5];
;;;1076   
;;;1077       accel_hw[0] += got_accel[0];
;;;1078       accel_hw[1] += got_accel[1];
;;;1079       accel_hw[2] += got_accel[2];
;;;1080   
;;;1081       data[0] = (accel_hw[0] >> 8) & 0xff;
;;;1082       data[1] = (accel_hw[0]) & 0xff;
;;;1083       data[2] = (accel_hw[1] >> 8) & 0xff;
;;;1084       data[3] = (accel_hw[1]) & 0xff;
;;;1085       data[4] = (accel_hw[2] >> 8) & 0xff;
;;;1086       data[5] = (accel_hw[2]) & 0xff;
;;;1087   
;;;1088       if (i2c_write(st.hw->addr, 0x06, 6, data))
;;;1089           return -1;
;;;1090       return 0;
;;;1091   }
00000c  b008              ADD      sp,sp,#0x20
00000e  bd10              POP      {r4,pc}
                  |L38.16|
000010  6820              LDR      r0,[r4,#0]            ;1057
000012  b928              CBNZ     r0,|L38.32|
000014  6860              LDR      r0,[r4,#4]            ;1057
000016  b918              CBNZ     r0,|L38.32|
000018  68a0              LDR      r0,[r4,#8]            ;1057
00001a  b908              CBNZ     r0,|L38.32|
00001c  2000              MOVS     r0,#0                 ;1058
00001e  e7f5              B        |L38.12|
                  |L38.32|
000020  4956              LDR      r1,|L38.380|
000022  6849              LDR      r1,[r1,#4]            ;1060  ; st
000024  7808              LDRB     r0,[r1,#0]            ;1060
000026  ab06              ADD      r3,sp,#0x18           ;1060
000028  2203              MOVS     r2,#3                 ;1060
00002a  4611              MOV      r1,r2                 ;1060
00002c  f7fffffe          BL       MPU_Read_Len
000030  b110              CBZ      r0,|L38.56|
000032  f04f30ff          MOV      r0,#0xffffffff        ;1061
000036  e7e9              B        |L38.12|
                  |L38.56|
000038  f89d0018          LDRB     r0,[sp,#0x18]         ;1062
00003c  2108              MOVS     r1,#8                 ;1062
00003e  eb011020          ADD      r0,r1,r0,ASR #4       ;1062
000042  f000000f          AND      r0,r0,#0xf            ;1062
000046  f8ad0000          STRH     r0,[sp,#0]            ;1062
00004a  f89d0019          LDRB     r0,[sp,#0x19]         ;1063
00004e  eb011020          ADD      r0,r1,r0,ASR #4       ;1063
000052  f000000f          AND      r0,r0,#0xf            ;1063
000056  f8ad0002          STRH     r0,[sp,#2]            ;1063
00005a  f89d001a          LDRB     r0,[sp,#0x1a]         ;1064
00005e  eb011020          ADD      r0,r1,r0,ASR #4       ;1064
000062  f000000f          AND      r0,r0,#0xf            ;1064
000066  f8ad0004          STRH     r0,[sp,#4]            ;1064
00006a  6820              LDR      r0,[r4,#0]            ;1066
00006c  0041              LSLS     r1,r0,#1              ;1066
00006e  f9bd0000          LDRSH    r0,[sp,#0]            ;1066
000072  3040              ADDS     r0,r0,#0x40           ;1066
000074  fb91f0f0          SDIV     r0,r1,r0              ;1066
000078  b200              SXTH     r0,r0                 ;1066
00007a  f8ad0010          STRH     r0,[sp,#0x10]         ;1066
00007e  6860              LDR      r0,[r4,#4]            ;1067
000080  0041              LSLS     r1,r0,#1              ;1067
000082  f9bd0002          LDRSH    r0,[sp,#2]            ;1067
000086  3040              ADDS     r0,r0,#0x40           ;1067
000088  fb91f0f0          SDIV     r0,r1,r0              ;1067
00008c  b200              SXTH     r0,r0                 ;1067
00008e  f8ad0012          STRH     r0,[sp,#0x12]         ;1067
000092  68a0              LDR      r0,[r4,#8]            ;1068
000094  0041              LSLS     r1,r0,#1              ;1068
000096  f9bd0004          LDRSH    r0,[sp,#4]            ;1068
00009a  3040              ADDS     r0,r0,#0x40           ;1068
00009c  fb91f0f0          SDIV     r0,r1,r0              ;1068
0000a0  b200              SXTH     r0,r0                 ;1068
0000a2  f8ad0014          STRH     r0,[sp,#0x14]         ;1068
0000a6  4935              LDR      r1,|L38.380|
0000a8  6849              LDR      r1,[r1,#4]            ;1070  ; st
0000aa  7808              LDRB     r0,[r1,#0]            ;1070
0000ac  ab06              ADD      r3,sp,#0x18           ;1070
0000ae  2206              MOVS     r2,#6                 ;1070
0000b0  4611              MOV      r1,r2                 ;1070
0000b2  f7fffffe          BL       MPU_Read_Len
0000b6  b110              CBZ      r0,|L38.190|
0000b8  f04f30ff          MOV      r0,#0xffffffff        ;1071
0000bc  e7a6              B        |L38.12|
                  |L38.190|
0000be  f89d0019          LDRB     r0,[sp,#0x19]         ;1073
0000c2  f89d1018          LDRB     r1,[sp,#0x18]         ;1073
0000c6  ea402001          ORR      r0,r0,r1,LSL #8       ;1073
0000ca  b200              SXTH     r0,r0                 ;1073
0000cc  f8ad0008          STRH     r0,[sp,#8]            ;1073
0000d0  f89d001b          LDRB     r0,[sp,#0x1b]         ;1074
0000d4  f89d101a          LDRB     r1,[sp,#0x1a]         ;1074
0000d8  ea402001          ORR      r0,r0,r1,LSL #8       ;1074
0000dc  b200              SXTH     r0,r0                 ;1074
0000de  f8ad000a          STRH     r0,[sp,#0xa]          ;1074
0000e2  f89d001d          LDRB     r0,[sp,#0x1d]         ;1075
0000e6  f89d101c          LDRB     r1,[sp,#0x1c]         ;1075
0000ea  ea402001          ORR      r0,r0,r1,LSL #8       ;1075
0000ee  b200              SXTH     r0,r0                 ;1075
0000f0  f8ad000c          STRH     r0,[sp,#0xc]          ;1075
0000f4  f8bd0010          LDRH     r0,[sp,#0x10]         ;1077
0000f8  f8bd1008          LDRH     r1,[sp,#8]            ;1077
0000fc  4408              ADD      r0,r0,r1              ;1077
0000fe  b200              SXTH     r0,r0                 ;1077
000100  f8ad0010          STRH     r0,[sp,#0x10]         ;1077
000104  f8bd0012          LDRH     r0,[sp,#0x12]         ;1078
000108  f8bd100a          LDRH     r1,[sp,#0xa]          ;1078
00010c  4408              ADD      r0,r0,r1              ;1078
00010e  b200              SXTH     r0,r0                 ;1078
000110  f8ad0012          STRH     r0,[sp,#0x12]         ;1078
000114  f8bd0014          LDRH     r0,[sp,#0x14]         ;1079
000118  f8bd100c          LDRH     r1,[sp,#0xc]          ;1079
00011c  4408              ADD      r0,r0,r1              ;1079
00011e  b200              SXTH     r0,r0                 ;1079
000120  f8ad0014          STRH     r0,[sp,#0x14]         ;1079
000124  f8bd0010          LDRH     r0,[sp,#0x10]         ;1081
000128  0a00              LSRS     r0,r0,#8              ;1081
00012a  f88d0018          STRB     r0,[sp,#0x18]         ;1081
00012e  f8bd0010          LDRH     r0,[sp,#0x10]         ;1082
000132  b2c0              UXTB     r0,r0                 ;1082
000134  f88d0019          STRB     r0,[sp,#0x19]         ;1082
000138  f8bd0012          LDRH     r0,[sp,#0x12]         ;1083
00013c  0a00              LSRS     r0,r0,#8              ;1083
00013e  f88d001a          STRB     r0,[sp,#0x1a]         ;1083
000142  f8bd0012          LDRH     r0,[sp,#0x12]         ;1084
000146  b2c0              UXTB     r0,r0                 ;1084
000148  f88d001b          STRB     r0,[sp,#0x1b]         ;1084
00014c  f8bd0014          LDRH     r0,[sp,#0x14]         ;1085
000150  0a00              LSRS     r0,r0,#8              ;1085
000152  f88d001c          STRB     r0,[sp,#0x1c]         ;1085
000156  f8bd0014          LDRH     r0,[sp,#0x14]         ;1086
00015a  b2c0              UXTB     r0,r0                 ;1086
00015c  f88d001d          STRB     r0,[sp,#0x1d]         ;1086
000160  4906              LDR      r1,|L38.380|
000162  6849              LDR      r1,[r1,#4]            ;1088  ; st
000164  7808              LDRB     r0,[r1,#0]            ;1088
000166  ab06              ADD      r3,sp,#0x18           ;1088
000168  2206              MOVS     r2,#6                 ;1088
00016a  4611              MOV      r1,r2                 ;1088
00016c  f7fffffe          BL       MPU_Write_Len
000170  b110              CBZ      r0,|L38.376|
000172  f04f30ff          MOV      r0,#0xffffffff        ;1089
000176  e749              B        |L38.12|
                  |L38.376|
000178  2000              MOVS     r0,#0                 ;1090
00017a  e747              B        |L38.12|
;;;1092   
                          ENDP

                  |L38.380|
                          DCD      ||st||

                          AREA ||i.mpu_set_accel_fsr||, CODE, READONLY, ALIGN=2

                  mpu_set_accel_fsr PROC
;;;1250    */
;;;1251   int mpu_set_accel_fsr(unsigned char fsr)
000000  b538              PUSH     {r3-r5,lr}
;;;1252   {
000002  4604              MOV      r4,r0
;;;1253       unsigned char data;
;;;1254   
;;;1255       if (!(st.chip_cfg.sensors))
000004  481e              LDR      r0,|L39.128|
000006  7a80              LDRB     r0,[r0,#0xa]
000008  b910              CBNZ     r0,|L39.16|
;;;1256           return -1;
00000a  f04f30ff          MOV      r0,#0xffffffff
                  |L39.14|
;;;1257   
;;;1258       switch (fsr) {
;;;1259       case 2:
;;;1260           data = INV_FSR_2G << 3;
;;;1261           break;
;;;1262       case 4:
;;;1263           data = INV_FSR_4G << 3;
;;;1264           break;
;;;1265       case 8:
;;;1266           data = INV_FSR_8G << 3;
;;;1267           break;
;;;1268       case 16:
;;;1269           data = INV_FSR_16G << 3;
;;;1270           break;
;;;1271       default:
;;;1272           return -1;
;;;1273       }
;;;1274   
;;;1275       if (st.chip_cfg.accel_fsr == (data >> 3))
;;;1276           return 0;
;;;1277       if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, &data))
;;;1278           return -1;
;;;1279       st.chip_cfg.accel_fsr = data >> 3;
;;;1280       return 0;
;;;1281   }
00000e  bd38              POP      {r3-r5,pc}
                  |L39.16|
000010  2c02              CMP      r4,#2                 ;1258
000012  d006              BEQ      |L39.34|
000014  2c04              CMP      r4,#4                 ;1258
000016  d007              BEQ      |L39.40|
000018  2c08              CMP      r4,#8                 ;1258
00001a  d008              BEQ      |L39.46|
00001c  2c10              CMP      r4,#0x10              ;1258
00001e  d10c              BNE      |L39.58|
000020  e008              B        |L39.52|
                  |L39.34|
000022  2000              MOVS     r0,#0                 ;1260
000024  9000              STR      r0,[sp,#0]            ;1260
000026  e00b              B        |L39.64|
                  |L39.40|
000028  2008              MOVS     r0,#8                 ;1263
00002a  9000              STR      r0,[sp,#0]            ;1263
00002c  e008              B        |L39.64|
                  |L39.46|
00002e  2010              MOVS     r0,#0x10              ;1266
000030  9000              STR      r0,[sp,#0]            ;1266
000032  e005              B        |L39.64|
                  |L39.52|
000034  2018              MOVS     r0,#0x18              ;1269
000036  9000              STR      r0,[sp,#0]            ;1269
000038  e002              B        |L39.64|
                  |L39.58|
00003a  f04f30ff          MOV      r0,#0xffffffff        ;1272
00003e  e7e6              B        |L39.14|
                  |L39.64|
000040  bf00              NOP                            ;1261
000042  480f              LDR      r0,|L39.128|
000044  7a40              LDRB     r0,[r0,#9]            ;1275
000046  f89d1000          LDRB     r1,[sp,#0]            ;1275
00004a  ebb00fe1          CMP      r0,r1,ASR #3          ;1275
00004e  d101              BNE      |L39.84|
000050  2000              MOVS     r0,#0                 ;1276
000052  e7dc              B        |L39.14|
                  |L39.84|
000054  4a0a              LDR      r2,|L39.128|
000056  6812              LDR      r2,[r2,#0]            ;1277  ; st
000058  79d1              LDRB     r1,[r2,#7]            ;1277
00005a  4a09              LDR      r2,|L39.128|
00005c  6852              LDR      r2,[r2,#4]            ;1277  ; st
00005e  7810              LDRB     r0,[r2,#0]            ;1277
000060  466b              MOV      r3,sp                 ;1277
000062  2201              MOVS     r2,#1                 ;1277
000064  f7fffffe          BL       MPU_Write_Len
000068  b110              CBZ      r0,|L39.112|
00006a  f04f30ff          MOV      r0,#0xffffffff        ;1278
00006e  e7ce              B        |L39.14|
                  |L39.112|
000070  f89d0000          LDRB     r0,[sp,#0]            ;1279
000074  10c1              ASRS     r1,r0,#3              ;1279
000076  4802              LDR      r0,|L39.128|
000078  7241              STRB     r1,[r0,#9]            ;1279
00007a  2000              MOVS     r0,#0                 ;1280
00007c  e7c7              B        |L39.14|
;;;1282   
                          ENDP

00007e  0000              DCW      0x0000
                  |L39.128|
                          DCD      ||st||

                          AREA ||i.mpu_set_bypass||, CODE, READONLY, ALIGN=2

                  mpu_set_bypass PROC
;;;1821    */
;;;1822   int mpu_set_bypass(unsigned char bypass_on)
000000  b538              PUSH     {r3-r5,lr}
;;;1823   {
000002  4604              MOV      r4,r0
;;;1824       unsigned char tmp;
;;;1825   
;;;1826       if (st.chip_cfg.bypass_mode == bypass_on)
000004  4850              LDR      r0,|L40.328|
000006  7c80              LDRB     r0,[r0,#0x12]
000008  42a0              CMP      r0,r4
00000a  d101              BNE      |L40.16|
;;;1827           return 0;
00000c  2000              MOVS     r0,#0
                  |L40.14|
;;;1828   
;;;1829       if (bypass_on) {
;;;1830           if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
;;;1831               return -1;
;;;1832           tmp &= ~BIT_AUX_IF_EN;
;;;1833           if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
;;;1834               return -1;
;;;1835           delay_ms(3);
;;;1836           tmp = BIT_BYPASS_EN;
;;;1837           if (st.chip_cfg.active_low_int)
;;;1838               tmp |= BIT_ACTL;
;;;1839           if (st.chip_cfg.latched_int)
;;;1840               tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
;;;1841           if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
;;;1842               return -1;
;;;1843       } else {
;;;1844           /* Enable I2C master mode if compass is being used. */
;;;1845           if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
;;;1846               return -1;
;;;1847           if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
;;;1848               tmp |= BIT_AUX_IF_EN;
;;;1849           else
;;;1850               tmp &= ~BIT_AUX_IF_EN;
;;;1851           if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
;;;1852               return -1;
;;;1853           delay_ms(3);
;;;1854           if (st.chip_cfg.active_low_int)
;;;1855               tmp = BIT_ACTL;
;;;1856           else
;;;1857               tmp = 0;
;;;1858           if (st.chip_cfg.latched_int)
;;;1859               tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
;;;1860           if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
;;;1861               return -1;
;;;1862       }
;;;1863       st.chip_cfg.bypass_mode = bypass_on;
;;;1864       return 0;
;;;1865   }
00000e  bd38              POP      {r3-r5,pc}
                  |L40.16|
000010  2c00              CMP      r4,#0                 ;1829
000012  d046              BEQ      |L40.162|
000014  4a4c              LDR      r2,|L40.328|
000016  6812              LDR      r2,[r2,#0]            ;1830  ; st
000018  7911              LDRB     r1,[r2,#4]            ;1830
00001a  4a4b              LDR      r2,|L40.328|
00001c  6852              LDR      r2,[r2,#4]            ;1830  ; st
00001e  7810              LDRB     r0,[r2,#0]            ;1830
000020  466b              MOV      r3,sp                 ;1830
000022  2201              MOVS     r2,#1                 ;1830
000024  f7fffffe          BL       MPU_Read_Len
000028  b110              CBZ      r0,|L40.48|
00002a  f04f30ff          MOV      r0,#0xffffffff        ;1831
00002e  e7ee              B        |L40.14|
                  |L40.48|
000030  f89d0000          LDRB     r0,[sp,#0]            ;1832
000034  f0200020          BIC      r0,r0,#0x20           ;1832
000038  9000              STR      r0,[sp,#0]            ;1832
00003a  4a43              LDR      r2,|L40.328|
00003c  6812              LDR      r2,[r2,#0]            ;1833  ; st
00003e  7911              LDRB     r1,[r2,#4]            ;1833
000040  4a41              LDR      r2,|L40.328|
000042  6852              LDR      r2,[r2,#4]            ;1833  ; st
000044  7810              LDRB     r0,[r2,#0]            ;1833
000046  466b              MOV      r3,sp                 ;1833
000048  2201              MOVS     r2,#1                 ;1833
00004a  f7fffffe          BL       MPU_Write_Len
00004e  b110              CBZ      r0,|L40.86|
000050  f04f30ff          MOV      r0,#0xffffffff        ;1834
000054  e7db              B        |L40.14|
                  |L40.86|
000056  2003              MOVS     r0,#3                 ;1835
000058  f7fffffe          BL       delay_ms
00005c  2002              MOVS     r0,#2                 ;1836
00005e  9000              STR      r0,[sp,#0]            ;1836
000060  4839              LDR      r0,|L40.328|
000062  f8900022          LDRB     r0,[r0,#0x22]         ;1837
000066  b120              CBZ      r0,|L40.114|
000068  f89d0000          LDRB     r0,[sp,#0]            ;1838
00006c  f0400080          ORR      r0,r0,#0x80           ;1838
000070  9000              STR      r0,[sp,#0]            ;1838
                  |L40.114|
000072  4835              LDR      r0,|L40.328|
000074  f8900023          LDRB     r0,[r0,#0x23]         ;1839
000078  b120              CBZ      r0,|L40.132|
00007a  f89d0000          LDRB     r0,[sp,#0]            ;1840
00007e  f0400030          ORR      r0,r0,#0x30           ;1840
000082  9000              STR      r0,[sp,#0]            ;1840
                  |L40.132|
000084  4a30              LDR      r2,|L40.328|
000086  6812              LDR      r2,[r2,#0]            ;1841  ; st
000088  7d11              LDRB     r1,[r2,#0x14]         ;1841
00008a  4a2f              LDR      r2,|L40.328|
00008c  6852              LDR      r2,[r2,#4]            ;1841  ; st
00008e  7810              LDRB     r0,[r2,#0]            ;1841
000090  466b              MOV      r3,sp                 ;1841
000092  2201              MOVS     r2,#1                 ;1841
000094  f7fffffe          BL       MPU_Write_Len
000098  2800              CMP      r0,#0                 ;1841
00009a  d051              BEQ      |L40.320|
00009c  f04f30ff          MOV      r0,#0xffffffff        ;1842
0000a0  e7b5              B        |L40.14|
                  |L40.162|
0000a2  4a29              LDR      r2,|L40.328|
0000a4  6812              LDR      r2,[r2,#0]            ;1845  ; st
0000a6  7911              LDRB     r1,[r2,#4]            ;1845
0000a8  4a27              LDR      r2,|L40.328|
0000aa  6852              LDR      r2,[r2,#4]            ;1845  ; st
0000ac  7810              LDRB     r0,[r2,#0]            ;1845
0000ae  466b              MOV      r3,sp                 ;1845
0000b0  2201              MOVS     r2,#1                 ;1845
0000b2  f7fffffe          BL       MPU_Read_Len
0000b6  b110              CBZ      r0,|L40.190|
0000b8  f04f30ff          MOV      r0,#0xffffffff        ;1846
0000bc  e7a7              B        |L40.14|
                  |L40.190|
0000be  4822              LDR      r0,|L40.328|
0000c0  7a80              LDRB     r0,[r0,#0xa]          ;1847
0000c2  f0000001          AND      r0,r0,#1              ;1847
0000c6  b128              CBZ      r0,|L40.212|
0000c8  f89d0000          LDRB     r0,[sp,#0]            ;1848
0000cc  f0400020          ORR      r0,r0,#0x20           ;1848
0000d0  9000              STR      r0,[sp,#0]            ;1848
0000d2  e004              B        |L40.222|
                  |L40.212|
0000d4  f89d0000          LDRB     r0,[sp,#0]            ;1850
0000d8  f0200020          BIC      r0,r0,#0x20           ;1850
0000dc  9000              STR      r0,[sp,#0]            ;1850
                  |L40.222|
0000de  4a1a              LDR      r2,|L40.328|
0000e0  6812              LDR      r2,[r2,#0]            ;1851  ; st
0000e2  7911              LDRB     r1,[r2,#4]            ;1851
0000e4  4a18              LDR      r2,|L40.328|
0000e6  6852              LDR      r2,[r2,#4]            ;1851  ; st
0000e8  7810              LDRB     r0,[r2,#0]            ;1851
0000ea  466b              MOV      r3,sp                 ;1851
0000ec  2201              MOVS     r2,#1                 ;1851
0000ee  f7fffffe          BL       MPU_Write_Len
0000f2  b110              CBZ      r0,|L40.250|
0000f4  f04f30ff          MOV      r0,#0xffffffff        ;1852
0000f8  e789              B        |L40.14|
                  |L40.250|
0000fa  2003              MOVS     r0,#3                 ;1853
0000fc  f7fffffe          BL       delay_ms
000100  4811              LDR      r0,|L40.328|
000102  f8900022          LDRB     r0,[r0,#0x22]         ;1854
000106  b110              CBZ      r0,|L40.270|
000108  2080              MOVS     r0,#0x80              ;1855
00010a  9000              STR      r0,[sp,#0]            ;1855
00010c  e001              B        |L40.274|
                  |L40.270|
00010e  2000              MOVS     r0,#0                 ;1857
000110  9000              STR      r0,[sp,#0]            ;1857
                  |L40.274|
000112  480d              LDR      r0,|L40.328|
000114  f8900023          LDRB     r0,[r0,#0x23]         ;1858
000118  b120              CBZ      r0,|L40.292|
00011a  f89d0000          LDRB     r0,[sp,#0]            ;1859
00011e  f0400030          ORR      r0,r0,#0x30           ;1859
000122  9000              STR      r0,[sp,#0]            ;1859
                  |L40.292|
000124  4a08              LDR      r2,|L40.328|
000126  6812              LDR      r2,[r2,#0]            ;1860  ; st
000128  7d11              LDRB     r1,[r2,#0x14]         ;1860
00012a  4a07              LDR      r2,|L40.328|
00012c  6852              LDR      r2,[r2,#4]            ;1860  ; st
00012e  7810              LDRB     r0,[r2,#0]            ;1860
000130  466b              MOV      r3,sp                 ;1860
000132  2201              MOVS     r2,#1                 ;1860
000134  f7fffffe          BL       MPU_Write_Len
000138  b110              CBZ      r0,|L40.320|
00013a  f04f30ff          MOV      r0,#0xffffffff        ;1861
00013e  e766              B        |L40.14|
                  |L40.320|
000140  4801              LDR      r0,|L40.328|
000142  7484              STRB     r4,[r0,#0x12]         ;1863
000144  2000              MOVS     r0,#0                 ;1864
000146  e762              B        |L40.14|
;;;1866   
                          ENDP

                  |L40.328|
                          DCD      ||st||

                          AREA ||i.mpu_set_compass_sample_rate||, CODE, READONLY, ALIGN=1

                  mpu_set_compass_sample_rate PROC
;;;1440    */
;;;1441   int mpu_set_compass_sample_rate(unsigned short rate)
000000  4601              MOV      r1,r0
;;;1442   {
;;;1443   #ifdef AK89xx_SECONDARY
;;;1444       unsigned char div;
;;;1445       if (!rate || rate > st.chip_cfg.sample_rate || rate > MAX_COMPASS_SAMPLE_RATE)
;;;1446           return -1;
;;;1447   
;;;1448       div = st.chip_cfg.sample_rate / rate - 1;
;;;1449       if (i2c_write(st.hw->addr, st.reg->s4_ctrl, 1, &div))
;;;1450           return -1;
;;;1451       st.chip_cfg.compass_sample_rate = st.chip_cfg.sample_rate / (div + 1);
;;;1452       return 0;
;;;1453   #else
;;;1454       return -1;
000002  f04f30ff          MOV      r0,#0xffffffff
;;;1455   #endif
;;;1456   }
000006  4770              BX       lr
;;;1457   
                          ENDP


                          AREA ||i.mpu_set_dmp_state||, CODE, READONLY, ALIGN=2

                  mpu_set_dmp_state PROC
;;;2381    */
;;;2382   int mpu_set_dmp_state(unsigned char enable)
000000  b538              PUSH     {r3-r5,lr}
;;;2383   {
000002  4604              MOV      r4,r0
;;;2384       unsigned char tmp;
;;;2385       if (st.chip_cfg.dmp_on == enable)
000004  4821              LDR      r0,|L42.140|
000006  f8900024          LDRB     r0,[r0,#0x24]
00000a  42a0              CMP      r0,r4
00000c  d101              BNE      |L42.18|
;;;2386           return 0;
00000e  2000              MOVS     r0,#0
                  |L42.16|
;;;2387   
;;;2388       if (enable) {
;;;2389           if (!st.chip_cfg.dmp_loaded)
;;;2390               return -1;
;;;2391           /* Disable data ready interrupt. */
;;;2392           set_int_enable(0);
;;;2393           /* Disable bypass mode. */
;;;2394           mpu_set_bypass(0);
;;;2395           /* Keep constant sample rate, FIFO rate controlled by DMP. */
;;;2396           mpu_set_sample_rate(st.chip_cfg.dmp_sample_rate);
;;;2397           /* Remove FIFO elements. */
;;;2398           tmp = 0;
;;;2399           i2c_write(st.hw->addr, 0x23, 1, &tmp);
;;;2400           st.chip_cfg.dmp_on = 1;
;;;2401           /* Enable DMP interrupt. */
;;;2402           set_int_enable(1);
;;;2403           mpu_reset_fifo();
;;;2404       } else {
;;;2405           /* Disable DMP interrupt. */
;;;2406           set_int_enable(0);
;;;2407           /* Restore FIFO settings. */
;;;2408           tmp = st.chip_cfg.fifo_enable;
;;;2409           i2c_write(st.hw->addr, 0x23, 1, &tmp);
;;;2410           st.chip_cfg.dmp_on = 0;
;;;2411           mpu_reset_fifo();
;;;2412       }
;;;2413       return 0;
;;;2414   }
000010  bd38              POP      {r3-r5,pc}
                  |L42.18|
000012  b324              CBZ      r4,|L42.94|
000014  481d              LDR      r0,|L42.140|
000016  f8900025          LDRB     r0,[r0,#0x25]         ;2389
00001a  b910              CBNZ     r0,|L42.34|
00001c  f04f30ff          MOV      r0,#0xffffffff        ;2390
000020  e7f6              B        |L42.16|
                  |L42.34|
000022  2000              MOVS     r0,#0                 ;2392
000024  f7fffffe          BL       set_int_enable
000028  2000              MOVS     r0,#0                 ;2394
00002a  f7fffffe          BL       mpu_set_bypass
00002e  4917              LDR      r1,|L42.140|
000030  8cc8              LDRH     r0,[r1,#0x26]         ;2396
000032  f7fffffe          BL       mpu_set_sample_rate
000036  2000              MOVS     r0,#0                 ;2398
000038  9000              STR      r0,[sp,#0]            ;2398
00003a  4914              LDR      r1,|L42.140|
00003c  6849              LDR      r1,[r1,#4]            ;2399  ; st
00003e  7808              LDRB     r0,[r1,#0]            ;2399
000040  466b              MOV      r3,sp                 ;2399
000042  2201              MOVS     r2,#1                 ;2399
000044  2123              MOVS     r1,#0x23              ;2399
000046  f7fffffe          BL       MPU_Write_Len
00004a  2101              MOVS     r1,#1                 ;2400
00004c  480f              LDR      r0,|L42.140|
00004e  f8801024          STRB     r1,[r0,#0x24]         ;2400
000052  2001              MOVS     r0,#1                 ;2402
000054  f7fffffe          BL       set_int_enable
000058  f7fffffe          BL       mpu_reset_fifo
00005c  e013              B        |L42.134|
                  |L42.94|
00005e  2000              MOVS     r0,#0                 ;2406
000060  f7fffffe          BL       set_int_enable
000064  4809              LDR      r0,|L42.140|
000066  7c00              LDRB     r0,[r0,#0x10]         ;2408
000068  9000              STR      r0,[sp,#0]            ;2408
00006a  4908              LDR      r1,|L42.140|
00006c  6849              LDR      r1,[r1,#4]            ;2409  ; st
00006e  7808              LDRB     r0,[r1,#0]            ;2409
000070  466b              MOV      r3,sp                 ;2409
000072  2201              MOVS     r2,#1                 ;2409
000074  2123              MOVS     r1,#0x23              ;2409
000076  f7fffffe          BL       MPU_Write_Len
00007a  2100              MOVS     r1,#0                 ;2410
00007c  4803              LDR      r0,|L42.140|
00007e  f8801024          STRB     r1,[r0,#0x24]         ;2410
000082  f7fffffe          BL       mpu_reset_fifo
                  |L42.134|
000086  2000              MOVS     r0,#0                 ;2413
000088  e7c2              B        |L42.16|
;;;2415   
                          ENDP

00008a  0000              DCW      0x0000
                  |L42.140|
                          DCD      ||st||

                          AREA ||i.mpu_set_gyro_fsr||, CODE, READONLY, ALIGN=2

                  mpu_set_gyro_fsr PROC
;;;1185    */
;;;1186   int mpu_set_gyro_fsr(unsigned short fsr)
000000  b538              PUSH     {r3-r5,lr}
;;;1187   {
000002  4604              MOV      r4,r0
;;;1188       unsigned char data;
;;;1189   
;;;1190       if (!(st.chip_cfg.sensors))
000004  481f              LDR      r0,|L43.132|
000006  7a80              LDRB     r0,[r0,#0xa]
000008  b910              CBNZ     r0,|L43.16|
;;;1191           return -1;
00000a  f04f30ff          MOV      r0,#0xffffffff
                  |L43.14|
;;;1192   
;;;1193       switch (fsr) {
;;;1194       case 250:
;;;1195           data = INV_FSR_250DPS << 3;
;;;1196           break;
;;;1197       case 500:
;;;1198           data = INV_FSR_500DPS << 3;
;;;1199           break;
;;;1200       case 1000:
;;;1201           data = INV_FSR_1000DPS << 3;
;;;1202           break;
;;;1203       case 2000:
;;;1204           data = INV_FSR_2000DPS << 3;
;;;1205           break;
;;;1206       default:
;;;1207           return -1;
;;;1208       }
;;;1209   
;;;1210       if (st.chip_cfg.gyro_fsr == (data >> 3))
;;;1211           return 0;
;;;1212       if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, &data))
;;;1213           return -1;
;;;1214       st.chip_cfg.gyro_fsr = data >> 3;
;;;1215       return 0;
;;;1216   }
00000e  bd38              POP      {r3-r5,pc}
                  |L43.16|
000010  2cfa              CMP      r4,#0xfa              ;1193
000012  d009              BEQ      |L43.40|
000014  f5b47ffa          CMP      r4,#0x1f4             ;1193
000018  d009              BEQ      |L43.46|
00001a  f5b47f7a          CMP      r4,#0x3e8             ;1193
00001e  d009              BEQ      |L43.52|
000020  f5b46ffa          CMP      r4,#0x7d0             ;1193
000024  d10c              BNE      |L43.64|
000026  e008              B        |L43.58|
                  |L43.40|
000028  2000              MOVS     r0,#0                 ;1195
00002a  9000              STR      r0,[sp,#0]            ;1195
00002c  e00b              B        |L43.70|
                  |L43.46|
00002e  2008              MOVS     r0,#8                 ;1198
000030  9000              STR      r0,[sp,#0]            ;1198
000032  e008              B        |L43.70|
                  |L43.52|
000034  2010              MOVS     r0,#0x10              ;1201
000036  9000              STR      r0,[sp,#0]            ;1201
000038  e005              B        |L43.70|
                  |L43.58|
00003a  2018              MOVS     r0,#0x18              ;1204
00003c  9000              STR      r0,[sp,#0]            ;1204
00003e  e002              B        |L43.70|
                  |L43.64|
000040  f04f30ff          MOV      r0,#0xffffffff        ;1207
000044  e7e3              B        |L43.14|
                  |L43.70|
000046  bf00              NOP                            ;1196
000048  480e              LDR      r0,|L43.132|
00004a  7a00              LDRB     r0,[r0,#8]            ;1210  ; st
00004c  f89d1000          LDRB     r1,[sp,#0]            ;1210
000050  ebb00fe1          CMP      r0,r1,ASR #3          ;1210
000054  d101              BNE      |L43.90|
000056  2000              MOVS     r0,#0                 ;1211
000058  e7d9              B        |L43.14|
                  |L43.90|
00005a  4a0a              LDR      r2,|L43.132|
00005c  6812              LDR      r2,[r2,#0]            ;1212  ; st
00005e  7991              LDRB     r1,[r2,#6]            ;1212
000060  4a08              LDR      r2,|L43.132|
000062  6852              LDR      r2,[r2,#4]            ;1212  ; st
000064  7810              LDRB     r0,[r2,#0]            ;1212
000066  466b              MOV      r3,sp                 ;1212
000068  2201              MOVS     r2,#1                 ;1212
00006a  f7fffffe          BL       MPU_Write_Len
00006e  b110              CBZ      r0,|L43.118|
000070  f04f30ff          MOV      r0,#0xffffffff        ;1213
000074  e7cb              B        |L43.14|
                  |L43.118|
000076  f89d0000          LDRB     r0,[sp,#0]            ;1214
00007a  10c0              ASRS     r0,r0,#3              ;1214
00007c  4901              LDR      r1,|L43.132|
00007e  7208              STRB     r0,[r1,#8]            ;1214
000080  2000              MOVS     r0,#0                 ;1215
000082  e7c4              B        |L43.14|
;;;1217   
                          ENDP

                  |L43.132|
                          DCD      ||st||

                          AREA ||i.mpu_set_int_latched||, CODE, READONLY, ALIGN=2

                  mpu_set_int_latched PROC
;;;1883    */
;;;1884   int mpu_set_int_latched(unsigned char enable)
000000  b538              PUSH     {r3-r5,lr}
;;;1885   {
000002  4604              MOV      r4,r0
;;;1886       unsigned char tmp;
;;;1887       if (st.chip_cfg.latched_int == enable)
000004  4818              LDR      r0,|L44.104|
000006  f8900023          LDRB     r0,[r0,#0x23]
00000a  42a0              CMP      r0,r4
00000c  d101              BNE      |L44.18|
;;;1888           return 0;
00000e  2000              MOVS     r0,#0
                  |L44.16|
;;;1889   
;;;1890       if (enable)
;;;1891           tmp = BIT_LATCH_EN | BIT_ANY_RD_CLR;
;;;1892       else
;;;1893           tmp = 0;
;;;1894       if (st.chip_cfg.bypass_mode)
;;;1895           tmp |= BIT_BYPASS_EN;
;;;1896       if (st.chip_cfg.active_low_int)
;;;1897           tmp |= BIT_ACTL;
;;;1898       if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
;;;1899           return -1;
;;;1900       st.chip_cfg.latched_int = enable;
;;;1901       return 0;
;;;1902   }
000010  bd38              POP      {r3-r5,pc}
                  |L44.18|
000012  b114              CBZ      r4,|L44.26|
000014  2030              MOVS     r0,#0x30              ;1891
000016  9000              STR      r0,[sp,#0]            ;1891
000018  e001              B        |L44.30|
                  |L44.26|
00001a  2000              MOVS     r0,#0                 ;1893
00001c  9000              STR      r0,[sp,#0]            ;1893
                  |L44.30|
00001e  4812              LDR      r0,|L44.104|
000020  7c80              LDRB     r0,[r0,#0x12]         ;1894
000022  b120              CBZ      r0,|L44.46|
000024  f89d0000          LDRB     r0,[sp,#0]            ;1895
000028  f0400002          ORR      r0,r0,#2              ;1895
00002c  9000              STR      r0,[sp,#0]            ;1895
                  |L44.46|
00002e  480e              LDR      r0,|L44.104|
000030  f8900022          LDRB     r0,[r0,#0x22]         ;1896
000034  b120              CBZ      r0,|L44.64|
000036  f89d0000          LDRB     r0,[sp,#0]            ;1897
00003a  f0400080          ORR      r0,r0,#0x80           ;1897
00003e  9000              STR      r0,[sp,#0]            ;1897
                  |L44.64|
000040  4a09              LDR      r2,|L44.104|
000042  6812              LDR      r2,[r2,#0]            ;1898  ; st
000044  7d11              LDRB     r1,[r2,#0x14]         ;1898
000046  4a08              LDR      r2,|L44.104|
000048  6852              LDR      r2,[r2,#4]            ;1898  ; st
00004a  7810              LDRB     r0,[r2,#0]            ;1898
00004c  466b              MOV      r3,sp                 ;1898
00004e  2201              MOVS     r2,#1                 ;1898
000050  f7fffffe          BL       MPU_Write_Len
000054  b110              CBZ      r0,|L44.92|
000056  f04f30ff          MOV      r0,#0xffffffff        ;1899
00005a  e7d9              B        |L44.16|
                  |L44.92|
00005c  4802              LDR      r0,|L44.104|
00005e  f8804023          STRB     r4,[r0,#0x23]         ;1900
000062  2000              MOVS     r0,#0                 ;1901
000064  e7d4              B        |L44.16|
;;;1903   
                          ENDP

000066  0000              DCW      0x0000
                  |L44.104|
                          DCD      ||st||

                          AREA ||i.mpu_set_int_level||, CODE, READONLY, ALIGN=2

                  mpu_set_int_level PROC
;;;1871    */
;;;1872   int mpu_set_int_level(unsigned char active_low)
000000  4601              MOV      r1,r0
;;;1873   {
;;;1874       st.chip_cfg.active_low_int = active_low;
000002  4802              LDR      r0,|L45.12|
000004  f8801022          STRB     r1,[r0,#0x22]
;;;1875       return 0;
000008  2000              MOVS     r0,#0
;;;1876   }
00000a  4770              BX       lr
;;;1877   
                          ENDP

                  |L45.12|
                          DCD      ||st||

                          AREA ||i.mpu_set_lpf||, CODE, READONLY, ALIGN=2

                  mpu_set_lpf PROC
;;;1323    */
;;;1324   int mpu_set_lpf(unsigned short lpf)
000000  b538              PUSH     {r3-r5,lr}
;;;1325   {
000002  4604              MOV      r4,r0
;;;1326       unsigned char data;
;;;1327   
;;;1328       if (!(st.chip_cfg.sensors))
000004  481e              LDR      r0,|L46.128|
000006  7a80              LDRB     r0,[r0,#0xa]
000008  b910              CBNZ     r0,|L46.16|
;;;1329           return -1;
00000a  f04f30ff          MOV      r0,#0xffffffff
                  |L46.14|
;;;1330   
;;;1331       if (lpf >= 188)
;;;1332           data = INV_FILTER_188HZ;
;;;1333       else if (lpf >= 98)
;;;1334           data = INV_FILTER_98HZ;
;;;1335       else if (lpf >= 42)
;;;1336           data = INV_FILTER_42HZ;
;;;1337       else if (lpf >= 20)
;;;1338           data = INV_FILTER_20HZ;
;;;1339       else if (lpf >= 10)
;;;1340           data = INV_FILTER_10HZ;
;;;1341       else
;;;1342           data = INV_FILTER_5HZ;
;;;1343   
;;;1344       if (st.chip_cfg.lpf == data)
;;;1345           return 0;
;;;1346       if (i2c_write(st.hw->addr, st.reg->lpf, 1, &data))
;;;1347           return -1;
;;;1348       st.chip_cfg.lpf = data;
;;;1349       return 0;
;;;1350   }
00000e  bd38              POP      {r3-r5,pc}
                  |L46.16|
000010  2cbc              CMP      r4,#0xbc              ;1331
000012  db02              BLT      |L46.26|
000014  2001              MOVS     r0,#1                 ;1332
000016  9000              STR      r0,[sp,#0]            ;1332
000018  e015              B        |L46.70|
                  |L46.26|
00001a  2c62              CMP      r4,#0x62              ;1333
00001c  db02              BLT      |L46.36|
00001e  2002              MOVS     r0,#2                 ;1334
000020  9000              STR      r0,[sp,#0]            ;1334
000022  e010              B        |L46.70|
                  |L46.36|
000024  2c2a              CMP      r4,#0x2a              ;1335
000026  db02              BLT      |L46.46|
000028  2003              MOVS     r0,#3                 ;1336
00002a  9000              STR      r0,[sp,#0]            ;1336
00002c  e00b              B        |L46.70|
                  |L46.46|
00002e  2c14              CMP      r4,#0x14              ;1337
000030  db02              BLT      |L46.56|
000032  2004              MOVS     r0,#4                 ;1338
000034  9000              STR      r0,[sp,#0]            ;1338
000036  e006              B        |L46.70|
                  |L46.56|
000038  2c0a              CMP      r4,#0xa               ;1339
00003a  db02              BLT      |L46.66|
00003c  2005              MOVS     r0,#5                 ;1340
00003e  9000              STR      r0,[sp,#0]            ;1340
000040  e001              B        |L46.70|
                  |L46.66|
000042  2006              MOVS     r0,#6                 ;1342
000044  9000              STR      r0,[sp,#0]            ;1342
                  |L46.70|
000046  480e              LDR      r0,|L46.128|
000048  7ac0              LDRB     r0,[r0,#0xb]          ;1344
00004a  f89d1000          LDRB     r1,[sp,#0]            ;1344
00004e  4288              CMP      r0,r1                 ;1344
000050  d101              BNE      |L46.86|
000052  2000              MOVS     r0,#0                 ;1345
000054  e7db              B        |L46.14|
                  |L46.86|
000056  4a0a              LDR      r2,|L46.128|
000058  6812              LDR      r2,[r2,#0]            ;1346  ; st
00005a  7891              LDRB     r1,[r2,#2]            ;1346
00005c  4a08              LDR      r2,|L46.128|
00005e  6852              LDR      r2,[r2,#4]            ;1346  ; st
000060  7810              LDRB     r0,[r2,#0]            ;1346
000062  466b              MOV      r3,sp                 ;1346
000064  2201              MOVS     r2,#1                 ;1346
000066  f7fffffe          BL       MPU_Write_Len
00006a  b110              CBZ      r0,|L46.114|
00006c  f04f30ff          MOV      r0,#0xffffffff        ;1347
000070  e7cd              B        |L46.14|
                  |L46.114|
000072  f89d1000          LDRB     r1,[sp,#0]            ;1348
000076  4802              LDR      r0,|L46.128|
000078  72c1              STRB     r1,[r0,#0xb]          ;1348
00007a  2000              MOVS     r0,#0                 ;1349
00007c  e7c7              B        |L46.14|
;;;1351   
                          ENDP

00007e  0000              DCW      0x0000
                  |L46.128|
                          DCD      ||st||

                          AREA ||i.mpu_set_sample_rate||, CODE, READONLY, ALIGN=2

                  mpu_set_sample_rate PROC
;;;1371    */
;;;1372   int mpu_set_sample_rate(unsigned short rate)
000000  b538              PUSH     {r3-r5,lr}
;;;1373   {
000002  4604              MOV      r4,r0
;;;1374       unsigned char data;
;;;1375   
;;;1376       if (!(st.chip_cfg.sensors))
000004  4824              LDR      r0,|L47.152|
000006  7a80              LDRB     r0,[r0,#0xa]
000008  b910              CBNZ     r0,|L47.16|
;;;1377           return -1;
00000a  f04f30ff          MOV      r0,#0xffffffff
                  |L47.14|
;;;1378   
;;;1379       if (st.chip_cfg.dmp_on)
;;;1380           return -1;
;;;1381       else {
;;;1382           if (st.chip_cfg.lp_accel_mode) {
;;;1383               if (rate && (rate <= 40)) {
;;;1384                   /* Just stay in low-power accel mode. */
;;;1385                   mpu_lp_accel_mode(rate);
;;;1386                   return 0;
;;;1387               }
;;;1388               /* Requested rate exceeds the allowed frequencies in LP accel mode,
;;;1389                * switch back to full-power mode.
;;;1390                */
;;;1391               mpu_lp_accel_mode(0);
;;;1392           }
;;;1393           if (rate < 4)
;;;1394               rate = 4;
;;;1395           else if (rate > 1000)
;;;1396               rate = 1000;
;;;1397   
;;;1398           data = 1000 / rate - 1;
;;;1399           if (i2c_write(st.hw->addr, st.reg->rate_div, 1, &data))
;;;1400               return -1;
;;;1401   
;;;1402           st.chip_cfg.sample_rate = 1000 / (1 + data);
;;;1403   
;;;1404   #ifdef AK89xx_SECONDARY
;;;1405           mpu_set_compass_sample_rate(min(st.chip_cfg.compass_sample_rate, MAX_COMPASS_SAMPLE_RATE));
;;;1406   #endif
;;;1407   
;;;1408           /* Automatically set LPF to 1/2 sampling rate. */
;;;1409           mpu_set_lpf(st.chip_cfg.sample_rate >> 1);
;;;1410           return 0;
;;;1411       }
;;;1412   }
00000e  bd38              POP      {r3-r5,pc}
                  |L47.16|
000010  4821              LDR      r0,|L47.152|
000012  f8900024          LDRB     r0,[r0,#0x24]         ;1379
000016  b110              CBZ      r0,|L47.30|
000018  f04f30ff          MOV      r0,#0xffffffff        ;1380
00001c  e7f7              B        |L47.14|
                  |L47.30|
00001e  481e              LDR      r0,|L47.152|
000020  7d00              LDRB     r0,[r0,#0x14]         ;1382
000022  b150              CBZ      r0,|L47.58|
000024  b134              CBZ      r4,|L47.52|
000026  2c28              CMP      r4,#0x28              ;1383
000028  dc04              BGT      |L47.52|
00002a  b2e0              UXTB     r0,r4                 ;1385
00002c  f7fffffe          BL       mpu_lp_accel_mode
000030  2000              MOVS     r0,#0                 ;1386
000032  e7ec              B        |L47.14|
                  |L47.52|
000034  2000              MOVS     r0,#0                 ;1391
000036  f7fffffe          BL       mpu_lp_accel_mode
                  |L47.58|
00003a  2c04              CMP      r4,#4                 ;1393
00003c  da01              BGE      |L47.66|
00003e  2404              MOVS     r4,#4                 ;1394
000040  e004              B        |L47.76|
                  |L47.66|
000042  f5b47f7a          CMP      r4,#0x3e8             ;1395
000046  dd01              BLE      |L47.76|
000048  f44f747a          MOV      r4,#0x3e8             ;1396
                  |L47.76|
00004c  f44f707a          MOV      r0,#0x3e8             ;1398
000050  fb90f0f4          SDIV     r0,r0,r4              ;1398
000054  1e40              SUBS     r0,r0,#1              ;1398
000056  b2c0              UXTB     r0,r0                 ;1398
000058  9000              STR      r0,[sp,#0]            ;1398
00005a  4a0f              LDR      r2,|L47.152|
00005c  6812              LDR      r2,[r2,#0]            ;1399  ; st
00005e  7851              LDRB     r1,[r2,#1]            ;1399
000060  4a0d              LDR      r2,|L47.152|
000062  6852              LDR      r2,[r2,#4]            ;1399  ; st
000064  7810              LDRB     r0,[r2,#0]            ;1399
000066  466b              MOV      r3,sp                 ;1399
000068  2201              MOVS     r2,#1                 ;1399
00006a  f7fffffe          BL       MPU_Write_Len
00006e  b110              CBZ      r0,|L47.118|
000070  f04f30ff          MOV      r0,#0xffffffff        ;1400
000074  e7cb              B        |L47.14|
                  |L47.118|
000076  f89d0000          LDRB     r0,[sp,#0]            ;1402
00007a  1c40              ADDS     r0,r0,#1              ;1402
00007c  f44f717a          MOV      r1,#0x3e8             ;1402
000080  fb91f0f0          SDIV     r0,r1,r0              ;1402
000084  b281              UXTH     r1,r0                 ;1402
000086  4804              LDR      r0,|L47.152|
000088  81c1              STRH     r1,[r0,#0xe]          ;1402
00008a  4601              MOV      r1,r0                 ;1409
00008c  89c9              LDRH     r1,[r1,#0xe]          ;1409
00008e  1048              ASRS     r0,r1,#1              ;1409
000090  f7fffffe          BL       mpu_set_lpf
000094  2000              MOVS     r0,#0                 ;1410
000096  e7ba              B        |L47.14|
;;;1413   
                          ENDP

                  |L47.152|
                          DCD      ||st||

                          AREA ||i.mpu_set_sensors||, CODE, READONLY, ALIGN=2

                  mpu_set_sensors PROC
;;;1596    */
;;;1597   int mpu_set_sensors(unsigned char sensors)
000000  b538              PUSH     {r3-r5,lr}
;;;1598   {
000002  4604              MOV      r4,r0
;;;1599       unsigned char data;
;;;1600   #ifdef AK89xx_SECONDARY
;;;1601       unsigned char user_ctrl;
;;;1602   #endif
;;;1603   
;;;1604       if (sensors & INV_XYZ_GYRO)
000004  f0040070          AND      r0,r4,#0x70
000008  b110              CBZ      r0,|L48.16|
;;;1605           data = INV_CLK_PLL;
00000a  2001              MOVS     r0,#1
00000c  9000              STR      r0,[sp,#0]
00000e  e005              B        |L48.28|
                  |L48.16|
;;;1606       else if (sensors)
000010  b114              CBZ      r4,|L48.24|
;;;1607           data = 0;
000012  2000              MOVS     r0,#0
000014  9000              STR      r0,[sp,#0]
000016  e001              B        |L48.28|
                  |L48.24|
;;;1608       else
;;;1609           data = BIT_SLEEP;
000018  2040              MOVS     r0,#0x40
00001a  9000              STR      r0,[sp,#0]
                  |L48.28|
;;;1610       if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &data)) {
00001c  4a2b              LDR      r2,|L48.204|
00001e  6812              LDR      r2,[r2,#0]  ; st
000020  7c91              LDRB     r1,[r2,#0x12]
000022  4a2a              LDR      r2,|L48.204|
000024  6852              LDR      r2,[r2,#4]  ; st
000026  7810              LDRB     r0,[r2,#0]
000028  466b              MOV      r3,sp
00002a  2201              MOVS     r2,#1
00002c  f7fffffe          BL       MPU_Write_Len
000030  b120              CBZ      r0,|L48.60|
;;;1611           st.chip_cfg.sensors = 0;
000032  2100              MOVS     r1,#0
000034  4825              LDR      r0,|L48.204|
000036  7281              STRB     r1,[r0,#0xa]
;;;1612           return -1;
000038  1e48              SUBS     r0,r1,#1
                  |L48.58|
;;;1613       }
;;;1614       st.chip_cfg.clk_src = data & ~BIT_SLEEP;
;;;1615   
;;;1616       data = 0;
;;;1617       if (!(sensors & INV_X_GYRO))
;;;1618           data |= BIT_STBY_XG;
;;;1619       if (!(sensors & INV_Y_GYRO))
;;;1620           data |= BIT_STBY_YG;
;;;1621       if (!(sensors & INV_Z_GYRO))
;;;1622           data |= BIT_STBY_ZG;
;;;1623       if (!(sensors & INV_XYZ_ACCEL))
;;;1624           data |= BIT_STBY_XYZA;
;;;1625       if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_2, 1, &data)) {
;;;1626           st.chip_cfg.sensors = 0;
;;;1627           return -1;
;;;1628       }
;;;1629   
;;;1630       if (sensors && (sensors != INV_XYZ_ACCEL))
;;;1631           /* Latched interrupts only used in LP accel mode. */
;;;1632           mpu_set_int_latched(0);
;;;1633   
;;;1634   #ifdef AK89xx_SECONDARY
;;;1635   #ifdef AK89xx_BYPASS
;;;1636       if (sensors & INV_XYZ_COMPASS)
;;;1637           mpu_set_bypass(1);
;;;1638       else
;;;1639           mpu_set_bypass(0);
;;;1640   #else
;;;1641       if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
;;;1642           return -1;
;;;1643       /* Handle AKM power management. */
;;;1644       if (sensors & INV_XYZ_COMPASS) {
;;;1645           data = AKM_SINGLE_MEASUREMENT;
;;;1646           user_ctrl |= BIT_AUX_IF_EN;
;;;1647       } else {
;;;1648           data = AKM_POWER_DOWN;
;;;1649           user_ctrl &= ~BIT_AUX_IF_EN;
;;;1650       }
;;;1651       if (st.chip_cfg.dmp_on)
;;;1652           user_ctrl |= BIT_DMP_EN;
;;;1653       else
;;;1654           user_ctrl &= ~BIT_DMP_EN;
;;;1655       if (i2c_write(st.hw->addr, st.reg->s1_do, 1, &data))
;;;1656           return -1;
;;;1657       /* Enable/disable I2C master mode. */
;;;1658       if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
;;;1659           return -1;
;;;1660   #endif
;;;1661   #endif
;;;1662   
;;;1663       st.chip_cfg.sensors = sensors;
;;;1664       st.chip_cfg.lp_accel_mode = 0;
;;;1665       delay_ms(50);
;;;1666       return 0;
;;;1667   }
00003a  bd38              POP      {r3-r5,pc}
                  |L48.60|
00003c  f89d0000          LDRB     r0,[sp,#0]            ;1614
000040  f0200140          BIC      r1,r0,#0x40           ;1614
000044  4821              LDR      r0,|L48.204|
000046  7301              STRB     r1,[r0,#0xc]          ;1614
000048  2000              MOVS     r0,#0                 ;1616
00004a  9000              STR      r0,[sp,#0]            ;1616
00004c  f0040040          AND      r0,r4,#0x40           ;1617
000050  b920              CBNZ     r0,|L48.92|
000052  f89d0000          LDRB     r0,[sp,#0]            ;1618
000056  f0400004          ORR      r0,r0,#4              ;1618
00005a  9000              STR      r0,[sp,#0]            ;1618
                  |L48.92|
00005c  f0040020          AND      r0,r4,#0x20           ;1619
000060  b920              CBNZ     r0,|L48.108|
000062  f89d0000          LDRB     r0,[sp,#0]            ;1620
000066  f0400002          ORR      r0,r0,#2              ;1620
00006a  9000              STR      r0,[sp,#0]            ;1620
                  |L48.108|
00006c  f0040010          AND      r0,r4,#0x10           ;1621
000070  b920              CBNZ     r0,|L48.124|
000072  f89d0000          LDRB     r0,[sp,#0]            ;1622
000076  f0400001          ORR      r0,r0,#1              ;1622
00007a  9000              STR      r0,[sp,#0]            ;1622
                  |L48.124|
00007c  f0040008          AND      r0,r4,#8              ;1623
000080  b920              CBNZ     r0,|L48.140|
000082  f89d0000          LDRB     r0,[sp,#0]            ;1624
000086  f0400038          ORR      r0,r0,#0x38           ;1624
00008a  9000              STR      r0,[sp,#0]            ;1624
                  |L48.140|
00008c  4a0f              LDR      r2,|L48.204|
00008e  6812              LDR      r2,[r2,#0]            ;1625  ; st
000090  7cd1              LDRB     r1,[r2,#0x13]         ;1625
000092  4a0e              LDR      r2,|L48.204|
000094  6852              LDR      r2,[r2,#4]            ;1625  ; st
000096  7810              LDRB     r0,[r2,#0]            ;1625
000098  466b              MOV      r3,sp                 ;1625
00009a  2201              MOVS     r2,#1                 ;1625
00009c  f7fffffe          BL       MPU_Write_Len
0000a0  b120              CBZ      r0,|L48.172|
0000a2  2100              MOVS     r1,#0                 ;1626
0000a4  4809              LDR      r0,|L48.204|
0000a6  7281              STRB     r1,[r0,#0xa]          ;1626
0000a8  1e48              SUBS     r0,r1,#1              ;1627
0000aa  e7c6              B        |L48.58|
                  |L48.172|
0000ac  b124              CBZ      r4,|L48.184|
0000ae  2c08              CMP      r4,#8                 ;1630
0000b0  d002              BEQ      |L48.184|
0000b2  2000              MOVS     r0,#0                 ;1632
0000b4  f7fffffe          BL       mpu_set_int_latched
                  |L48.184|
0000b8  4804              LDR      r0,|L48.204|
0000ba  7284              STRB     r4,[r0,#0xa]          ;1663
0000bc  2100              MOVS     r1,#0                 ;1664
0000be  7501              STRB     r1,[r0,#0x14]         ;1664
0000c0  2032              MOVS     r0,#0x32              ;1665
0000c2  f7fffffe          BL       delay_ms
0000c6  2000              MOVS     r0,#0                 ;1666
0000c8  e7b7              B        |L48.58|
;;;1668   
                          ENDP

0000ca  0000              DCW      0x0000
                  |L48.204|
                          DCD      ||st||

                          AREA ||i.mpu_write_mem||, CODE, READONLY, ALIGN=2

                  mpu_write_mem PROC
;;;2275    */
;;;2276   int mpu_write_mem(unsigned short mem_addr, unsigned short length,
000000  b5f8              PUSH     {r3-r7,lr}
;;;2277           unsigned char *data)
;;;2278   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;2279       unsigned char tmp[2];
;;;2280   
;;;2281       if (!data)
000008  b916              CBNZ     r6,|L49.16|
;;;2282           return -1;
00000a  f04f30ff          MOV      r0,#0xffffffff
                  |L49.14|
;;;2283       if (!st.chip_cfg.sensors)
;;;2284           return -1;
;;;2285   
;;;2286       tmp[0] = (unsigned char)(mem_addr >> 8);
;;;2287       tmp[1] = (unsigned char)(mem_addr & 0xFF);
;;;2288   
;;;2289       /* Check bank boundaries. */
;;;2290       if (tmp[1] + length > st.hw->bank_size)
;;;2291           return -1;
;;;2292   
;;;2293       if (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))
;;;2294           return -1;
;;;2295       if (i2c_write(st.hw->addr, st.reg->mem_r_w, length, data))
;;;2296           return -1;
;;;2297       return 0;
;;;2298   }
00000e  bdf8              POP      {r3-r7,pc}
                  |L49.16|
000010  481a              LDR      r0,|L49.124|
000012  7a80              LDRB     r0,[r0,#0xa]          ;2283
000014  b910              CBNZ     r0,|L49.28|
000016  f04f30ff          MOV      r0,#0xffffffff        ;2284
00001a  e7f8              B        |L49.14|
                  |L49.28|
00001c  1220              ASRS     r0,r4,#8              ;2286
00001e  f88d0000          STRB     r0,[sp,#0]            ;2286
000022  b2e0              UXTB     r0,r4                 ;2287
000024  f88d0001          STRB     r0,[sp,#1]            ;2287
000028  f89d0001          LDRB     r0,[sp,#1]            ;2290
00002c  4428              ADD      r0,r0,r5              ;2290
00002e  4913              LDR      r1,|L49.124|
000030  6849              LDR      r1,[r1,#4]            ;2290  ; st
000032  8949              LDRH     r1,[r1,#0xa]          ;2290
000034  4288              CMP      r0,r1                 ;2290
000036  dd02              BLE      |L49.62|
000038  f04f30ff          MOV      r0,#0xffffffff        ;2291
00003c  e7e7              B        |L49.14|
                  |L49.62|
00003e  4a0f              LDR      r2,|L49.124|
000040  6812              LDR      r2,[r2,#0]            ;2293  ; st
000042  7e11              LDRB     r1,[r2,#0x18]         ;2293
000044  4a0d              LDR      r2,|L49.124|
000046  6852              LDR      r2,[r2,#4]            ;2293  ; st
000048  7810              LDRB     r0,[r2,#0]            ;2293
00004a  466b              MOV      r3,sp                 ;2293
00004c  2202              MOVS     r2,#2                 ;2293
00004e  f7fffffe          BL       MPU_Write_Len
000052  b110              CBZ      r0,|L49.90|
000054  f04f30ff          MOV      r0,#0xffffffff        ;2294
000058  e7d9              B        |L49.14|
                  |L49.90|
00005a  b2ea              UXTB     r2,r5                 ;2295
00005c  4b07              LDR      r3,|L49.124|
00005e  681b              LDR      r3,[r3,#0]            ;2295  ; st
000060  7d59              LDRB     r1,[r3,#0x15]         ;2295
000062  4b06              LDR      r3,|L49.124|
000064  685b              LDR      r3,[r3,#4]            ;2295  ; st
000066  7818              LDRB     r0,[r3,#0]            ;2295
000068  4633              MOV      r3,r6                 ;2295
00006a  f7fffffe          BL       MPU_Write_Len
00006e  b110              CBZ      r0,|L49.118|
000070  f04f30ff          MOV      r0,#0xffffffff        ;2296
000074  e7cb              B        |L49.14|
                  |L49.118|
000076  2000              MOVS     r0,#0                 ;2297
000078  e7c9              B        |L49.14|
;;;2299   
                          ENDP

00007a  0000              DCW      0x0000
                  |L49.124|
                          DCD      ||st||

                          AREA ||i.run_self_test||, CODE, READONLY, ALIGN=1

                  run_self_test PROC
;;;2878   //    ÆäËû,Ê§°Ü
;;;2879   u8 run_self_test(void)
000000  b570              PUSH     {r4-r6,lr}
;;;2880   {
000002  b088              SUB      sp,sp,#0x20
;;;2881   	int result;
;;;2882   	//char test_packet[4] = {0};
;;;2883   	long gyro[3], accel[3]; 
;;;2884   	result = mpu_run_self_test(gyro, accel);
000004  a902              ADD      r1,sp,#8
000006  a805              ADD      r0,sp,#0x14
000008  f7fffffe          BL       mpu_run_self_test
00000c  4604              MOV      r4,r0
;;;2885   	if (result == 0x7) 
00000e  2c07              CMP      r4,#7
000010  d13e              BNE      |L50.144|
;;;2886   	{
;;;2887   		/* Test passed. We can trust the gyro data here, so let's push it down
;;;2888   		* to the DMP.
;;;2889   		*/
;;;2890   		float sens;
;;;2891   		unsigned short accel_sens;
;;;2892   		mpu_get_gyro_sens(&sens);
000012  a801              ADD      r0,sp,#4
000014  f7fffffe          BL       mpu_get_gyro_sens
;;;2893   		gyro[0] = (long)(gyro[0] * sens);
000018  9805              LDR      r0,[sp,#0x14]
00001a  f7fffffe          BL       __aeabi_i2f
00001e  4606              MOV      r6,r0
000020  9901              LDR      r1,[sp,#4]
000022  f7fffffe          BL       __aeabi_fmul
000026  4605              MOV      r5,r0
000028  f7fffffe          BL       __aeabi_f2iz
00002c  9005              STR      r0,[sp,#0x14]
;;;2894   		gyro[1] = (long)(gyro[1] * sens);
00002e  9806              LDR      r0,[sp,#0x18]
000030  f7fffffe          BL       __aeabi_i2f
000034  4606              MOV      r6,r0
000036  9901              LDR      r1,[sp,#4]
000038  f7fffffe          BL       __aeabi_fmul
00003c  4605              MOV      r5,r0
00003e  f7fffffe          BL       __aeabi_f2iz
000042  9006              STR      r0,[sp,#0x18]
;;;2895   		gyro[2] = (long)(gyro[2] * sens);
000044  9807              LDR      r0,[sp,#0x1c]
000046  f7fffffe          BL       __aeabi_i2f
00004a  4606              MOV      r6,r0
00004c  9901              LDR      r1,[sp,#4]
00004e  f7fffffe          BL       __aeabi_fmul
000052  4605              MOV      r5,r0
000054  f7fffffe          BL       __aeabi_f2iz
000058  9007              STR      r0,[sp,#0x1c]
;;;2896   		dmp_set_gyro_bias(gyro);
00005a  a805              ADD      r0,sp,#0x14
00005c  f7fffffe          BL       dmp_set_gyro_bias
;;;2897   		mpu_get_accel_sens(&accel_sens);
000060  4668              MOV      r0,sp
000062  f7fffffe          BL       mpu_get_accel_sens
;;;2898   		accel[0] *= accel_sens;
000066  f8bd1000          LDRH     r1,[sp,#0]
00006a  9802              LDR      r0,[sp,#8]
00006c  4348              MULS     r0,r1,r0
00006e  9002              STR      r0,[sp,#8]
;;;2899   		accel[1] *= accel_sens;
000070  f8bd1000          LDRH     r1,[sp,#0]
000074  9803              LDR      r0,[sp,#0xc]
000076  4348              MULS     r0,r1,r0
000078  9003              STR      r0,[sp,#0xc]
;;;2900   		accel[2] *= accel_sens;
00007a  f8bd1000          LDRH     r1,[sp,#0]
00007e  9804              LDR      r0,[sp,#0x10]
000080  4348              MULS     r0,r1,r0
000082  9004              STR      r0,[sp,#0x10]
;;;2901   		dmp_set_accel_bias(accel);
000084  a802              ADD      r0,sp,#8
000086  f7fffffe          BL       dmp_set_accel_bias
;;;2902   		return 0;
00008a  2000              MOVS     r0,#0
                  |L50.140|
;;;2903   	}else return 1;
;;;2904   }
00008c  b008              ADD      sp,sp,#0x20
00008e  bd70              POP      {r4-r6,pc}
                  |L50.144|
000090  2001              MOVS     r0,#1                 ;2903
000092  e7fb              B        |L50.140|
;;;2905   //ÍÓÂÝÒÇ·½Ïò¿ØÖÆ
                          ENDP


                          AREA ||i.set_int_enable||, CODE, READONLY, ALIGN=2

                  set_int_enable PROC
;;;685     */
;;;686    static int set_int_enable(unsigned char enable)
000000  b538              PUSH     {r3-r5,lr}
;;;687    {
000002  4604              MOV      r4,r0
;;;688        unsigned char tmp;
;;;689    
;;;690        if (st.chip_cfg.dmp_on) {
000004  4821              LDR      r0,|L51.140|
000006  f8900024          LDRB     r0,[r0,#0x24]
00000a  b1c0              CBZ      r0,|L51.62|
;;;691            if (enable)
00000c  b114              CBZ      r4,|L51.20|
;;;692                tmp = BIT_DMP_INT_EN;
00000e  2002              MOVS     r0,#2
000010  9000              STR      r0,[sp,#0]
000012  e001              B        |L51.24|
                  |L51.20|
;;;693            else
;;;694                tmp = 0x00;
000014  2000              MOVS     r0,#0
000016  9000              STR      r0,[sp,#0]
                  |L51.24|
;;;695            if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
000018  4a1c              LDR      r2,|L51.140|
00001a  6812              LDR      r2,[r2,#0]  ; st
00001c  7bd1              LDRB     r1,[r2,#0xf]
00001e  4a1b              LDR      r2,|L51.140|
000020  6852              LDR      r2,[r2,#4]  ; st
000022  7810              LDRB     r0,[r2,#0]
000024  466b              MOV      r3,sp
000026  2201              MOVS     r2,#1
000028  f7fffffe          BL       MPU_Write_Len
00002c  b110              CBZ      r0,|L51.52|
;;;696                return -1;
00002e  f04f30ff          MOV      r0,#0xffffffff
                  |L51.50|
;;;697            st.chip_cfg.int_enable = tmp;
;;;698        } else {
;;;699            if (!st.chip_cfg.sensors)
;;;700                return -1;
;;;701            if (enable && st.chip_cfg.int_enable)
;;;702                return 0;
;;;703            if (enable)
;;;704                tmp = BIT_DATA_RDY_EN;
;;;705            else
;;;706                tmp = 0x00;
;;;707            if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
;;;708                return -1;
;;;709            st.chip_cfg.int_enable = tmp;
;;;710        }
;;;711        return 0;
;;;712    }
000032  bd38              POP      {r3-r5,pc}
                  |L51.52|
000034  f89d1000          LDRB     r1,[sp,#0]            ;697
000038  4814              LDR      r0,|L51.140|
00003a  7441              STRB     r1,[r0,#0x11]         ;697
00003c  e023              B        |L51.134|
                  |L51.62|
00003e  4813              LDR      r0,|L51.140|
000040  7a80              LDRB     r0,[r0,#0xa]          ;699
000042  b910              CBNZ     r0,|L51.74|
000044  f04f30ff          MOV      r0,#0xffffffff        ;700
000048  e7f3              B        |L51.50|
                  |L51.74|
00004a  b124              CBZ      r4,|L51.86|
00004c  480f              LDR      r0,|L51.140|
00004e  7c40              LDRB     r0,[r0,#0x11]         ;701
000050  b108              CBZ      r0,|L51.86|
000052  2000              MOVS     r0,#0                 ;702
000054  e7ed              B        |L51.50|
                  |L51.86|
000056  b114              CBZ      r4,|L51.94|
000058  2001              MOVS     r0,#1                 ;704
00005a  9000              STR      r0,[sp,#0]            ;704
00005c  e001              B        |L51.98|
                  |L51.94|
00005e  2000              MOVS     r0,#0                 ;706
000060  9000              STR      r0,[sp,#0]            ;706
                  |L51.98|
000062  4a0a              LDR      r2,|L51.140|
000064  6812              LDR      r2,[r2,#0]            ;707  ; st
000066  7bd1              LDRB     r1,[r2,#0xf]          ;707
000068  4a08              LDR      r2,|L51.140|
00006a  6852              LDR      r2,[r2,#4]            ;707  ; st
00006c  7810              LDRB     r0,[r2,#0]            ;707
00006e  466b              MOV      r3,sp                 ;707
000070  2201              MOVS     r2,#1                 ;707
000072  f7fffffe          BL       MPU_Write_Len
000076  b110              CBZ      r0,|L51.126|
000078  f04f30ff          MOV      r0,#0xffffffff        ;708
00007c  e7d9              B        |L51.50|
                  |L51.126|
00007e  f89d1000          LDRB     r1,[sp,#0]            ;709
000082  4802              LDR      r0,|L51.140|
000084  7441              STRB     r1,[r0,#0x11]         ;709
                  |L51.134|
000086  2000              MOVS     r0,#0                 ;711
000088  e7d3              B        |L51.50|
;;;713    
                          ENDP

00008a  0000              DCW      0x0000
                  |L51.140|
                          DCD      ||st||

                          AREA ||i.setup_compass||, CODE, READONLY, ALIGN=1

                  setup_compass PROC
;;;2428   /* This initialization is similar to the one in ak8975.c. */
;;;2429   int setup_compass(void)
000000  f04f30ff          MOV      r0,#0xffffffff
;;;2430   {
;;;2431   #ifdef AK89xx_SECONDARY
;;;2432       unsigned char data[4], akm_addr;
;;;2433   
;;;2434       mpu_set_bypass(1);
;;;2435   
;;;2436       /* Find compass. Possible addresses range from 0x0C to 0x0F. */
;;;2437       for (akm_addr = 0x0C; akm_addr <= 0x0F; akm_addr++) {
;;;2438           int result;
;;;2439           result = i2c_read(akm_addr, AKM_REG_WHOAMI, 1, data);
;;;2440           if (!result && (data[0] == AKM_WHOAMI))
;;;2441               break;
;;;2442       }
;;;2443   
;;;2444       if (akm_addr > 0x0F) {
;;;2445           /* TODO: Handle this case in all compass-related functions. */
;;;2446           log_e("Compass not found.\n");
;;;2447           return -1;
;;;2448       }
;;;2449   
;;;2450       st.chip_cfg.compass_addr = akm_addr;
;;;2451   
;;;2452       data[0] = AKM_POWER_DOWN;
;;;2453       if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
;;;2454           return -1;
;;;2455       delay_ms(1);
;;;2456   
;;;2457       data[0] = AKM_FUSE_ROM_ACCESS;
;;;2458       if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
;;;2459           return -1;
;;;2460       delay_ms(1);
;;;2461   
;;;2462       /* Get sensitivity adjustment data from fuse ROM. */
;;;2463       if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ASAX, 3, data))
;;;2464           return -1;
;;;2465       st.chip_cfg.mag_sens_adj[0] = (long)data[0] + 128;
;;;2466       st.chip_cfg.mag_sens_adj[1] = (long)data[1] + 128;
;;;2467       st.chip_cfg.mag_sens_adj[2] = (long)data[2] + 128;
;;;2468   
;;;2469       data[0] = AKM_POWER_DOWN;
;;;2470       if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
;;;2471           return -1;
;;;2472       delay_ms(1);
;;;2473   
;;;2474       mpu_set_bypass(0);
;;;2475   
;;;2476       /* Set up master mode, master clock, and ES bit. */
;;;2477       data[0] = 0x40;
;;;2478       if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
;;;2479           return -1;
;;;2480   
;;;2481       /* Slave 0 reads from AKM data registers. */
;;;2482       data[0] = BIT_I2C_READ | st.chip_cfg.compass_addr;
;;;2483       if (i2c_write(st.hw->addr, st.reg->s0_addr, 1, data))
;;;2484           return -1;
;;;2485   
;;;2486       /* Compass reads start at this register. */
;;;2487       data[0] = AKM_REG_ST1;
;;;2488       if (i2c_write(st.hw->addr, st.reg->s0_reg, 1, data))
;;;2489           return -1;
;;;2490   
;;;2491       /* Enable slave 0, 8-byte reads. */
;;;2492       data[0] = BIT_SLAVE_EN | 8;
;;;2493       if (i2c_write(st.hw->addr, st.reg->s0_ctrl, 1, data))
;;;2494           return -1;
;;;2495   
;;;2496       /* Slave 1 changes AKM measurement mode. */
;;;2497       data[0] = st.chip_cfg.compass_addr;
;;;2498       if (i2c_write(st.hw->addr, st.reg->s1_addr, 1, data))
;;;2499           return -1;
;;;2500   
;;;2501       /* AKM measurement mode register. */
;;;2502       data[0] = AKM_REG_CNTL;
;;;2503       if (i2c_write(st.hw->addr, st.reg->s1_reg, 1, data))
;;;2504           return -1;
;;;2505   
;;;2506       /* Enable slave 1, 1-byte writes. */
;;;2507       data[0] = BIT_SLAVE_EN | 1;
;;;2508       if (i2c_write(st.hw->addr, st.reg->s1_ctrl, 1, data))
;;;2509           return -1;
;;;2510   
;;;2511       /* Set slave 1 data. */
;;;2512       data[0] = AKM_SINGLE_MEASUREMENT;
;;;2513       if (i2c_write(st.hw->addr, st.reg->s1_do, 1, data))
;;;2514           return -1;
;;;2515   
;;;2516       /* Trigger slave 0 and slave 1 actions at each sample. */
;;;2517       data[0] = 0x03;
;;;2518       if (i2c_write(st.hw->addr, st.reg->i2c_delay_ctrl, 1, data))
;;;2519           return -1;
;;;2520   
;;;2521   #ifdef MPU9150
;;;2522       /* For the MPU9150, the auxiliary I2C bus needs to be set to VDD. */
;;;2523       data[0] = BIT_I2C_MST_VDDIO;
;;;2524       if (i2c_write(st.hw->addr, st.reg->yg_offs_tc, 1, data))
;;;2525           return -1;
;;;2526   #endif
;;;2527   
;;;2528       return 0;
;;;2529   #else
;;;2530       return -1;
;;;2531   #endif
;;;2532   }
000004  4770              BX       lr
;;;2533   
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  ||reg||
000000  75191a0c          DCB      0x75,0x19,0x1a,0x0c
000004  6a231b1c          DCB      0x6a,0x23,0x1b,0x1c
000008  1f207274          DCB      0x1f,0x20,0x72,0x74
00000c  433b4138          DCB      0x43,0x3b,0x41,0x38
000010  393a6b6c          DCB      0x39,0x3a,0x6b,0x6c
000014  376f0624          DCB      0x37,0x6f,0x06,0x24
000018  6d6e7000          DCB      0x6d,0x6e,0x70,0x00
                  ||hw||
00001c  6800              DCB      0x68,0x00
00001e  0400              DCW      0x0400
000020  7600              DCB      0x76,0x00
000022  0154              DCW      0x0154
000024  fdf70100          DCW      0xfdf7,0x0100
                  test
                          DCD      0x00000083
                          DCD      0x00000800
000030  00010018          DCB      0x00,0x01,0x00,0x18
000034  0032              DCW      0x0032
000036  0500              DCB      0x05,0x00
000038  41200000          DCFS     0x41200000 ; 10
00003c  42d20000          DCFS     0x42d20000 ; 105
000040  3e0f5c29          DCFS     0x3e0f5c29 ; 0.14000000059604645
000044  3e99999a          DCFS     0x3e99999a ; 0.30000001192092896
000048  3f733333          DCFS     0x3f733333 ; 0.94999998807907104
00004c  3e0f5c29          DCFS     0x3e0f5c29 ; 0.14000000059604645

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  50726f64          DCB      "Product ID read as 0 indicates device is either incompa"
000004  75637420
000008  49442072
00000c  65616420
000010  61732030
000014  20696e64
000018  69636174
00001c  65732064
000020  65766963
000024  65206973
000028  20656974
00002c  68657220
000030  696e636f
000034  6d7061  
000037  7469626c          DCB      "tible or an MPU3050.\n",0
00003b  65206f72
00003f  20616e20
000043  4d505533
000047  3035302e
00004b  0a00    

                          AREA ||.data||, DATA, ALIGN=2

                  ||st||
                          DCD      ||reg||
                          DCD      ||hw||
000008  00000000          DCB      0x00,0x00,0x00,0x00
00000c  0000              DCB      0x00,0x00
00000e  0000              DCW      0x0000
000010  00000000          DCB      0x00,0x00,0x00,0x00
000014  00000000          DCB      0x00,0x00,0x00,0x00
                          %        8
000020  00000000          DCB      0x00,0x00,0x00,0x00
000024  0000              DCB      0x00,0x00
000026  0000              DCW      0x0000
                          DCD      test
                  gyro_orientation
00002c  01000000          DCB      0x01,0x00,0x00,0x00
000030  01000000          DCB      0x01,0x00,0x00,0x00
000034  01                DCB      0x01
